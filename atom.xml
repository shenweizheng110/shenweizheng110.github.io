<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>唯你の博客</title>
  
  <subtitle>记录生活学习中的事迹或bug</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://shenweini.cn/"/>
  <updated>2019-07-26T12:47:05.904Z</updated>
  <id>http://shenweini.cn/</id>
  
  <author>
    <name>ShenWeiZheng</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>原型链 与 继承的理解</title>
    <link href="http://shenweini.cn/2019/07/26/%E5%8E%9F%E5%9E%8B%E9%93%BE%20%E4%B8%8E%20%E7%BB%A7%E6%89%BF%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <id>http://shenweini.cn/2019/07/26/原型链 与 继承的理解/</id>
    <published>2019-07-26T12:47:05.904Z</published>
    <updated>2019-07-26T12:47:05.904Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原型链是前端面试几乎必问的东西，原型链实现了js中的继承。在看完阮一峰老师的博客后，理解了原型链的作用。</p></blockquote><h2 id="new-的由来"><a href="#new-的由来" class="headerlink" title="new 的由来"></a>new 的由来</h2><p>关于new的由来大家可以借阅阮一峰老师的博客<a href="http://www.ruanyifeng.com/blog/2011/06/designing_ideas_of_inheritance_mechanism_in_javascript.html" target="_blank" rel="noopener">Javascript继承机制的设计思想</a></p><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>在es5之前还没有类的时候，js都是 new 一个构造函数来生成一个构造函数的对象，这边的构造函数相当于java中的class，在es6之后，为了方便js也诞生了 class 关键字。<br>构造函数和普通的function最直观的区别是 构造函数的函数名是大写的，它张这个样子<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dog</span><span class="params">(name)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.type = <span class="string">'dog'</span>;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这边是定义了一个 Dog 的构造函数，那么我们可以使用 new 来创建一只狗</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> dog = <span class="keyword">new</span> Dog(<span class="string">'哈士奇'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(dog.name); <span class="comment">// 哈士奇</span></span><br></pre></td></tr></table></figure><p>至于构造函数中的this指向问题，这边就不说了，在我的上一篇博客详细的介绍了<a href="https://blog.csdn.net/qq_38606793/article/details/97309053" target="_blank" rel="noopener">js中的this指向问题</a>。</p><p>下面我们了解一下 new 一个对象的中间发生了什么</p><h2 id="new-的过程"><a href="#new-的过程" class="headerlink" title="new 的过程"></a>new 的过程</h2><p>节选自js高级程序设计（第三版），创建一个实例，一共分为四个步骤</p><p>（1）创建一个新对象；</p><p>（2）将构造函数的作用域赋给新对象（因此this就指向了这个新对象）；</p><p>（3）执行构造函数中的代码（为这个新对象添加属性）；</p><p>（4）返回新对象。</p><h2 id="new-的缺点"><a href="#new-的缺点" class="headerlink" title="new 的缺点"></a>new 的缺点</h2><p>前面提到了 new 运算符可以实例化一个对象，但是 new 也有一个缺点，就是new出来的两个对象之间没有任何的联系，做不到数据共享，这个缺点有违 new 创建的初衷。下面看一段示例<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dog</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.type = <span class="string">'dog'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> dogA = <span class="keyword">new</span> Dog(<span class="string">'哈士奇'</span>);</span><br><span class="line"><span class="keyword">let</span> dogB = <span class="keyword">new</span> Dog(<span class="string">'大金毛'</span>);</span><br><span class="line"></span><br><span class="line">dogA.type = <span class="string">'大型犬'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(dogB.type); <span class="comment">// 'dog'</span></span><br></pre></td></tr></table></figure></p><p>通过 Dog 构造函数实例化出了两个对象，修改其中一个对象的属性，并不会改变另一个对象的属性，这并不是 new 设计的初衷， dogA 和 dogB 两个对象之间无法做到数据共享，就好像没有任何关系一样。</p><h2 id="prototype-的引入"><a href="#prototype-的引入" class="headerlink" title="prototype 的引入"></a>prototype 的引入</h2><p>为了解决上面所述的问题，new 的创始人引入了 prototype 属性，</p><blockquote><p>这个属性包含一个对象（以下简称”prototype对象”），所有实例对象需要共享的属性和方法，都放在这个对象里面；那些不需要共享的属性和方法，就放在构造函数里面。</p><p>实例对象一旦创建，将自动引用prototype对象的属性和方法。也就是说，实例对象的属性和方法，分成两种，一种是本地的，另一种是引用的。</p></blockquote><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function Dog(name)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">&#125;</span><br><span class="line">Dog.prototype.<span class="keyword">type</span> = <span class="string">'dog'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> dogA = <span class="literal">new</span> Dog(<span class="string">'哈士奇'</span>);</span><br><span class="line"><span class="keyword">let</span> dogB = <span class="literal">new</span> Dog(<span class="string">'大金毛'</span>);</span><br><span class="line"></span><br><span class="line">console.<span class="keyword">log</span>(dogA.<span class="keyword">type</span>); <span class="comment">// dog</span></span><br><span class="line">Dog.prototype.<span class="keyword">type</span> = <span class="string">'大型犬'</span>;</span><br><span class="line">console.<span class="keyword">log</span>(dogA.<span class="keyword">type</span>, dogB.<span class="keyword">type</span>); <span class="comment">//大型犬 大型犬</span></span><br></pre></td></tr></table></figure><p>type属性是 Dog实例化出的对象所共享的属性，只要修改了 prototype中的type属性，每一个对象的 type 值都会被改变。</p><h2 id="构造函数实现继承"><a href="#构造函数实现继承" class="headerlink" title="构造函数实现继承"></a>构造函数实现继承</h2><p>构造函数实现继承有很多中实现方式，首先看第一种</p><h3 id="call-apply-绑定"><a href="#call-apply-绑定" class="headerlink" title="call apply 绑定"></a>call apply 绑定</h3><p>这种是直接将父构造函数绑定在子构造函数中<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.type = <span class="string">'dog'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dog</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    Animal.call(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> dogA = <span class="keyword">new</span> Dog(<span class="string">'哈士奇'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(dogA.type); <span class="comment">// dog</span></span><br></pre></td></tr></table></figure></p><h3 id="使用prototype进行继承"><a href="#使用prototype进行继承" class="headerlink" title="使用prototype进行继承"></a>使用prototype进行继承</h3><p>由于 prototype 属性可以存在对象共享的属性，那么我们可以按照封装的思想，将公共的部分抽离出来，变成一个公共的构造函数，也就是这些对象的父类也是基类，我觉得叫基类更加的合适，因为它存储着每一个对象的公共部分。实现方式只需要将子构造函数的 prototype 属性赋值为父构造函数<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.type = <span class="string">'dog'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dog</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Dog.prototype = <span class="keyword">new</span> Animal();</span><br><span class="line">Dog.prototype.constructor = Dog;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> dogA = <span class="keyword">new</span> Dog(<span class="string">'哈士奇'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(dogA.type); <span class="comment">// dog</span></span><br></pre></td></tr></table></figure></p><ul><li>第 9 行：将Dog 的原型属性赋值为Animal的实例</li><li>第 10 行：修改 prototype 属性的costructor对象为Dog，这是因为每一个 prototype 对象都包含了它的构造函数对象，在上一行将 Dog 的原型直接赋值为 Animal的构造函数，所以此时Dog的原型对象中的 constructor其实是指向Animal的构造函数的，所以我们这边要修改回来，不然引起原型链的絮乱。</li></ul><h3 id="直接继承prototype"><a href="#直接继承prototype" class="headerlink" title="直接继承prototype"></a>直接继承prototype</h3><blockquote><p>第三种方法是对第二种方法的改进。由于Animal对象中，不变的属性都可以直接写入Animal.prototype。所以，我们也可以让Cat()跳过 Animal()，直接继承Animal.prototype。</p></blockquote><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span><span class="params">()</span><span class="comment">&#123; &#125;</span>;</span></span><br><span class="line">Animal.prototype.<span class="keyword">type</span> = <span class="string">'dog'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dog</span><span class="params">(<span class="keyword">name</span>)</span><span class="comment">&#123;</span></span></span><br><span class="line"><span class="function"><span class="comment">    this.name = name;</span></span></span><br><span class="line"><span class="function"><span class="comment">&#125;</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">Dog</span>.<span class="title">prototype</span> = <span class="title">Animal</span>.<span class="title">prototype</span>;</span></span><br><span class="line">Dog.prototype.<span class="keyword">constructor</span> = Dog;</span><br><span class="line"></span><br><span class="line">let dogA = new Dog(<span class="string">'哈士奇'</span>);</span><br><span class="line">console.log(dogA.<span class="keyword">type</span>); <span class="comment">// dog</span></span><br></pre></td></tr></table></figure><p>这种方法相比于第二种方法，优点是效率高，因为他跳过了执行创建一个 Animal 实例，省内存。但是也有缺点，缺点是直接将 Animal 的prototype 属性赋值给了 Dog 的 prototype 这是一个浅拷贝，因为prototype 是一个 object，所以对于任何Dog 的 prototype的修改都会响应在 Animal.prototype；</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log<span class="params">(Animal.prototype.<span class="attr">constructor</span> === Dog)</span>; <span class="string">//</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>我们在第 9 行修改了Dog.prototype中的 constructor属性，这边打印发现 Animal 的 prototype中的 constructor 也指向了 Dog</p><h3 id="利用空对象作为中介"><a href="#利用空对象作为中介" class="headerlink" title="利用空对象作为中介"></a>利用空对象作为中介</h3><p>为了解决上面一种方式引起的问题，可以采用空对象作为媒介。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params"></span>)</span>&#123; &#125;;</span><br><span class="line">Animal.prototype.type = <span class="string">'dog'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dog</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Temp = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; &#125;;</span><br><span class="line">Temp.prototype = Animal.prototype;</span><br><span class="line">Dog.prototype = <span class="keyword">new</span> Temp();</span><br><span class="line">Dog.prototype.constructor = Dog;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> dogA = <span class="keyword">new</span> Dog(<span class="string">'哈士奇'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(dogA.type); <span class="comment">// dog</span></span><br><span class="line"><span class="built_in">console</span>.log(Animal.prototype.constructor === Dog); <span class="comment">// false</span></span><br></pre></td></tr></table></figure></p><p>利用空对象作为媒介，空对象几乎不占内存，也不会影响 Animal 的 prototype</p><h3 id="拷贝继承"><a href="#拷贝继承" class="headerlink" title="拷贝继承"></a>拷贝继承</h3><p>顾名思义，就是将父对象的所有属性和方法，拷贝进子对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params"></span>)</span>&#123; &#125;;</span><br><span class="line">Animal.prototype.type = <span class="string">'dog'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dog</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">extendOfCopy</span>(<span class="params">Child, Parent</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> c = Child.prototype;</span><br><span class="line">    <span class="keyword">let</span> p = Parent.prototype;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">in</span> p)&#123;</span><br><span class="line">        c[i] = p[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">extendOfCopy(Dog, Animal);</span><br><span class="line"><span class="keyword">let</span> dogA = <span class="keyword">new</span> Dog(<span class="string">'哈士奇'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(dogA.type); <span class="comment">// dog</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;原型链是前端面试几乎必问的东西，原型链实现了js中的继承。在看完阮一峰老师的博客后，理解了原型链的作用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;new-的由来&quot;&gt;&lt;a href=&quot;#new-的由来&quot; class=&quot;headerlink
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>js 微任务 宏任务</title>
    <link href="http://shenweini.cn/2019/07/26/js%20%E5%BE%AE%E4%BB%BB%E5%8A%A1%20%E5%AE%8F%E4%BB%BB%E5%8A%A1%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%E8%A7%A3%E9%87%8A/"/>
    <id>http://shenweini.cn/2019/07/26/js 微任务 宏任务的执行顺序解释/</id>
    <published>2019-07-26T01:19:57.075Z</published>
    <updated>2019-07-26T01:19:57.075Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>js 是单线程执行的，js中的任务按顺序一个一个的执行，但是一个任务耗时太长，那么后面的任务就需要等待，为了解决这种情况，将任务分为了同步任务和异步任务，而异步任务又可以分为微任务和宏任务。</p></blockquote><p>首先第一段示例代码<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">console.<span class="built_in">log</span>(<span class="string">'script start'</span>);</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span><span class="params">()</span></span> &#123;</span><br><span class="line">  console.<span class="built_in">log</span>(<span class="string">'setTimeout'</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">Promise.resolve().<span class="keyword">then</span>(<span class="function"><span class="keyword">function</span><span class="params">()</span></span> &#123;</span><br><span class="line">  console.<span class="built_in">log</span>(<span class="string">'promise1'</span>);</span><br><span class="line">&#125;).<span class="keyword">then</span>(<span class="function"><span class="keyword">function</span><span class="params">()</span></span> &#123;</span><br><span class="line">  console.<span class="built_in">log</span>(<span class="string">'promise2'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">console.<span class="built_in">log</span>(<span class="string">'script end'</span>);</span><br></pre></td></tr></table></figure></p><p>打印顺序为：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">script start</span><br><span class="line">script end</span><br><span class="line">promise1</span><br><span class="line">promise</span><br><span class="line">setTimeout</span><br></pre></td></tr></table></figure></p><p>具体为什么会打印出这个顺序，下面在具体解释。<br>我们具体看一下js的执行流程：<br><img src="http://static.zybuluo.com/shenweizheng/iy5q6fscnpe2c6cch47ck9na/image_1dglrup181e0m18gr10lc187e19549.png" alt="image_1dglrup181e0m18gr10lc187e19549.png-496.3kB"></p><p><a href="https://juejin.im/post/5b498d245188251b193d4059" target="_blank" rel="noopener">张倩qianniuerlv-2 JS事件循环机制（event loop）之宏任务/微任务</a>解读：</p><ol><li>同步和异步任务分别进入不同的执行”场所”，同步的进入主线程，异步的进入Event Table并注册函数</li><li>当指定的事情完成时，Event Table会将这个函数移入Event Queue。</li><li>主线程内的任务执行完毕为空，会去Event Queue读取对应的函数，进入主线程执行。</li><li>上述过程会不断重复，也就是常说的Event Loop(事件循环)。</li></ol><p>在js引擎中，存在一个叫monitoring process的进程，这个进程会不断的检查主线程的执行情况，一旦为空，就会去Event Quene检查有哪些待执行的函数。</p><h2 id="微任务-和-宏任务"><a href="#微任务-和-宏任务" class="headerlink" title="微任务 和 宏任务"></a>微任务 和 宏任务</h2><blockquote><p>微任务和宏任务的问题应该是前端面试中比较常见的，他们都从属于异步任务，主要区别在于他们的执行顺序，Event Loop的走向和取值</p></blockquote><p><img src="http://static.zybuluo.com/shenweizheng/cegc5egyrr3orq4ylwf1136k/image_1dglsb50i1tvh1ul01ur318fa6h39.png" alt="image_1dglsb50i1tvh1ul01ur318fa6h39.png-293.5kB"></p><p>这张图的意思就是：</p><ol><li>存在微任务的话，那么就执行所有的微任务</li><li>微任务都执行完之后，执行第一个宏任务，</li><li>循环 1， 2</li></ol><p>从参考博主的博客里看到这段，这边不得不提一句，我也是看了这为博主的博客才理清楚了微任务和宏任务的概念。博主的链接会在文章末给出。</p><blockquote><p>一个掘金的老哥（ssssyoki）的文章摘要：<br>那么如此看来我给的答案还是对的。但是js异步有一个机制，就是遇到宏任务，先执行宏任务，将宏任务放入eventqueue，然后在执行微任务，将微任务放入eventqueue最骚的是，这两个queue不是一个queue。当你往外拿的时候先从微任务里拿这个回掉函数，然后再从宏任务的queue上拿宏任务的回掉函数。 我当时看到这我就服了还有这种骚操作。</p></blockquote><p>这边我们可以看出，微任务和宏任务是同属于两个不同的队列的！！！</p><ul><li>宏任务一般包括：整体代码script，setTimeout，setInterval、setImmediate。</li><li>微任务一般包括：原生Promise(有些实现的promise将then方法放到了宏任务中)、process.nextTick、Object.observe(已废弃)、 MutationObserver </li></ul><p>一段丧心病狂的代码<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'1'</span>);</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'2'</span>);</span><br><span class="line">    process.nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'3'</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'4'</span>);</span><br><span class="line">        resolve();</span><br><span class="line">    &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'5'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">process.nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'6'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'7'</span>);</span><br><span class="line">    resolve();</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'8'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'9'</span>);</span><br><span class="line">    process.nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'10'</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'11'</span>);</span><br><span class="line">        resolve();</span><br><span class="line">    &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'12'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>第一轮循环：</p><ul><li>首先打印 1</li><li>下面是setTimeout是异步任务且是宏任务，加入宏任务暂且记为 setTimeout1</li><li>下面是 process 微任务 加入微任务队列 记为 process1</li><li>下面是 new Promise 里面直接 resolve(7) 所以打印 7 后面的then是微任务 记为 then1</li><li>setTimeout 宏任务 记为 setTimeout2</li></ul><p>第一轮循环打印出的是 1 7<br>当前宏任务队列：setTimeout1, setTimeout2<br>当前微任务队列：process1, then1, </p><p>第二轮循环：</p><ul><li>执行所有微任务</li><li>执行process1，打印出 6 </li><li>执行then1 打印出8</li><li>微任务都执行结束了，开始执行第一个宏任务</li><li>执行  setTimeout1 也就是 第 3 - 14 行</li><li>首先打印出 2</li><li>遇到 process 微任务 记为 process2</li><li>new Promise中resolve 打印出 4</li><li>then 微任务 记为 then2</li></ul><p>第二轮循环结束，当前打印出来的是  1 7 6 8 2 4<br>当前宏任务队列：setTimeout2<br>当前微任务队列：process2, then2</p><p>第三轮循环：</p><ul><li>执行所有的微任务</li><li>执行 process2 打印出 3</li><li>执行 then2 打印出 5</li><li>执行第一个宏任务，也就是执行 setTimeout2 对应代码中的 25 - 36 行</li><li>首先打印出 9</li><li>process 微任务 记为 process3</li><li>new Promise执行resolve 打印出 11</li><li>then 微任务 记为 then3</li></ul><p>当前打印顺序为：1 7 6 8 2 4 3 5 9 11<br>当前宏任务队列为空<br>当前微任务队列：process3，then3</p><p>第四轮循环：</p><ul><li>执行所有的微任务</li><li>执行process3 打印出 10</li><li>执行then3 打印出 12</li></ul><p>代码执行结束：<br>最终打印顺序为：1 7 6 8 2 4 3 5 9 11 10 12<br>(请注意，node环境下的事件监听依赖libuv与前端环境不完全相同，输出顺序可能会有误差)</p><p>参考文章：<br><a href="https://juejin.im/post/5b498d245188251b193d4059" target="_blank" rel="noopener">JS事件循环机制（event loop）之宏任务/微任务</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;js 是单线程执行的，js中的任务按顺序一个一个的执行，但是一个任务耗时太长，那么后面的任务就需要等待，为了解决这种情况，将任务分为了同步任务和异步任务，而异步任务又可以分为微任务和宏任务。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;首先第一段示例
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>对 js 中的this 的理解</title>
    <link href="http://shenweini.cn/2019/07/25/%E5%AF%B9%20js%20%E4%B8%AD%20this%20%E6%8C%87%E5%90%91%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <id>http://shenweini.cn/2019/07/25/对 js 中 this 指向的理解/</id>
    <published>2019-07-25T14:11:00.364Z</published>
    <updated>2019-07-25T14:11:00.364Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>this 指针一直都是一个很玄学的东西，它是函数运行时，函数内部自动生成的对象，只能在函数体内部使用。一下示例都是测试过的，对于答案请放心。如有疑问欢迎评论</p></blockquote><h2 id="纯粹的函数调用"><a href="#纯粹的函数调用" class="headerlink" title="纯粹的函数调用"></a>纯粹的函数调用</h2><blockquote><p>这是函数通常的用法，属于全局性的调用，所以this指向全局。</p></blockquote><p>最简单的示例<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="keyword">this</span>.x);</span><br><span class="line">&#125;</span><br><span class="line">test();  <span class="comment">// 1</span></span><br></pre></td></tr></table></figure></p><h2 id="作为对象的一个属性"><a href="#作为对象的一个属性" class="headerlink" title="作为对象的一个属性"></a>作为对象的一个属性</h2><blockquote><p>此时，谁调用这个函数，函数内部的this就指向谁</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">'window'</span>;</span><br><span class="line"><span class="keyword">var</span> test = &#123;</span><br><span class="line">    name: <span class="string">'test'</span>,</span><br><span class="line">    getName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">test.getName(); <span class="comment">// test</span></span><br></pre></td></tr></table></figure><h2 id="作为构造函数的一个属性"><a href="#作为构造函数的一个属性" class="headerlink" title="作为构造函数的一个属性"></a>作为构造函数的一个属性</h2><blockquote><p>this指向当前实例</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">'window'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">'test'</span>;</span><br><span class="line">    <span class="keyword">this</span>.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> test = <span class="keyword">new</span> Test();</span><br><span class="line">test.getName(); <span class="comment">// test</span></span><br></pre></td></tr></table></figure><h2 id="call、apply、bind修改this指向"><a href="#call、apply、bind修改this指向" class="headerlink" title="call、apply、bind修改this指向"></a>call、apply、bind修改this指向</h2><p>使用call 和 apply 方法可以修改this的指向，两者的区别为：</p><blockquote><p>call this后面的参数为一个参数列表<br>apply this后面的参数为一个数组<br>bind bind绑定返回一个新的函数，bind的中this后面的参数是预先添加到绑定函数的参数列表中的参数。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> test = &#123;</span><br><span class="line">    name: <span class="string">'test'</span>,</span><br><span class="line">    getName: <span class="function"><span class="keyword">function</span>(<span class="params">extraParam1, extraParam2</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name, extraParam1, extraParam2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> testCall = &#123;</span><br><span class="line">    name: <span class="string">'testCall'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test.getName.call(testCall,<span class="string">'extraParam1'</span>,<span class="string">'extraParam2'</span>);</span><br><span class="line"><span class="comment">// testCall extraParam1 extraParam2</span></span><br></pre></td></tr></table></figure><p>这边可以看到打印出的时testCall对象的name属性，并且call方法后面携带的是一个参数列表</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> test = &#123;</span><br><span class="line">    name: <span class="string">'test'</span>,</span><br><span class="line">    getName: <span class="function"><span class="keyword">function</span>(<span class="params">extraParam1, extraParam2</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name, extraParam1, extraParam2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> testApply = &#123;</span><br><span class="line">    name: <span class="string">'testApply'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test.getName.apply(testApply,[<span class="string">'extraParam1'</span>,<span class="string">'extraParam2'</span>]);</span><br><span class="line"><span class="comment">// testApply extraParam1 extraParam2</span></span><br></pre></td></tr></table></figure><p>apply的参数为一个参数数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> test = &#123;</span><br><span class="line">    name: <span class="string">'test'</span>,</span><br><span class="line">    getName: <span class="function"><span class="keyword">function</span>(<span class="params">extraParam1, extraParam2</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name, extraParam1, extraParam2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> testBind = &#123;</span><br><span class="line">    name: <span class="string">'testBind'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> getNameBind = test.getName.bind(testBind,<span class="string">'前置参数'</span>);</span><br><span class="line">getNameBind(<span class="string">'extraParam1'</span>); <span class="comment">// testBind 前置参数 extraParam1</span></span><br><span class="line">test.getName(<span class="string">'extraParam1'</span>,<span class="string">'extraParam2'</span>); <span class="comment">// test extraParam1 extraParam2</span></span><br></pre></td></tr></table></figure><p>bind返回一个新的函数</p><h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><blockquote><p>箭头函数本身并不具备this对象，内部的this对象是继承父级作用域中的this,且箭头函数的this不可使用call、apply修改指向，但是可以通过修改父级的this来实现。简单来说要想知道箭头函数的this，需要查看箭头函数的定义位置，而不是调用位置。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.name = <span class="string">'window'</span>;</span><br><span class="line"><span class="keyword">var</span> test = &#123;</span><br><span class="line">    name: <span class="string">'getName'</span>,</span><br><span class="line">    getName: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> testCall = &#123;</span><br><span class="line">    name: <span class="string">'testCall'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> testApply = &#123;</span><br><span class="line">    name: <span class="string">'testApply'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> testBind = &#123;</span><br><span class="line">    name: <span class="string">'testBind'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test.getName(); <span class="comment">// window</span></span><br><span class="line">test.getName.call(testCall); <span class="comment">// window</span></span><br><span class="line">test.getName.apply(testApply); <span class="comment">// window</span></span><br><span class="line">test.getName.bind(testBind)(); <span class="comment">// window</span></span><br></pre></td></tr></table></figure><p>箭头函数定义在 test 对象的内部，test的作用域为全局作用域，所以，getName函数中的this指向的是全局，与调用位置无关。且无法通过call apply bind 直接修改this指向。然后在看下一个示例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.name = <span class="string">'window'</span>;</span><br><span class="line"><span class="keyword">var</span> test = &#123;</span><br><span class="line">    name: <span class="string">'test'</span>,</span><br><span class="line">    getName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> testCall = &#123;</span><br><span class="line">    name: <span class="string">'testCall'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> testApply = &#123;</span><br><span class="line">    name: <span class="string">'testApply'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> testBind = &#123;</span><br><span class="line">    name: <span class="string">'testBind'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test.getName()(); <span class="comment">// test</span></span><br><span class="line">test.getName.call(testCall)(); <span class="comment">// testCall</span></span><br><span class="line">test.getName.apply(testApply)(); <span class="comment">// testApply</span></span><br><span class="line">test.getName.bind(testBind)()(); <span class="comment">// testBind</span></span><br></pre></td></tr></table></figure><p>getName函数返回一个箭头函数，所以初始时箭头函数的父级作用域为getName函数的内部作用域，所以此时this指向应该是看谁调用getName就指向谁。既然如此的话，那我们就可以通过call、apply、bind来修改getName的this指向从而改变箭头函数的this指向。</p><p>说完以上几种情况，下面看两个综合题<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">'window'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = &#123;</span><br><span class="line">    name: <span class="string">'person1'</span>,</span><br><span class="line">    show1: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">    &#125;,</span><br><span class="line">    show2: <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="keyword">this</span>.name),</span><br><span class="line">    show3: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    show4: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person2 = &#123; <span class="attr">name</span>: <span class="string">'person2'</span> &#125;</span><br><span class="line"></span><br><span class="line">person1.show1() <span class="comment">// person1</span></span><br><span class="line">person1.show1.call(person2) <span class="comment">// person2</span></span><br><span class="line"></span><br><span class="line">person1.show2() <span class="comment">// window</span></span><br><span class="line">person1.show2.call(person2) <span class="comment">// window</span></span><br><span class="line"></span><br><span class="line">person1.show3()() <span class="comment">// window</span></span><br><span class="line">person1.show3().call(person2) <span class="comment">// person2</span></span><br><span class="line">person1.show3.call(person2)() <span class="comment">// window</span></span><br><span class="line"></span><br><span class="line">person1.show4()() <span class="comment">// person1</span></span><br><span class="line">person1.show4().call(person2) <span class="comment">// person1</span></span><br><span class="line">person1.show4.call(person2)() <span class="comment">// person2</span></span><br></pre></td></tr></table></figure></p><p>第 20 行：show1为普通函数，this指向调用对象，这边是person1调用，所以指向person1</p><p>第 21 行：使用call将show1函数的指针指向person2</p><p>第 23 行：show2函数为箭头函数，父级作用域为person1作用域即全局作用域，所以this指向window</p><p>地 24 行：箭头函数的this指向在定义时就已经确定。不随着call进行修改，所以此处this依旧是指向window</p><p>第 26 行：show3 返回一个函数，然后调用这个返回的函数，此行等价于<br><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let show<span class="number">3</span> = perso<span class="symbol">n1</span>.show<span class="number">3</span><span class="comment">()</span>; </span><br><span class="line">show<span class="number">3</span><span class="comment">()</span></span><br></pre></td></tr></table></figure></p><p>属于第一种情况，函数的直接调用，this指向全局</p><p>第 27 行：使用call将show3函数返回的函数的this指向了person2，等价与于<br><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let show<span class="number">3</span> = perso<span class="symbol">n1</span>.show<span class="number">3</span><span class="comment">()</span>;</span><br><span class="line">show<span class="number">3.</span><span class="keyword">call</span><span class="comment">(person2)</span>;</span><br></pre></td></tr></table></figure></p><p>第 28 行：和第 26 行道理一样，等价于<br><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let show<span class="number">3</span> = perso<span class="symbol">n1</span>.show<span class="number">3.</span><span class="keyword">call</span><span class="comment">(person2)</span>;</span><br><span class="line">show<span class="number">3</span><span class="comment">()</span>;</span><br></pre></td></tr></table></figure></p><p>函数直接调用，this指向全局</p><p>第 30 行：show4返回的是一个箭头函数，箭头函数的this是继承的父级函数show4的this，所以此处箭头函数的this取决于show4的this指向，此处使用person1进行调用，所以shoe4的this指向person1</p><p>第 31 行：show4返回的是一个箭头函数，箭头函数的this不会被call改变，依旧时取决于父级的show4函数的this，此处person1进行调用，所以依旧是指向的this</p><p>第 32 行：修改了show4函数的this指向，指向了person2，由于上面说的，此处箭头函数的this是取决于show4的，所以箭头函数的this也指向了person2。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">'window'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.show1 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.show2 = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">    <span class="keyword">this</span>.show3 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.show4 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> personA = <span class="keyword">new</span> Person(<span class="string">'personA'</span>)</span><br><span class="line"><span class="keyword">var</span> personB = <span class="keyword">new</span> Person(<span class="string">'personB'</span>)</span><br><span class="line"></span><br><span class="line">personA.show1() <span class="comment">// personA</span></span><br><span class="line">personA.show1.call(personB) <span class="comment">// personB</span></span><br><span class="line"></span><br><span class="line">personA.show2() <span class="comment">// personA</span></span><br><span class="line">personA.show2.call(personB) <span class="comment">// personA</span></span><br><span class="line"></span><br><span class="line">personA.show3()() <span class="comment">// window</span></span><br><span class="line">personA.show3().call(personB) <span class="comment">// personB</span></span><br><span class="line">personA.show3.call(personB)() <span class="comment">// window</span></span><br><span class="line"></span><br><span class="line">personA.show4()() <span class="comment">// personA</span></span><br><span class="line">personA.show4().call(personB) <span class="comment">// personA</span></span><br><span class="line">personA.show4.call(personB)() <span class="comment">// personB</span></span><br></pre></td></tr></table></figure><p>此题是一个构造函数，并且示例化出两个对象，personA 和 personB。<br>第 22 行：构造函数实例的对象调用函数，函数this指向调用对象，所以此处是指向了personA</p><p>第 23 行：show1函数的this被call修改，指向 personB</p><p>第 25 行：show2 为一个箭头函数，this指向父级作用域，此处也就是构造函数内部，取决于调用对象，此处是personA进行调用，所以this指向了personA</p><p>第 26 行：箭头函数的this指向不会被call修改，所以依旧是指向personA</p><p>第 28 行：show3 返回一个函数，属于全局调用，this指向全局，等价于<br><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let show3 = personA.show3()<span class="comment">;</span></span><br><span class="line">show3()<span class="comment">;</span></span><br></pre></td></tr></table></figure></p><p>第 29 行：等价于<br><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let show3 = personA.show3()<span class="comment">;</span></span><br><span class="line">show3.call(personB)<span class="comment">;</span></span><br></pre></td></tr></table></figure></p><p>第 30 行：等价于<br><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let show3 = personA.show3.call(personB)<span class="comment">;</span></span><br><span class="line">show3()<span class="comment">;</span></span><br></pre></td></tr></table></figure></p><p>第 32 行：show4 返回一个箭头函数，取决于show4的调用者，此处为 personA</p><p>第 33 行：箭头函数的this不会被call修改，此处依旧取决于 show4 的调用者，指向 personA</p><p>第 34 行：修改 show4 的this指向，而箭头函数的this取决于show4 所以此处this指向了 personB</p><p>以上为对js中this指向的阐述。得出结论：代码 === 玄学</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;this 指针一直都是一个很玄学的东西，它是函数运行时，函数内部自动生成的对象，只能在函数体内部使用。一下示例都是测试过的，对于答案请放心。如有疑问欢迎评论&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;纯粹的函数调用&quot;&gt;&lt;a href=&quot;#
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>js 变量提升和作用域的理解</title>
    <link href="http://shenweini.cn/2019/07/25/js%20%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87%E5%92%8C%E4%BD%9C%E7%94%A8%E5%9F%9F%E7%9A%84i%E7%90%86%E8%A7%A3/"/>
    <id>http://shenweini.cn/2019/07/25/js 变量提升和作用域的i理解/</id>
    <published>2019-07-25T06:45:29.270Z</published>
    <updated>2019-07-25T06:45:29.270Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>js 中的变量提升大体可以分为两种，一种是使用 var 声明的变量，另一种是函数的变量提升，而函数的创建可以分为函数声明和函数表达式两种，这两种具有不同的变量提升，以下为本人根据自己的理解参考其他博主的博客得出的看法，如有错误欢迎指正。</p></blockquote><h2 id="使用var声明的变量"><a href="#使用var声明的变量" class="headerlink" title="使用var声明的变量"></a>使用var声明的变量</h2><p>我们首先先看一段代码，<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">scopeTest</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(test); <span class="comment">// undefined</span></span><br><span class="line">    <span class="keyword">var</span> test = <span class="string">'hello'</span>;</span><br><span class="line">&#125;</span><br><span class="line">scopeTest();</span><br></pre></td></tr></table></figure></p><p>以上代码输出的结果是 <code>undefined</code>，原因是 js 对于使用var声明的变量具有变量提升的特性，函数内部会首先声明函数内部需要的变量并赋值为undefined。以上代码等价于<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">scopeTest</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> test;</span><br><span class="line">    <span class="built_in">console</span>.log(test);</span><br><span class="line">    test = <span class="string">'hello'</span>;</span><br><span class="line">&#125;</span><br><span class="line">scopeTest();</span><br></pre></td></tr></table></figure></p><blockquote><p>没有使用var声明的会变成全局变量<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> test = <span class="string">'hello'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">scopeTest</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(test) <span class="comment">// hello</span></span><br><span class="line">    test = <span class="string">'helloworld'</span>;</span><br><span class="line">&#125;</span><br><span class="line">scopeTest();</span><br><span class="line"><span class="built_in">console</span>.log(test); <span class="comment">// helloworld</span></span><br></pre></td></tr></table></figure></p></blockquote><p>函数中的 test 变量没有使用var进行声明，所以并不具备变量提升，此时打印，打印的是上层作用域的test即 hello，由于 test 是直接声明的，那么 test 会成为全局变量，覆盖掉已经有的 test ，所以为函数执行完打印 test 输出的是 helloworld</p><h2 id="函数提升"><a href="#函数提升" class="headerlink" title="函数提升"></a>函数提升</h2><blockquote><p>函数的创建分为两种，一种是使用function加函数名进行声明，另一中将函数赋值给变量</p></blockquote><p>首先看第一种，声明方式如下<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a=<span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a); <span class="comment">//[Function: a]</span></span><br><span class="line">    a=<span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure></p><p>这边我们可以看到最后打印的出的 a 是 1 而不是函数里赋值的10，原因是函数具有变量提升的特性，以上代码等价于<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a=<span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123; &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(a); <span class="comment">//[Function: a]</span></span><br><span class="line">    a=<span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure></p><p>函数内部首先声明 function a 此时函数内部的 a 为function类型，此时打印 a 可以看出是一个function 接下来 a = 10 将 a 的类型转为 number 并赋值为 10；然后return 函数销毁，函数内部的 a 变量被回收。最后打印的 a 还是全局的 a</p><p>上面是使用 function 进行申明的，下面试一下使用函数表达式的方式进行声明<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a=<span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a); <span class="comment">//undefined</span></span><br><span class="line">    a=<span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure></p><p>这边可以看到第 3 行打印的是 undefined 而不是 function，同样具有变量提升但是两者却不一样，使用函数表达式的方式进行声明函数只会定义变量，函数体和函数内容并不会携带，但是使用function加函数名的方式会将函数名和函数体一起提升到函数的头部。<br>以上代码等价于<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a=<span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a;</span><br><span class="line">    <span class="built_in">console</span>.log(a); <span class="comment">//undefined</span></span><br><span class="line">    a=<span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">    a = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure></p><h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>js 的作用域分为全局作用域和函数作用域，没有块级作用域，说起作用域就得说到作用域链。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> global=<span class="string">'global context'</span>;</span><br><span class="line"><span class="keyword">var</span> inner=<span class="string">'global inner context'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(global); </span><br><span class="line">    <span class="built_in">console</span>.log(inner);</span><br><span class="line">    <span class="keyword">var</span> inner=<span class="string">'inner context'</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(inner);</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure></p><p>第4行：foo 函数内部，首先打印global，由于函数内部没有这个变量，那么会从foo函数的外部作用域开始找这个变量，然后打印。<br>第5行：inner这个变量，由于变量提升，所有函数的头部存在inner变量的定义，打印出undefined<br>第7行：inner变量赋值，打印出 inner context</p><p>与作用域息息相关的是闭包，this指向问题。</p><p>感谢博主的文章<br><a href="https://www.liaoxuefeng.com/wiki/1022910821149312/1023021187855808" target="_blank" rel="noopener">廖雪峰-变量作用域与解构赋值</a><br><a href="https://segmentfault.com/a/1190000000618597" target="_blank" rel="noopener">深入javascript——作用域和闭包</a><br><a href="https://segmentfault.com/a/1190000013656524" target="_blank" rel="noopener">js 变量提升和闭包理解</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;js 中的变量提升大体可以分为两种，一种是使用 var 声明的变量，另一种是函数的变量提升，而函数的创建可以分为函数声明和函数表达式两种，这两种具有不同的变量提升，以下为本人根据自己的理解参考其他博主的博客得出的看法，如有错误欢迎指正。&lt;/p&gt;
&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>js快排尾递归优化</title>
    <link href="http://shenweini.cn/2019/03/25/js%E5%BF%AB%E6%8E%92%E5%B0%BE%E9%80%92%E5%BD%92%E4%BC%98%E5%8C%96/"/>
    <id>http://shenweini.cn/2019/03/25/js快排尾递归优化/</id>
    <published>2019-03-25T13:09:51.000Z</published>
    <updated>2019-03-25T13:09:51.000Z</updated>
    
    <content type="html"><![CDATA[<p>尾递归是个什么东西这边就不介绍了。总之递归我是一直没有搞明白。但是我知道尾递归是为了解决递归造成的栈溢出和大量重复的计算。</p><h2 id="常规版本"><a href="#常规版本" class="headerlink" title="常规版本"></a>常规版本</h2><pre><code>function quickSort(arr, left, right) {    // 递归跳出条件    if (left &gt;= right)        return;    let i = left,        j = right,        flag = arr[left]; // 定义的基准    while (i &lt; j) {        // 找到比flag小的        while (i &lt; j &amp;&amp; arr[j] &gt;= flag)            j--;        // 找到比flag大的        while (i &lt; j &amp;&amp; arr[i] &lt;= flag)            i++;        // 交换i和j        if (i &lt;= j) {            let temp = arr[i];            arr[i] = arr[j];            arr[j] = temp;        }    }    // 交换基准和i    arr[left] = arr[i];    arr[i] = flag;    // 对左边快排    quickSort(arr, left, i - 1);    // 对右边快排    quickSort(arr, i + 1, right);}let testArr = [2, 4, 1, 5, 8, 6, 7, 9, 0];quickSort(testArr, 0, testArr.length - 1);console.log(testArr);</code></pre><h2 id="尾递归版本"><a href="#尾递归版本" class="headerlink" title="尾递归版本"></a>尾递归版本</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tailQuickSort</span><span class="params">(arr, left, right)</span> &#123;</span></span><br><span class="line">    let <span class="built_in">i</span> = left,</span><br><span class="line">        <span class="built_in">j</span> = right,</span><br><span class="line">        flag = arr[left];</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">i</span> &lt; <span class="built_in">j</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">i</span> &lt; <span class="built_in">j</span> &amp;&amp; arr[<span class="built_in">j</span>] &gt;= flag)</span><br><span class="line">            <span class="built_in">j</span>--;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">i</span> &lt; <span class="built_in">j</span> &amp;&amp; arr[<span class="built_in">i</span>] &lt;= flag)</span><br><span class="line">            <span class="built_in">i</span>++;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">i</span> &lt; <span class="built_in">j</span>) &#123;</span><br><span class="line">            let temp = arr[<span class="built_in">i</span>];</span><br><span class="line">            arr[<span class="built_in">i</span>] = arr[<span class="built_in">j</span>];</span><br><span class="line">            arr[<span class="built_in">j</span>] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    arr[left] = arr[<span class="built_in">i</span>];</span><br><span class="line">    arr[<span class="built_in">i</span>] = flag;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">i</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">quickSort</span><span class="params">(arr, left, right)</span> &#123;</span></span><br><span class="line">    let pivot = left;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        pivot = tailQuickSort(arr, left, right);</span><br><span class="line">        quickSort(arr, left, pivot - <span class="number">1</span>);</span><br><span class="line">        left = pivot + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let testArray = [<span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">4</span>];</span><br><span class="line">quickSort(testArray, <span class="number">0</span>, testArray.<span class="built_in">length</span> - <span class="number">1</span>);</span><br><span class="line">console.<span class="built_in">log</span>(testArray);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;尾递归是个什么东西这边就不介绍了。总之递归我是一直没有搞明白。但是我知道尾递归是为了解决递归造成的栈溢出和大量重复的计算。&lt;/p&gt;
&lt;h2 id=&quot;常规版本&quot;&gt;&lt;a href=&quot;#常规版本&quot; class=&quot;headerlink&quot; title=&quot;常规版本&quot;&gt;&lt;/a&gt;常规版本&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>19年前端校招面经</title>
    <link href="http://shenweini.cn/2019/03/25/19%E5%B9%B4%E6%A0%A1%E6%8B%9B%E5%89%8D%E7%AB%AF%E9%9D%A2%E7%BB%8F%EF%BC%88%E9%98%BF%E9%87%8C-%E5%B0%8F%E7%B1%B3-%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8%EF%BC%89/"/>
    <id>http://shenweini.cn/2019/03/25/19年校招前端面经（阿里-小米-字节跳动）/</id>
    <published>2019-03-25T12:47:45.000Z</published>
    <updated>2019-03-25T12:47:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>加个小前提，本人投的是web前端，如果分方向的话，是React方向。<br>俗话说，金三银四，在这充满了刺激的三月，我也拿着我的一页纸的简历投了好几家公司，下面记录着我参加了面试的几家公司以及近期整理出的题目。很尴尬，没有拿到任何一家的offer，经过这几次的面试也发现自己的基础确实很差，打算歇息一阵子好好补一补自己的基础，准备开始秋招或者明年的春招，毕竟我还是很向往大公司的待遇的。不过我也发现了一点，可能学历对于程序员有点影响，但是还是技术比较重要，只要你够牛逼，BAT肯定会向你打开大门，再不济也是磨练几年走社招进。但是个人认为对于考研和找工作动摇不定的还是先尝试一下考研吧，毕竟对于像我这样的不出名的小二本环境还是不咋地，985/211出名不是没有道理的。</p><h2 id="阿里前端校招–电话面试"><a href="#阿里前端校招–电话面试" class="headerlink" title="阿里前端校招–电话面试"></a>阿里前端校招–电话面试</h2><p>小生不才，第一轮的电话初试就被刷掉了，所以不清楚阿里的校招这个流程，我也只能提供电话初试的情况了，那天阳光明媚，中午刚下课接到一个电话，一看归属地浙江杭州已经开始梦想进入阿里的场景了，果不其然，约了第二天晚上八点的电话初始，又在情理之中的被刷掉了，历经一个小时，感觉就是这个面试官是真牛逼啊，我是在一个小时之内肚子里的存货被掏的干干净净的。</p><h3 id="1-请求跨域问题"><a href="#1-请求跨域问题" class="headerlink" title="1. 请求跨域问题"></a>1. 请求跨域问题</h3><p>这是前端面试必问题型，我就写几个不一定对，因为我也是搜的我也没经历过跨域。</p><ol><li>jsonp形式，缺点是只能实现get请求，并且对于出现的error不容易调试</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</span></span><br><span class="line"><span class="actionscript">    script.type = <span class="string">'text/javascript'</span>;</span></span><br><span class="line"><span class="actionscript">    script.src = <span class="string">'http://domain2.com:8080/login?user=admin&amp;callback=onBack'</span>;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.head.appendChild(script);</span></span><br><span class="line"><span class="actionscript">    <span class="comment">// 回调执行函数</span></span></span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span> <span class="title">onBack</span><span class="params">(res)</span></span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(res);</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>document.domain  改变两个域的document.domain</li><li>window.name</li><li>postMessage</li><li>CORS 跨域资源共享</li><li>nginx反向代理</li><li>websocket协议跨域</li></ol><h3 id="2-webpack插件、优化、loader"><a href="#2-webpack插件、优化、loader" class="headerlink" title="2. webpack插件、优化、loader"></a>2. webpack插件、优化、loader</h3><h3 id="3-页面性能优化"><a href="#3-页面性能优化" class="headerlink" title="3. 页面性能优化"></a>3. 页面性能优化</h3><ol><li>减少http请求</li><li>使用CDN</li><li>添加Expires头，第一次访问是缓存组件，减少不必要的http请求</li><li>开启压缩gzip可以减少到30%</li><li>样式表放在head表，脚本放最下面</li><li>配置ETAG</li><li>….</li></ol><h3 id="4-原型链相关"><a href="#4-原型链相关" class="headerlink" title="4. 原型链相关"></a>4. 原型链相关</h3><h3 id="5-ES6的新特性了解多少"><a href="#5-ES6的新特性了解多少" class="headerlink" title="5. ES6的新特性了解多少"></a>5. ES6的新特性了解多少</h3><h3 id="6-ES6和commonjs的区别"><a href="#6-ES6和commonjs的区别" class="headerlink" title="6. ES6和commonjs的区别"></a>6. ES6和commonjs的区别</h3><ol><li>es6导出的是值得引用，值的改变引用也改变，commonjs输出的是值的拷贝，值改变不会影响已经导出的变量</li><li>es6中this指向undefined，commonjs指向当前模块</li><li>es6是在解析是加载模块，commonjs是运行时加载</li><li>es6可以单独加载某个函数，commonjs只能加载整个模块</li><li>es6加载的不是对象，commonjs加载的是一个对象</li></ol><h3 id="7-react生命周期"><a href="#7-react生命周期" class="headerlink" title="7. react生命周期"></a>7. react生命周期</h3><p><img src="http://static.zybuluo.com/shenweizheng/0lh7kggg8topfqk2grc9717w/TIM%E6%88%AA%E5%9B%BE20190325164720.png" alt="TIM截图20190325164720.png-258.9kB"></p><h3 id="8-react优化"><a href="#8-react优化" class="headerlink" title="8. react优化"></a>8. react优化</h3><ol><li>shouldComponentUpdate这边做操作，判断是否进行render</li><li>尽量不适应组件state使用mobx或者其他代替</li><li>。。。</li></ol><h3 id="9-为什么使用mobx而不是使用原生的setState"><a href="#9-为什么使用mobx而不是使用原生的setState" class="headerlink" title="9. 为什么使用mobx而不是使用原生的setState"></a>9. 为什么使用mobx而不是使用原生的setState</h3><ol><li>setState是异步的，渲染时可能会出现错误</li><li>setState会造成不必要的渲染，mobx可以不把变量设置为可观察变量</li><li>setState不可能管理所有的状态，父子组件很多的时候会很乱</li><li>使得jsx的职责变得更单一</li></ol><h3 id="10-setState是批处理吗"><a href="#10-setState是批处理吗" class="headerlink" title="10. setState是批处理吗"></a>10. setState是批处理吗</h3><p>是批处理，如果render里面有多个setState时会一起进行setState</p><h3 id="11-说一说flex布局"><a href="#11-说一说flex布局" class="headerlink" title="11. 说一说flex布局"></a>11. 说一说flex布局</h3><h3 id="12-说一说冒泡机制"><a href="#12-说一说冒泡机制" class="headerlink" title="12. 说一说冒泡机制"></a>12. 说一说冒泡机制</h3><p>从上到下捕获到冒泡，从下往上冒泡<br>最上面是window</p><h3 id="13-浏览器已经定义好的对象有哪些"><a href="#13-浏览器已经定义好的对象有哪些" class="headerlink" title="13. 浏览器已经定义好的对象有哪些"></a>13. 浏览器已经定义好的对象有哪些</h3><p>window,screen,location,history,navigator</p><h3 id="14-数组去重-说一说复杂度"><a href="#14-数组去重-说一说复杂度" class="headerlink" title="14. 数组去重,说一说复杂度"></a>14. 数组去重,说一说复杂度</h3><h3 id="15-说一说websocket"><a href="#15-说一说websocket" class="headerlink" title="15. 说一说websocket"></a>15. 说一说websocket</h3><h3 id="16-正则表达式"><a href="#16-正则表达式" class="headerlink" title="16. 正则表达式"></a>16. 正则表达式</h3><h3 id="17-http和https的区别"><a href="#17-http和https的区别" class="headerlink" title="17. http和https的区别"></a>17. http和https的区别</h3><ol><li>http是明文传输，https是使用安全套接字加密的</li><li>http的端口是80 https的端口是443</li><li>https需要到ca申请证书，需要一定的费用</li><li>http的链接很简单没有状态，https的协议是由SSL+http协议构建的加密传输，身份认证的网络协议很安全</li></ol><h3 id="18-http请求常用的状态码"><a href="#18-http请求常用的状态码" class="headerlink" title="18. http请求常用的状态码"></a>18. http请求常用的状态码</h3><ol><li>200 请求成功</li><li>404 请求不存在</li><li>405 请求方式错误</li><li>403 服务器接受了请求但是拒绝响应</li><li>303 请求需要存在另一个url，请使用get请求定向获取请求的资源</li><li>500 服务器发生了一场异常</li></ol><h3 id="19-说一说css3动画"><a href="#19-说一说css3动画" class="headerlink" title="19. 说一说css3动画"></a>19. 说一说css3动画</h3><h3 id="20-canvas画布"><a href="#20-canvas画布" class="headerlink" title="20. canvas画布"></a>20. canvas画布</h3><h3 id="21-http属于哪一层"><a href="#21-http属于哪一层" class="headerlink" title="21. http属于哪一层"></a>21. http属于哪一层</h3><p>应用层</p><h3 id="22-tcp和udp的区别以及使用场景"><a href="#22-tcp和udp的区别以及使用场景" class="headerlink" title="22. tcp和udp的区别以及使用场景"></a>22. tcp和udp的区别以及使用场景</h3><ol><li>tcp面向连接的可靠传输，udp面向无连接不可靠</li><li>tcp面向字节流，udp面向报文</li><li>tcp是一对一的通信，udp可以一对一也可以一对多也可以多对多通信</li><li>tcp的建立需要经历三次握手四次挥手</li><li>tcp适用于文件传输，发送邮件</li><li>udp适用于即时通信，在线视频</li></ol><h3 id="23-讲一讲计算机网络的七层模型"><a href="#23-讲一讲计算机网络的七层模型" class="headerlink" title="23. 讲一讲计算机网络的七层模型"></a>23. 讲一讲计算机网络的七层模型</h3><p>物理层、数据链路层、传输层、网络层、应用层、会话层、表示层</p><h3 id="24-讲一讲闭包"><a href="#24-讲一讲闭包" class="headerlink" title="24. 讲一讲闭包"></a>24. 讲一讲闭包</h3><p>函数内部可以读取函数外部的变量，直白的说就是函数包函数<br>可以保存局部变量并且不会污染全局环境，缺点是会加大内存的负担</p><h3 id="25-箭头函数和普通函数的区别"><a href="#25-箭头函数和普通函数的区别" class="headerlink" title="25. 箭头函数和普通函数的区别"></a>25. 箭头函数和普通函数的区别</h3><ol><li>this作用域的区别，箭头函数是函数自身，普通函数是函数所在的上下文</li><li>函数作用于提升的区别，箭头函数需要将函数赋值给一个var变量才能提升他的作用域</li><li>构造函数的问题，箭头函数是匿名函数不可以作为构造函数不可以new</li></ol><h3 id="26-如何提升函数的作作用域"><a href="#26-如何提升函数的作作用域" class="headerlink" title="26. 如何提升函数的作作用域"></a>26. 如何提升函数的作作用域</h3><p>call，apply，bind</p><h3 id="27-call和apply的区别"><a href="#27-call和apply的区别" class="headerlink" title="27. call和apply的区别"></a>27. call和apply的区别</h3><p>第二个参数的区别，apply的第二个参数是一个数组，call是一个一个参数的往后加</p><h3 id="28-es5的继承是如何实现的"><a href="#28-es5的继承是如何实现的" class="headerlink" title="28. es5的继承是如何实现的"></a>28. es5的继承是如何实现的</h3><p>利用prototype实现</p><pre><code>function Dog{    this.name = &apos;dog&apos;;};function Animal{    this.speak = function(){        console.log(&apos;二哈&apos;);    }};Dog.prototype = new Animal();dog = new Dog();dog.speak();</code></pre><h3 id="29-XSS攻击"><a href="#29-XSS攻击" class="headerlink" title="29. XSS攻击"></a>29. XSS攻击</h3><ol><li>XSS攻击分为反射型，存储型，DOM型</li><li>反射型XSS是在将XSS代码放在URL中，将参数提交到服务器。服务器解析后响应，在响应结果中存在XSS代码，最终通过浏览器解析执行</li><li>存储型XSS是将XSS代码存储到服务端（数据库、内存、文件系统等），在下次请求同一个页面时就不需要带上XSS代码了，而是从服务器读取</li><li>DOM XSS的发生主要是在JS中使用eval造成的，所以应当避免使用eval语句</li><li>XSS危害有盗取用户cookie，通过JS或CSS改变样式，Dom造成正常用户无法得到服务器响应<br>预防：</li><li>对cookie进行保护 对cookie设置httpOnly</li><li>对用户输入的数据进行编码、解码、过滤</li></ol><h3 id="30-jsx为什么叫jsx-类名为什么大写"><a href="#30-jsx为什么叫jsx-类名为什么大写" class="headerlink" title="30. jsx为什么叫jsx 类名为什么大写"></a>30. jsx为什么叫jsx 类名为什么大写</h3><p>jsx也叫javascript XML</p><h3 id="31-如何获取到dom里面的某个节点"><a href="#31-如何获取到dom里面的某个节点" class="headerlink" title="31. 如何获取到dom里面的某个节点"></a>31. 如何获取到dom里面的某个节点</h3><p>各种dom操作，querySelector等</p><h3 id="32-absolute是对哪个点开始计算的"><a href="#32-absolute是对哪个点开始计算的" class="headerlink" title="32. absolute是对哪个点开始计算的"></a>32. absolute是对哪个点开始计算的</h3><ol><li>外层有relative定义时相对于relative定位</li><li>外层没有时根据body定位</li></ol><h3 id="33-原生js发送请求"><a href="#33-原生js发送请求" class="headerlink" title="33. 原生js发送请求"></a>33. 原生js发送请求</h3><pre><code>// 定义一个XMLHttpRequest变量var xhr = new XMLHttpRequest();// 要发送的请求urlxhr.open(&apos;post&apos;,&apos;/api/login&apos;);// 对于post请求要设置请求头xhr.setRequestHeader(&apos;Content-type&apos;,&apos;application/x-www-form-urlencoded&apos;);// 发送请求xhr.send(&apos;account=admin&amp;password=123456);// 监听状态改变xhr.onreadystatechange = function(){    if(xhr.readyState === 4 &amp;&amp; xhr.status === 200){        console.log(&apos;success&apos;);    }}</code></pre><h2 id="小米电话面试"><a href="#小米电话面试" class="headerlink" title="小米电话面试"></a>小米电话面试</h2><h3 id="1-css常用选择器按照优先级说"><a href="#1-css常用选择器按照优先级说" class="headerlink" title="1. css常用选择器按照优先级说"></a>1. css常用选择器按照优先级说</h3><h3 id="2-css常用水平居中"><a href="#2-css常用水平居中" class="headerlink" title="2. css常用水平居中"></a>2. css常用水平居中</h3><h3 id="3-css垂直居中"><a href="#3-css垂直居中" class="headerlink" title="3. css垂直居中"></a>3. css垂直居中</h3><h3 id="4-css实现图片等比例缩放"><a href="#4-css实现图片等比例缩放" class="headerlink" title="4. css实现图片等比例缩放"></a>4. css实现图片等比例缩放</h3><h3 id="5-讲一讲flex布局"><a href="#5-讲一讲flex布局" class="headerlink" title="5. 讲一讲flex布局"></a>5. 讲一讲flex布局</h3><h3 id="6-css行内元素和块级元素的区别"><a href="#6-css行内元素和块级元素的区别" class="headerlink" title="6. css行内元素和块级元素的区别"></a>6. css行内元素和块级元素的区别</h3><h3 id="7-讲一讲原型链"><a href="#7-讲一讲原型链" class="headerlink" title="7. 讲一讲原型链"></a>7. 讲一讲原型链</h3><h3 id="8-箭头函数和普通函数的区别"><a href="#8-箭头函数和普通函数的区别" class="headerlink" title="8. 箭头函数和普通函数的区别"></a>8. 箭头函数和普通函数的区别</h3><h3 id="9-webpack的插件都用过哪些，都是干嘛用的"><a href="#9-webpack的插件都用过哪些，都是干嘛用的" class="headerlink" title="9. webpack的插件都用过哪些，都是干嘛用的"></a>9. webpack的插件都用过哪些，都是干嘛用的</h3><h2 id="字节跳动"><a href="#字节跳动" class="headerlink" title="字节跳动"></a>字节跳动</h2><p>字节跳动对算法是有点要求的公司，所以很不幸的在最后一轮面试被刷了，想要投字节跳动的同学介意多刷一刷牛客网上的算法题。各种排序，查找，递归。很不幸我就是不会递归最后一轮才被刷了。</p><h3 id="笔试"><a href="#笔试" class="headerlink" title="笔试"></a>笔试</h3><p>我的笔试是两个小时直接四道算法题，前两道还是很简单的，基本的循环就都可以解出来没什么难度，后两题是有点意思了，我是花了一个多小时没写的出来。后两道应该是用动态规划就做出来了。<br>我是两题满分两题零分拿到了面试的机会，我本人也是不敢相信的。貌似是作对两题就可以拿到面试机会。<br>接下来是视频面试，最多三轮，过了一轮会发短信告诉你这一轮有没有过，中间可以休息半个小时左右。三轮都是技术面。个人感觉前两面虽然有的没答得出来但是面试官人还是很好的都给过了。</p><h3 id="视频一面"><a href="#视频一面" class="headerlink" title="视频一面"></a>视频一面</h3><p>一面是一个小姐姐，但是这个小姐姐尽然比我还要紧张。瞬间就搞得我更紧张了。互道你好之后，开始聊聊之前做过的项目，都用了哪些技术栈，为什么选这种技术栈。一面全程半个小时。</p><ol><li>箭头函数和普通函数的区别</li><li>mobx和redux的区别，为什么选用mobx</li><li>单向数据流和双向绑定的理解</li><li>浏览器从输入网址到页面渲染完成中间都发生了什么</li><li>正则表达式</li><li>webpack都用过哪些插件</li><li>了解promise吧，用过promise.all吧 ，来，模拟一下promise.all的过程（。。直接给我整蒙了）</li><li><p>经典的闭包问题</p><p> for(var i = 0;i &lt; 10;i++){</p><pre><code>console.log(i);</code></pre><p> }<br>最后输出的是什么，改写成我们需要的样子</p><p> for(var i = 0;i &lt; 10;i++){</p><pre><code>(function(i){    console.log(i)})(i)</code></pre><p> }</p><h3 id="视频二面"><a href="#视频二面" class="headerlink" title="视频二面"></a>视频二面</h3><p>二面是一个小哥哥，目测发际线有点厉害，是我以后的模样。小哥哥人还是很好的，我没答得上的还和我讲了一遍，最好告诉我我的基础哪里有薄弱。</p></li><li>自我介绍</li><li>stage-0 -1 的区别</li><li>经典的闭包问题，以及闭包改写，其中有一个微任务和宏任务的概念</li><li>函数作用域提示问题，一串代码问我输出是什么，代码记不住了，但是我知道的是这是我看不懂的操作。不过大致就是靠变量提示的。</li><li>一道编程题，给定一个字符串，找出里面出现最多的字符并输出对应的字符和出现次数</li><li>给一张二叉树的图，口述前序中序后序遍历的过程</li><li>说一说tcp和Udp的区别，以及各自的使用场景</li></ol><h3 id="视屏三面"><a href="#视屏三面" class="headerlink" title="视屏三面"></a>视屏三面</h3><p>好吧，这一轮不说多少，两道算法题，有点后悔要是之前搞懂了递归也不会被刷。</p><ol><li><p>第一道题</p><pre><code>const vDom = {    tag: &apos;div&apos;,    props: {&apos;a&apos;: &apos;b&apos;},    children: [        {            tag: &apos;span&apos;,            props: {},            children: []        },{            tag: &apos;span&apos;,            props: {},            children: []        }    ]}// 将这个json组成一个节点&lt;div a=&apos;b&apos;&gt;    &lt;span&gt;&lt;/span&gt;    &lt;span&gt;&lt;/span&gt;&lt;/div&gt;// 递归求解</code></pre></li><li><p>数组旋转</p><p> const image = [</p><pre><code>[1,2,3,4,10],[5,6,7,8,9],[11,12,13,14,15]</code></pre><p> ]<br> // 顺时针旋转九十度<br>这题还是很简单的，刷一下就写完了，刷的一个就收到了你的面试未通过的短信，刷的一下offer就飞了。就是这么快。</p></li></ol><h2 id="以下是在准备面试时收集到的其他人的经验，不全"><a href="#以下是在准备面试时收集到的其他人的经验，不全" class="headerlink" title="以下是在准备面试时收集到的其他人的经验，不全"></a>以下是在准备面试时收集到的其他人的经验，不全</h2><h3 id="1-new一个对象的过程发生了什么"><a href="#1-new一个对象的过程发生了什么" class="headerlink" title="1. new一个对象的过程发生了什么"></a>1. new一个对象的过程发生了什么</h3><ol><li>创建一个新对象，如：var person = {};</li><li>新对象的proto属性指向构造函数的原型对象。</li><li>将构造函数的作用域赋值给新对象。（也所以this对象指向新对象）</li><li>执行构造函数内部的代码，将属性添加给person中的this对象。</li><li>返回新对象person。</li></ol><h3 id="2-visibilty-和-display：none的区别"><a href="#2-visibilty-和-display：none的区别" class="headerlink" title="2. visibilty 和 display：none的区别"></a>2. visibilty 和 display：none的区别</h3><p>visibility隐藏是还是会占据原来的位置<br>但是display：none不会占据原来的位置</p><h3 id="3-js的基本数据类型"><a href="#3-js的基本数据类型" class="headerlink" title="3. js的基本数据类型"></a>3. js的基本数据类型</h3><p>null,underfined,number,string,boolean,object</p><h3 id="4-typeof和intanceof的区别"><a href="#4-typeof和intanceof的区别" class="headerlink" title="4. typeof和intanceof的区别"></a>4. typeof和intanceof的区别</h3><p>typeof返回一个字符串，说明匹配对象的类型，返回值有string，number，boolean，object，underfined，function<br>局限性：对于Array类型和null typeof一致都返回object</p><p>intanceof判断一个对象的原型链中是否存在一个构造函数的prototype</p><h3 id="5-函数的arguments是不是一个数组"><a href="#5-函数的arguments是不是一个数组" class="headerlink" title="5. 函数的arguments是不是一个数组"></a>5. 函数的arguments是不是一个数组</h3><p>不是,arguments是一个类数组对象，可以打印看一下，包含了函数所有的参数</p><h3 id="6-let-var-const-的区别"><a href="#6-let-var-const-的区别" class="headerlink" title="6. let var const 的区别"></a>6. let var const 的区别</h3><ol><li>const 表示常量，一旦定义不可修改，且必须初始化</li><li>var的作用于为全文上下，可以重复定义，</li><li>let是快级作用域，不可重复定义</li></ol><h3 id="7-promise的原理及实现"><a href="#7-promise的原理及实现" class="headerlink" title="7. promise的原理及实现"></a>7. promise的原理及实现</h3><h3 id="8-git相关操作，git-merge-和rebase的区别"><a href="#8-git相关操作，git-merge-和rebase的区别" class="headerlink" title="8. git相关操作，git merge 和rebase的区别"></a>8. git相关操作，git merge 和rebase的区别</h3><ul><li>get merge 之后解决冲突需要执行 git add . git commit -m’fix conflict’ 会多出一个commit </li><li>git rebase 之后执行 git add .和git rebase –continue 不会产生额外的commit这样会干净，不会产生无意义的commit</li></ul><h3 id="9-Es5新增的map-filter-reduce"><a href="#9-Es5新增的map-filter-reduce" class="headerlink" title="9. Es5新增的map filter reduce"></a>9. Es5新增的map filter reduce</h3><ul><li>map 遍历不会改变原数组 </li><li>filter 过滤不会改变原数组，会返回一个新数组 </li><li>reduce 函数值累加</li></ul><h3 id="10-js中的微任务和宏任务"><a href="#10-js中的微任务和宏任务" class="headerlink" title="10. js中的微任务和宏任务"></a>10. js中的微任务和宏任务</h3><h3 id="11-arguments是什么，转数组有哪些方法"><a href="#11-arguments是什么，转数组有哪些方法" class="headerlink" title="11. arguments是什么，转数组有哪些方法"></a>11. arguments是什么，转数组有哪些方法</h3><p>类数组对象，</p><ul><li>[…arguments]</li><li>Array.prototye.slice.apply(arguments)</li><li>Array.from(arguments)</li></ul><h3 id="12-cookie-session的关系区别"><a href="#12-cookie-session的关系区别" class="headerlink" title="12. cookie session的关系区别"></a>12. cookie session的关系区别</h3><h3 id="13-cookie-localStorage-sessionStorage之间的区别"><a href="#13-cookie-localStorage-sessionStorage之间的区别" class="headerlink" title="13. cookie localStorage sessionStorage之间的区别"></a>13. cookie localStorage sessionStorage之间的区别</h3><h3 id="14-link和-import之间的区别"><a href="#14-link和-import之间的区别" class="headerlink" title="14. link和@import之间的区别"></a>14. link和@import之间的区别</h3><ol><li>link属于HTML标签，而@import是CSS提供的; </li><li>页面被加载的时，link会同时被加载，而@import引用的CSS会等到页面被加载完再加载; </li><li>import只在IE5以上才能识别，而link是HTML标签，无兼容问题; </li><li>link方式的样式的权重 高于@import的权重.</li></ol><h3 id="15-absolute-和-float"><a href="#15-absolute-和-float" class="headerlink" title="15. absolute 和 float"></a>15. absolute 和 float</h3><p>A：共同点：<br>对内联元素设置float和absolute属性，可以让元素脱离文档流，并且可以设置其宽高。</p><p>B：不同点：<br>float仍会占据位置，position会覆盖文档流中的其他元素。</p><h3 id="16-XML和json的区别"><a href="#16-XML和json的区别" class="headerlink" title="16. XML和json的区别"></a>16. XML和json的区别</h3><ol><li>数据体积方面。<br>JSON相对于XML来讲，数据的体积小，传递的速度更快些。 </li><li>数据交互方面。<br>JSON与JavaScript的交互更加方便，更容易解析处理，更好的数据交互。 </li><li>数据描述方面。<br>JSON对数据的描述性比XML较差。 </li><li>传输速度方面。<br>JSON的速度要远远快于XML。</li></ol><h3 id="17-BFC"><a href="#17-BFC" class="headerlink" title="17. BFC"></a>17. BFC</h3><p>盒模型</p><h3 id="18-HTML语义化的理解"><a href="#18-HTML语义化的理解" class="headerlink" title="18. HTML语义化的理解"></a>18. HTML语义化的理解</h3><h3 id="19-DOCTYPE，严格模式与混杂模式"><a href="#19-DOCTYPE，严格模式与混杂模式" class="headerlink" title="19. DOCTYPE，严格模式与混杂模式"></a>19. DOCTYPE，严格模式与混杂模式</h3><ol><li>声明位于文档中的最前面，处于 标签之前。告知浏览器以何种模式来渲染文档。</li><li>严格模式的排版和 JS 运作模式是 以该浏览器支持的最高标准运行。</li><li>在混杂模式中，页面以宽松的向后兼容的方式显示。模拟老式浏览器的行为以防止站点无法工作</li><li>DOCTYPE不存在或格式不正确会导致文档以混杂模式呈现。</li></ol><h3 id="20-transform-代替-marginLeft-Top的区别"><a href="#20-transform-代替-marginLeft-Top的区别" class="headerlink" title="20. transform 代替 marginLeft/Top的区别"></a>20. transform 代替 marginLeft/Top的区别</h3><p>页面回流没有了</p><h3 id="21-calc计算"><a href="#21-calc计算" class="headerlink" title="21. calc计算"></a>21. calc计算</h3><p>vw表示 宽度的百分比<br>vh表示 高度的百分比</p><h3 id="22-js防抖和节流"><a href="#22-js防抖和节流" class="headerlink" title="22. js防抖和节流"></a>22. js防抖和节流</h3><h3 id="23-栈和堆得区别"><a href="#23-栈和堆得区别" class="headerlink" title="23. 栈和堆得区别"></a>23. 栈和堆得区别</h3><h3 id="24-聊一聊NaN"><a href="#24-聊一聊NaN" class="headerlink" title="24. 聊一聊NaN"></a>24. 聊一聊NaN</h3><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>唯一的体会就是一定要补补自己的基础，大厂很注重基础，看的是一个人的潜力和可塑造性。另外多看看别人的面经，多做好准备我是准备的有点冲忙，因为我总有一种明天就要毕业的既视感，所以很着急找工作，现在放宽心态慢慢来。</p><h2 id="最后忠诚祝愿各位同行能拿到自己心仪的offer，祝各位拿offer拿到手软"><a href="#最后忠诚祝愿各位同行能拿到自己心仪的offer，祝各位拿offer拿到手软" class="headerlink" title="最后忠诚祝愿各位同行能拿到自己心仪的offer，祝各位拿offer拿到手软"></a>最后忠诚祝愿各位同行能拿到自己心仪的offer，祝各位拿offer拿到手软</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;加个小前提，本人投的是web前端，如果分方向的话，是React方向。&lt;br&gt;俗话说，金三银四，在这充满了刺激的三月，我也拿着我的一页纸的简历投了好几家公司，下面记录着我参加了面试的几家公司以及近期整理出的题目。很尴尬，没有拿到任何一家的offer，经过这几次的面试也发现自己
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Git基本操作</title>
    <link href="http://shenweini.cn/2019/01/28/Git%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
    <id>http://shenweini.cn/2019/01/28/Git基本操作/</id>
    <published>2019-01-28T10:07:47.000Z</published>
    <updated>2019-01-28T10:07:47.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-查看分支"><a href="#1-查看分支" class="headerlink" title="1.查看分支"></a>1.查看分支</h2><pre><code>git branch 查看本地分支git branch -a 查看所有分支</code></pre><p><img src="http://static.zybuluo.com/shenweizheng/z2noezmkolv3clrzsv3kr3ys/image_1d29tb0vg1bu35spagp1spr1tqr14.png" alt="image_1d29tb0vg1bu35spagp1spr1tqr14.png-3kB"></p><p>前面带有 * 号的表示当前分支。</p><pre><code>git branch xxx 添加本地分支git branch -d xxx 删除分支git pull 拉取代码git pull origin xxx 拉取远程分支git push xxx 推送本地分支到远程git merge xxx 合并分支</code></pre><h2 id="2-合并分支"><a href="#2-合并分支" class="headerlink" title="2. 合并分支"></a>2. 合并分支</h2><p>当前分支  A  要合并分支B的代码<br>步骤一：将A分支的代码commit<br>步骤二：切换到B分支  <code>git checkout B</code><br>步骤三：拉取远程代码  <code>git pull</code><br>步骤四：切换回A分支 <code>git checkout A</code><br>步骤五：合并B分支代码 <code>git merge B</code></p><h2 id="3-合并部分文件"><a href="#3-合并部分文件" class="headerlink" title="3. 合并部分文件"></a>3. 合并部分文件</h2><p>当前分支 A  要合并分支文件 B 文件路径 /static/src/apps/login/store/loginStore.js<br>步骤一：将A分支commit<br>步骤二：切换B分支 <code>git checkout B</code><br>步骤三：拉取远程代码 <code>git pull</code><br>步骤四：检查有没有未提交的文件，有的话提交</p><pre><code>git statusgit commit -m &apos;&apos;</code></pre><p>步骤五：切换回A分支 <code>git checkout A</code><br>步骤六：cd进药合并的文件所在的文件夹 <code>cd /static/src/apps/login/store</code><br>步骤七：合并指定文件 <code>git merge B loginStore.js</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-查看分支&quot;&gt;&lt;a href=&quot;#1-查看分支&quot; class=&quot;headerlink&quot; title=&quot;1.查看分支&quot;&gt;&lt;/a&gt;1.查看分支&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;git branch 查看本地分支
git branch -a 查看所有分支
&lt;/code&gt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>hexo博客配置</title>
    <link href="http://shenweini.cn/2018/12/05/hexo%E5%8D%9A%E5%AE%A2%E9%85%8D%E7%BD%AE/"/>
    <id>http://shenweini.cn/2018/12/05/hexo博客配置/</id>
    <published>2018-12-05T08:30:21.000Z</published>
    <updated>2018-12-05T08:30:21.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-网站图标更换"><a href="#1-网站图标更换" class="headerlink" title="1.网站图标更换"></a>1.网站图标更换</h2><p>themes\hexo-theme-Annie\layout_partial\head.ejs<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link <span class="attribute">href</span>=<span class="string">"&lt;%- config.root %&gt;img/favicon.ico"</span> <span class="attribute">rel</span>=<span class="string">"Shortcut Icon"</span> <span class="attribute">type</span>=<span class="string">"image/ico"</span>&gt;</span><br></pre></td></tr></table></figure></p><p>我中间这个hexo-theme-Annie 是我的主题名字，只要路径差不多，找到layout_partial\head.ejs这个文件就对了，把你要换的那个ico文件放在根目录的public\img文件里面就行了，就是你放静态文件的那个目录。</p><h2 id="2-主题更换"><a href="#2-主题更换" class="headerlink" title="2.主题更换"></a>2.主题更换</h2><p>可以去hexo theme的官网找到你想要的主题，<a href="https://hexo.io/themes/" target="_blank" rel="noopener">hexo-theme</a>选择你喜欢的主题,以我的为例，我选的是Annie<img src="http://static.zybuluo.com/shenweizheng/91gzkw8d7exfxt76rujuznus/TIM%E6%88%AA%E5%9B%BE20181024000407.png" alt="TIM截图20181024000407.png-41.1kB"><br>然后点击这个主题，就可以找到这个主题的博客拥有者，这时候观察浏览器的地址栏的路由，<a href="https://sariay.github.io/" target="_blank" rel="noopener">https://sariay.github.io/</a> github.io前面这个sariay就是博主的github用户名了<br>然后我们主要在进 <a href="https://github.com/博主用户名，这里就是https://github.com/sariay" target="_blank" rel="noopener">https://github.com/博主用户名，这里就是https://github.com/sariay</a> 就可以找到博主的仓库了<br><img src="http://static.zybuluo.com/shenweizheng/lw0roum747u4lwi79scp4o3x/TIM%E6%88%AA%E5%9B%BE20181024000712.png" alt="TIM截图20181024000712.png-207.9kB"><br>这里我们找到我们所选的主题 hexo-theme-Annie 点进去<br><img src="http://static.zybuluo.com/shenweizheng/di0v7n85s3nfxxdjo44my531/TIM%E6%88%AA%E5%9B%BE20181024000819.png" alt="TIM截图20181024000819.png-109.5kB"><br>复制一下网址，然后我们cd进我们的博客文件夹，右击git bash here<br><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">clone</span> <span class="title">https</span>://github.com/Sariay/hexo-theme-Annie.git themes/hexo-theme-Annie</span><br></pre></td></tr></table></figure></p><p>这样我们就可以吧主题克隆到我们的本地，然后需求修改一下博客的配置文件_config.yml 找到theme字段<br><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">theme</span>: hexo-<span class="built_in">theme</span>-Annie</span><br></pre></td></tr></table></figure></p><p>修改theme后面的值是我们刚刚克隆下来的主题名，注意克隆下的那个主题文件夹不要去修改他的文件夹的名字，这边配置文件修改完之后，启动下本地服务就会发现主题已经更新好了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-网站图标更换&quot;&gt;&lt;a href=&quot;#1-网站图标更换&quot; class=&quot;headerlink&quot; title=&quot;1.网站图标更换&quot;&gt;&lt;/a&gt;1.网站图标更换&lt;/h2&gt;&lt;p&gt;themes\hexo-theme-Annie\layout_partial\head.ej
      
    
    </summary>
    
      <category term="HEXO博客" scheme="http://shenweini.cn/categories/HEXO%E5%8D%9A%E5%AE%A2/"/>
    
    
  </entry>
  
  <entry>
    <title>webpack配置及踩过的那些坑</title>
    <link href="http://shenweini.cn/2018/12/03/webpack%E9%85%8D%E7%BD%AE%E5%8F%8A%E8%B8%A9%E8%BF%87%E7%9A%84%E9%82%A3%E4%BA%9B%E5%9D%91/"/>
    <id>http://shenweini.cn/2018/12/03/webpack配置及踩过的那些坑/</id>
    <published>2018-12-03T07:19:47.000Z</published>
    <updated>2018-12-03T07:19:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近学习了一波webpack打包部署，作为一名前端，不会一个打包的工具可真的是丢人啊。不过，用webpack又要接触到了配置文件，这个当初当我放弃写后端的东西，不过以后还是要全面发展的。好了，话不多说，这篇文章用的是webpack4.x版本的，下面将细数当初才过的坑。</p><h2 id="1-基础准备"><a href="#1-基础准备" class="headerlink" title="1.基础准备"></a>1.基础准备</h2><p>创建一个文件夹webpackDemo，我们使用命令行进入这个文件夹，运行 <code>npm init</code> 命令，初始化这个文件夹，初始化过程中出现的询问的一些配置，一路回车就好了。初始化好了之后，我们会发现文件夹里面已经多了package.json文件。<br><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install webpack --<span class="built_in">save</span>-<span class="built_in">dev</span> webpack-cli --<span class="built_in">save</span>-<span class="built_in">dev</span></span><br></pre></td></tr></table></figure></p><p>安装必要的 webpack 和 webpack-cli，安装成功之后的package.json文件如下</p><p><img src="http://static.zybuluo.com/shenweizheng/p03mjogf4044egkmgw1y3jzz/image_1csm6khqv45cj0i1plv1erc15ig9.png" alt="image_1csm6khqv45cj0i1plv1erc15ig9.png-26.8kB"></p><p>在根目录下创建如下的目录结构</p><p><img src="http://static.zybuluo.com/shenweizheng/6w2mp3ir0jcu9vahebdtg5n0/image_1csm6mqk21otcctql4fvdcpcpm.png" alt="image_1csm6mqk21otcctql4fvdcpcpm.png-10.4kB"></p><p>在<code>test.js</code>文件里面编写如下代码，一万年经典的Hello World</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">document.write(<span class="string">"Hello World"</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>在<code>index.html</code>里面编写代码<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width,initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Webpack初探<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./dist/js/bundle.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>这边引用一个<code>bundle.js</code>文件，<code>bundle.js</code>文件使我们打包之后生成的文件，接下来使用webpack的打包命令进行打包</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">webpack src<span class="regexp">/apps/</span>test.js -o dist<span class="regexp">/js/</span>bundle.js</span><br></pre></td></tr></table></figure><p>wepack的基础打包命令 <code>webpack {entryFile} -o {aimFile}</code> 执行完之后会发现我们的目录里已经生成了 <code>bundle.js</code> 文件，我们运行 <code>index.html</code> 文件，可以看到亲切的Hello World了。<br>打包过程中，出现的输出如下</p><p><img src="http://static.zybuluo.com/shenweizheng/0ky26he4f2kmgoddtgzdfpuo/image_1csm770vr12441ju3u61v1s49v2j.png" alt="image_1csm770vr12441ju3u61v1s49v2j.png-52.1kB"></p><p>这边会显示webpack打包一共花了501ms，打包后的 <code>bundle.js</code> 体积是957bytes，因为我们的代码比较简单，所以打包生成的文件还是很小的。</p><h2 id="2-webpack-config-js配置文件"><a href="#2-webpack-config-js配置文件" class="headerlink" title="2.webpack.config.js配置文件"></a>2.webpack.config.js配置文件</h2><p>在根目录下创建文件 <code>webpack.config.js</code> 这是weback运行所要依据的配置。大致分为入口配置，出口配置，loader配置，plugins配置</p><h3 id="2-1-entry和output"><a href="#2-1-entry和output" class="headerlink" title="2.1 entry和output"></a>2.1 entry和output</h3><p>entry配置的是入口文件，告诉webpack从哪个文件开始解析，分为单入口和多入口。有了入口，就要配置出口，配置打包生成的文件位置和文件名称。在<code>webpack.config.js</code>里面编写如下代码</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const <span class="built_in">path</span> = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line">module.exports = &#123;</span><br><span class="line">    entry: <span class="built_in">path</span>.resolve(__dirname, <span class="string">'src/apps/test.js'</span>),</span><br><span class="line">    <span class="built_in">output</span>: &#123;</span><br><span class="line">        <span class="built_in">path</span>: <span class="built_in">path</span>.resolve(__dirname, <span class="string">'dist'</span>),</span><br><span class="line">        filename: <span class="string">"js/bundle.js"</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先这边引用的<code>path</code>是<code>node.js</code>的一个模块，是用来解析路径用的，<code>path.resolve</code>指的是当前文件的所在路径，那么这边我们<code>entry</code>配置的就是<code>/src/apps/test.js</code>，这是单入口的配置形式。<br>下面对出口进行配置，output是一个对象，基础的两个属性，一个是输出文件的路径，另一个是输出文件的名称。<br>在<code>package.json</code>里面编写如下代码：</p><p><img src="http://static.zybuluo.com/shenweizheng/5fdepz23biva2ealjip37xvy/image_1csonnbu01u9340h1keo11d91nio9.png" alt="image_1csonnbu01u9340h1keo11d91nio9.png-10.9kB"></p><p>这边配置一下webpack的打包命令，之后通过<code>npm run start</code>进行打包，就不需要输一大串的命令了。打包一下我们可以看一下控制台的输出</p><p><img src="http://static.zybuluo.com/shenweizheng/68nmhoje7hk26hqsgfk6k2c1/image_1csonpuv21ev91ekv93i22k15gum.png" alt="image_1csonpuv21ev91ekv93i22k15gum.png-57.5kB"></p><p>发现有一个warning，这是因为我们还没有配置我们的mode，我们修改<code>webpack.config.js</code>文件</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const <span class="built_in">path</span> = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line">module.exports = &#123;</span><br><span class="line">    mode: <span class="string">'development'</span>,</span><br><span class="line">    devtool: <span class="string">'source-map'</span>,</span><br><span class="line">    entry: <span class="built_in">path</span>.resolve(__dirname, <span class="string">'src/apps/test.js'</span>),</span><br><span class="line">    <span class="built_in">output</span>: &#123;</span><br><span class="line">        <span class="built_in">path</span>: <span class="built_in">path</span>.resolve(__dirname, <span class="string">'dist'</span>),</span><br><span class="line">        filename: <span class="string">"js/bundle.js"</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在打包一下会发现这边的warning已经没有了。</p><h3 id="2-2-devtool配置"><a href="#2-2-devtool配置" class="headerlink" title="2.2 devtool配置"></a>2.2 devtool配置</h3><p>上面的配置文件我们是加了一个<code>devtool</code>的配置，这是因为webpack打包后的这个文件，我们可以看一下，已经不是我们所熟知的代码了，这样不方便于我们的调试，所以webpack为了解决这个问题，有一个<code>devtool</code>的配置。这边给一个别人博客的传送门<a href="https://www.jb51.net/article/134834.htm" target="_blank" rel="noopener">webpack之devtool详解</a>，<a href="https://webpack.js.org/configuration/devtool/#src/components/Sidebar/Sidebar.jsx" target="_blank" rel="noopener">webpack官方解释</a></p><h3 id="2-3-loader配置"><a href="#2-3-loader配置" class="headerlink" title="2.3 loader配置"></a>2.3 loader配置</h3><p>loader配置是webpack中的重点，因为webpack默认是只能处理html文件，如果要处理比如react应用中的jsx文件那么就需要配置一下loader，或者js、css等文件，都需要配置一下loader。这边已react应用为例。由于目前浏览器的兼容性问题，所以我们需要大量的插件和loader来转换我们写的高级js语法，就有了各种es6转es5，es7啥的。具体的还得好好研究。首先安装react相关的插件</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">npm</span> <span class="comment">install</span> <span class="comment">react</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">save</span> <span class="comment">react</span><span class="literal">-</span><span class="comment">dom</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">save</span></span><br></pre></td></tr></table></figure><p>安装解析react的相关插件和解析es6语法的相关插件。</p><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install babel-loader -<span class="built_in">save</span>-<span class="built_in">dev</span> babel-core --<span class="built_in">save</span>-<span class="built_in">dev</span> babel-preset-env --<span class="built_in">save</span>-<span class="built_in">dev</span> babel-preset-react --<span class="built_in">save</span>-<span class="built_in">dev</span></span><br></pre></td></tr></table></figure><p>babel-core<br>把 js 代码分析成 ast (抽象语法树, 是源代码的抽象语法结构的树状表现形式)，方便各个插件分析语法进行相应的处理。有些新语法在低版本 js 中是不存在的，如箭头函数，rest 参数，函数默认值等，这种语言层面的不兼容只能通过将代码转为 ast，再通过语法转换器分析其语法后转为低版本 js。</p><p>babel-preset-<em><br>babel-preset-</em> 代表了一系列的转码插件<br>有了 babel-plugin 系列，可以按需配置自己想要的特性，若是想搭个 es6 环境，一个个地配置各个插件，我猜你会疯掉。babel-preset 系列就可以满足我们的需求，babel-preset 系列打包了一组插件，类似于餐厅的套餐。如 babel-preset-es2015 打包了 es6 的特性，babel-preset-stage-0 打包处于 strawman 阶段的语法</p><p>下面看具体的配置，配置文件如下，这边首先我们要将package.json文件里面的babel-loader的版本更换成7.1.5然后重新安装一下模块，不然下面会因为babel-loader的版本问题出现打包失败的问题。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line"></span><br><span class="line">    mode: <span class="string">'development'</span>,</span><br><span class="line"></span><br><span class="line">    devtool: <span class="string">'source-map'</span>,</span><br><span class="line"></span><br><span class="line">    entry: path.resolve(__dirname, <span class="string">'src/apps/console.jsx'</span>),</span><br><span class="line"></span><br><span class="line">    output: &#123;</span><br><span class="line">        path: path.resolve(__dirname, <span class="string">'dist'</span>),</span><br><span class="line">        filename: <span class="string">"js/bundle.js"</span>,</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="keyword">module</span>: &#123;</span><br><span class="line">        rules: [&#123;</span><br><span class="line">            test: <span class="regexp">/(\.js)|(\.jsx)$/</span>,</span><br><span class="line">            exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">            use: &#123;</span><br><span class="line">                loader: <span class="string">'babel-loader'</span>,</span><br><span class="line">                options: &#123;</span><br><span class="line">                    presets: [<span class="string">'env'</span>, <span class="string">'react'</span>]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>test 指明要对哪一种后缀的文件进行解析，使用正则进行验证<br>exclude 规定一些文件夹或文件不参与解析<br>use.loader 配置使用的loader名称<br>use.option 配置loader的其他选项，这边的presets是告诉webpack解析react语法和es6语法。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// console.jsx</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mountNode = <span class="built_in">document</span>.getElementById(<span class="string">"root"</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">        <span class="keyword">super</span>(props)</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">Hello China!</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        );</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDOM.render(&lt;App /</span>&gt;, mountNode);</span><br></pre></td></tr></table></figure><p>执行<code>npm run start</code>，然后运行我们的index.html文件可以看到Hello China！。</p><h3 id="2-4-plugin配置"><a href="#2-4-plugin配置" class="headerlink" title="2.4 plugin配置"></a>2.4 plugin配置</h3><p>插件赋予了webpack更多的功能，比如说 js和css分离打包。比如说happyPack的多线程打包，比如说每次打包前自动清空dist目录。<br>以js、css分离打包为例，这是使用的<code>extract-text-webpack-plugin</code>插件，<br>首先安装一下，注意这边安装的是<code>extract-text-webpack-plugin@next</code>而不是<code>extract-text-webpack-plugin</code></p><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install --<span class="built_in">save</span>-<span class="built_in">dev</span> extract-text-webpack-plugin@<span class="built_in">next</span></span><br><span class="line">npm install style-loader --<span class="built_in">save</span>-<span class="built_in">dev</span> css-loader --<span class="built_in">save</span>-<span class="built_in">dev</span></span><br></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> ExtractTextPlugin = <span class="built_in">require</span>(<span class="string">'extract-text-webpack-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line"></span><br><span class="line">    mode: <span class="string">'development'</span>,</span><br><span class="line"></span><br><span class="line">    devtool: <span class="string">'source-map'</span>,</span><br><span class="line"></span><br><span class="line">    entry: path.resolve(__dirname, <span class="string">'src/apps/console.jsx'</span>),</span><br><span class="line"></span><br><span class="line">    output: &#123;</span><br><span class="line">        path: path.resolve(__dirname, <span class="string">'dist'</span>),</span><br><span class="line">        filename: <span class="string">"js/bundle.js"</span>,</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="keyword">module</span>: &#123;</span><br><span class="line">        rules: [&#123;</span><br><span class="line">            test: <span class="regexp">/(\.js)|(\.jsx)$/</span>,</span><br><span class="line">            exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">            use: &#123;</span><br><span class="line">                loader: <span class="string">'babel-loader'</span>,</span><br><span class="line">                options: &#123;</span><br><span class="line">                    presets: [<span class="string">'env'</span>, <span class="string">'react'</span>]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, &#123;</span><br><span class="line">            test: <span class="regexp">/\.css$/i</span>,</span><br><span class="line">            use: ExtractTextPlugin.extract(&#123;</span><br><span class="line">                fallback: <span class="string">'style-loader'</span>,</span><br><span class="line">                use: [<span class="string">'css-loader'</span>]</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;]</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="keyword">new</span> ExtractTextPlugin(&#123;</span><br><span class="line">            filename: <span class="string">'style/css/[name].css'</span>,</span><br><span class="line">            allChunks: <span class="literal">true</span> </span><br><span class="line">        &#125;)</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>###2.5 其他配置###</p><blockquote><p>stats配置</p></blockquote><p>在进行webpack打包的时候会出现很多的输出，但是有的输出是我们不需要看见的输出，这就可以采用stats进行配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">//</span> <span class="string">对webpack输出信息的配置，可以减少一些不必要的输出</span></span><br><span class="line"><span class="attr">stats:</span> <span class="string">&#123;</span></span><br><span class="line"><span class="attr">    children:</span> <span class="literal">false</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><blockquote><p>resolve.extensions 解决引入模块不需要加后缀<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// extensions 自动解决扩展，配置这个在引用模块时不用加后缀</span><br><span class="line">// modules 配置解析模块的搜索目录</span><br><span class="line">// path.<span class="built_in">resolve</span> 返回参数的绝对路径  path.<span class="keyword">join</span> 拼接路径 然后返回绝对路径</span><br><span class="line"><span class="built_in">resolve</span>: &#123;</span><br><span class="line">        module<span class="variable">s:</span> [path.<span class="built_in">resolve</span>(__dirname, <span class="string">'node_modules'</span>), path.<span class="keyword">join</span>(__dirname, <span class="string">'src'</span>)],</span><br><span class="line">        extension<span class="variable">s:</span> [<span class="string">'.wasm'</span>, <span class="string">'.mjs'</span>, <span class="string">'.js'</span>, <span class="string">'.json'</span>, <span class="string">'.jsx'</span>]</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>optimization配置 抽离公共模块<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">optimization</span>: &#123;</span><br><span class="line">    <span class="attribute">minimize</span>: false,</span><br><span class="line">    <span class="attribute">splitChunks</span>: &#123;</span><br><span class="line">        <span class="attribute">chunks</span>: <span class="string">'all'</span>,</span><br><span class="line">        <span class="attribute">name</span>: <span class="string">'common'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></p></blockquote><h2 id="last-一些解释及踩过的那些坑"><a href="#last-一些解释及踩过的那些坑" class="headerlink" title="last.一些解释及踩过的那些坑"></a>last.一些解释及踩过的那些坑</h2><p>###last.1 npm install 的时候 –save-dev 和–save的区别</p><p>首先这边的 <code>--save</code> 是将我们install的包写进package.json文件里面，后面的-dev才是要描述的重点，<code>-dev</code>是写进我们的<code>devDependencies</code>里面，如果不加这个那么是写进<code>dependencies</code>里面的，在生产环境下，是不会安装<code>devDependencies</code>里面的包的。这边找了一个别人的博客，写的比我这个更全面一点。<a href="https://www.cnblogs.com/blackgan/p/7678868.html" target="_blank" rel="noopener">对–save-dev和–save的区别详解</a></p><p>###last.2 webpack基础命令打包的时候报ERROR in multi ./src/apps/test.js dist/js/bundle.js<br>Module not found: Error: Can’t resolve ‘dist/js/bundle.js’ in ‘F:\WebDemo\webpackDemo’</p><p>这是因为webpack的版本问题，在webpack4.x版本之前的打包命令是<br><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml">webpack </span><span class="template-variable">&#123;entryFile&#125;</span><span class="xml"> </span><span class="template-variable">&#123;aimFile&#125;</span><span class="xml"></span></span><br></pre></td></tr></table></figure></p><p>但是在webpack4.x开始基础打包命令就变成了<br><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class">webpack </span>&#123;entryFile&#125; -<span class="class">o </span>&#123;aimFile&#125;</span><br></pre></td></tr></table></figure></p><p>###last.3出现Error: Cannot find module ‘@babel/core’###<br>这是因为<code>babel-loader</code>版本的问题，如果之前我们安装<code>babel-loader</code>的时候是采用<code>npm install babel-loader</code>这样写的话是默认安装最新版本的<code>babel-loader</code>最新的是8.x的，我们回退到7.1.5版本就可以避免这个报错了。</p><p>###last.4 webpack-dev-server问题 ###<br>1.webpack-dev-server 不会读取webpack.config.js配置的output也不会将生产的文件添加进项目目录里<br>2.webpack-dev-server 生成的文件和你dist里面的文件不是同一个文件。dist里面的是output里面决定<br>的webpack-dev-server打包生成的文件位置取决于contentBase配置</p><p>###last.5 的 package.json里面的打包命令###<br>–colors 输出结果带有颜色<br>–profile 输出性能数据看见每一步的耗时<br>–proress 输出当前的编译进度<br>–display-error-details 输出详细的错误信息</p><p>###lats.6 使用extractTextPlugin时报 Chunk.entrypoints: Use Chunks.groupsIterable and filter by instanceof Entrypoint instead###<br>这是因为安装<code>extract-text-webpack-plugin</code>的时候安装命令问题，实际上我们需要安装的是<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">"<span class="selector-tag">extract-text-webpack-plugin</span>": "^4<span class="selector-class">.0</span><span class="selector-class">.0-beta</span><span class="selector-class">.0</span>",</span><br></pre></td></tr></table></figure></p><p>解决办法，删除之前安装的extract插件，更换安装命令为<br><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --<span class="built_in">save</span>-<span class="built_in">dev</span> extract-text-webpack-plugin@<span class="built_in">next</span></span><br></pre></td></tr></table></figure></p><p>###last.7 入口文件配置[name].js 但是打包出来的文件总是main.js并不会根据入口名称决定出口名称###<br>这边的main.js main是取决你的主入口的，就是在执行npm init的时候那一堆默认的主入口。之所以没有按照入口文件来改变出口文件的名称，是因为入口文件采用的单入口的形式，也就是如下写法<br><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">entry</span>: path.resolve(__dirname, <span class="symbol">'src</span>/apps/console.jsx')</span><br></pre></td></tr></table></figure></p><p>使用单入口的形式，那么<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">output</span>: &#123;</span><br><span class="line">        <span class="attribute">path</span>: path.<span class="built_in">resolve</span>(__dirname, <span class="string">'dist'</span>),</span><br><span class="line">        filename: <span class="string">'js/[name].js'</span></span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure></p><p>打包生成的文件只会有一个main.js 并不会生成console.js<br>解决办法是将单入口的写法换成多入口的形式，也就是下面这种写法<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">entry</span>: &#123;</span><br><span class="line">        <span class="attribute">console</span>: path.<span class="built_in">resolve</span>(__dirname, <span class="string">'src/apps/console'</span>)</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure></p><p>这样打包出来的文件就是console.js</p><p>###last.7 bundle.js和vendor.js的引入顺序问题###<br>vendor.js一定是最先引用的，因为bundle.js要依赖于vendor.js生存。</p><p>###last.8 名词解释 ###<br>webpack.config.dev.js 开发环境下的webpack配置文件<br>webpack.config.prod.js 生产环境下的配置文件<br>vendor.js 这是打包我们引入的第三方包的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近学习了一波webpack打包部署，作为一名前端，不会一个打包的工具可真的是丢人啊。不过，用webpack又要接触到了配置文件，这个当初当我放弃写后端的东西，不过以后还是要全面发展的。好了，话不多说，这篇文章用的是webpack4.x版本的，下面将细数当初才过的坑。&lt;/p
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>腾讯云服务器配置JDK，tomcat解决外网无法访问问题</title>
    <link href="http://shenweini.cn/2018/11/10/%E8%85%BE%E8%AE%AF%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AEJDK%EF%BC%8Ctomcat%E8%A7%A3%E5%86%B3%E5%A4%96%E7%BD%91%E6%97%A0%E6%B3%95%E8%AE%BF%E9%97%AE%E9%97%AE%E9%A2%98/"/>
    <id>http://shenweini.cn/2018/11/10/腾讯云服务器配置JDK，tomcat解决外网无法访问问题/</id>
    <published>2018-11-10T04:26:58.000Z</published>
    <updated>2018-11-10T04:26:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>前几天试了一下腾讯云的学生服务器，在配置tomcat的时候，配置了好久，一直都是无法访问主页，翻看了N多的博客，关了防火墙，配置了安全组，依旧无法访问，接下来改了tomcat的配置终于成功，记录一下。<br>我用的是腾讯云的学生服务器，操作系统是CentOS7.2 64位 JDK版本是1.8.0 tomcat版本是8.5.34<br>准备一下XShell工具，我是使用的XShell。还有一个WinScp工具用来上传文件，当然也可以使用命令，但是我感觉有点慢，不懂是不是错觉。</p><h2 id="1-配置JDK"><a href="#1-配置JDK" class="headerlink" title="1.配置JDK"></a>1.配置JDK</h2><p>网上看到了很多配置jdk的方法，相对而言，配置一下jdk还是很简单。我是使用的直接解压linux版本的jdk文件然后配置下环境变量，当然也有的是直接使用yum安装jdk。那么我们首先去<a href="https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html" target="_blank" rel="noopener">jdk官网</a>下载一下jdk<br><img src="http://static.zybuluo.com/shenweizheng/d6as8u57y5cwx0zklb2l8ubg/image_1crsc1nek1797gbtv7i1rfvpiv9.png" alt="image_1crsc1nek1797gbtv7i1rfvpiv9.png-103.2kB"></p><p>这边我们用的是后缀为.tar.gz的，这是linux版本的<br>使用我们的WinScp工具把我们刚刚的下载的jdk上传至我们的服务器。用XShell登录进服务器，这边有一个问题就是我看到有的博客是说一开始进去的时候不是root用户但是我这边是进去就是root用户。下面的所有的配置我们都是要在root用户下进行的。<br><img src="http://static.zybuluo.com/shenweizheng/dpu4hunouaswrrmozaq12750/image_1crscssno10vipt7m0e37m1rfd13.png" alt="image_1crscssno10vipt7m0e37m1rfd13.png-21.9kB"></p><p>如果你不是root用户而是ubuntu用户那么<br><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">sudo su</span></span><br></pre></td></tr></table></figure></p><p>切换进root用户，当然我没有遇到这个问题。<br><img src="http://static.zybuluo.com/shenweizheng/jewd66ybvwimbvixxk3lxl4f/image_1crtp2a1sb8t10vtdsd1475dgs9.png" alt="image_1crtp2a1sb8t10vtdsd1475dgs9.png-25.8kB"><br>ls一下查看现在的根目录，解压jdk</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf jdk-<span class="number">8</span>u191-linux-x64<span class="selector-class">.tar</span><span class="selector-class">.gz</span></span><br></pre></td></tr></table></figure><p>ls查看一下解压成功</p><p><img src="http://static.zybuluo.com/shenweizheng/r5nqg0utk1vumr6jqro13xkp/image_1crtp97csdms3kc15pv10c01jkr16.png" alt="image_1crtp97csdms3kc15pv10c01jkr16.png-7.4kB"></p><p>接下来在/usr下面创建一下文件夹叫java</p><p><img src="http://static.zybuluo.com/shenweizheng/o3c26xka6jvyiwo7nesvgiv9/image_1crtpt60a3271k911pcd1c4boqf1j.png" alt="image_1crtpt60a3271k911pcd1c4boqf1j.png-10.8kB"></p><p>接下来把我们解压好的jdk放到上一步创建的文件夹下面</p><p><img src="http://static.zybuluo.com/shenweizheng/9qxwwuaubcriiuqy62j7jg38/image_1crtq214a1r2lav3t7svm8144c20.png" alt="image_1crtq214a1r2lav3t7svm8144c20.png-5kB"></p><p>下面就是配置jdk的环境变量，我们需要修改 /etc/profile文件</p><p><img src="http://static.zybuluo.com/shenweizheng/hretoz8xtgh5byccpiydt2fj/image_1crtq922b1kt1jmb15ri16on5sb2d.png" alt="image_1crtq922b1kt1jmb15ri16on5sb2d.png-2.7kB"></p><p>配置一下JAVA_HOME CLASSPATH PATH<br><img src="http://static.zybuluo.com/shenweizheng/gogfsd3z7zlxc8zjcvfk8gfy/image_1crtqakkmm3s1a6103c1duq1be2q.png" alt="image_1crtqakkmm3s1a6103c1duq1be2q.png-75.5kB"></p><p>按esc之后 :wq 保存退出编辑，不得不说linux命令还是要会的，多多少少会用到linux的东西<br>使用source命令使我们刚刚做的修改生效，使用java -version检查我们的配置是否正确<br><img src="http://static.zybuluo.com/shenweizheng/wx9rjeszrp6a80sx5x2lnffr/image_1crtqesme1pmnldm1ltm12u71uq737.png" alt="image_1crtqesme1pmnldm1ltm12u71uq737.png-15.3kB"></p><p>到此为止jdk的配置已经做完了，下面就是tomcat的配置，也是本章的重点，拿笔开始记笔记了。</p><h2 id="2-Tomcat配置以及外网无法访问问题"><a href="#2-Tomcat配置以及外网无法访问问题" class="headerlink" title="2.Tomcat配置以及外网无法访问问题"></a>2.Tomcat配置以及外网无法访问问题</h2><p>首先第一步我们得去下一个tomcat和jdk一样，这边给一个传送门<a href="https://tomcat.apache.org/download-80.cgi" target="_blank" rel="noopener">tomcat8.5</a><br><img src="http://static.zybuluo.com/shenweizheng/7i5yo5ja413q6abv4oflxlg8/image_1crtqmg8s4ap1joo1ls219a2140k3k.png" alt="image_1crtqmg8s4ap1joo1ls219a2140k3k.png-93.4kB"></p><p>老样子还是下.tar.gz的，接下来上传tomcat，解压tomcat，将解压好的文件夹移至我们的/usr/java文件夹下面，当然你也可以重新建一个，这都是小事。</p><p>我们进入java文件夹，ls一下现在是有两个文件夹，一个是我们上面的jdk另一个是刚刚的tomcat</p><p><img src="http://static.zybuluo.com/shenweizheng/1jujj0042crmuqpr3nhq01he/image_1crtqu1pvaag1fcn4ld123vpdl41.png" alt="image_1crtqu1pvaag1fcn4ld123vpdl41.png-9.4kB"></p><p>那么下面就是tomcat的问题，首先我们去修改一下tomcat的端口号，默认是8080我们这边修改成80。修改conf/server.xml文件</p><p><img src="http://static.zybuluo.com/shenweizheng/m481dibr6w5yrraphxtm425r/image_1crtr550hecc8krk3e1spm18e14e.png" alt="image_1crtr550hecc8krk3e1spm18e14e.png-87.4kB"></p><p>接下来就是启动我们的tomcat先看一下能不能访问。启动程序和关闭程序在 bin目录下有一个startup.sh 和shutdown.sh<br><img src="http://static.zybuluo.com/shenweizheng/wfhcb1ul4humux1pedea0xuo/image_1crtr8o56c35t577c01j8n1e3d4r.png" alt="image_1crtr8o56c35t577c01j8n1e3d4r.png-23.9kB"></p><p>如果这一步遇到 -bash: startup.sh not command这种报错时<br><img src="http://static.zybuluo.com/shenweizheng/kmv88x25dvqaps4h54xmgps2/image_1crtrcipe1nla1bfd1honj199j458.png" alt="image_1crtrcipe1nla1bfd1honj199j458.png-3.3kB"></p><p>然后再执行startup.sh文件，这样就可以了。<br>那么我们这边开启了tomcat，使用外网ip加端口号访问一下看看情况。<br>如果你不能访问，首先配置一下云服务器的安全组，这边我们直接默认全部端口都放通，当然你也可以自定义配置一下规则。<br><img src="http://static.zybuluo.com/shenweizheng/5fo9j5yft5genj37nn2kuume/image_1crtrkq1k1d56sa6i1l18vf97t5l.png" alt="image_1crtrkq1k1d56sa6i1l18vf97t5l.png-134.3kB"></p><p>接下来重启一下服务器，不知道要不要重启，反正我是重启了一下。之后再去访问一下80端口，看能不能出现tomcat的主页，如果还是不行，那么接下去我们继续配置，这边安全组是已经都开启了，接下来我们查看80端口有没有开启。<br><img src="http://static.zybuluo.com/shenweizheng/ajfaio341tmx3l9idey0ylsq/image_1crtrscii1ls21anrl9417411oq762.png" alt="image_1crtrscii1ls21anrl9417411oq762.png-20.2kB"></p><p>我这边是已经配置好了的，所以80端口是开启的，如果你的80端口没有开启，那么下面我们去搞一下防火墙。<br>首先我们查看一下防火墙的状态<br><img src="http://static.zybuluo.com/shenweizheng/xnj3z2ymgshz32aylpes248g/image_1crts1red1bu81bfd50d4q1dio6f.png" alt="image_1crts1red1bu81bfd50d4q1dio6f.png-14.5kB"></p><p>发现现在防火墙是关闭的，这边我们先开启一下防火墙，不然待会出现filreWalld not runnuind的错<br><img src="http://static.zybuluo.com/shenweizheng/xs7nmzqmlgvdzwi1anzg7cvf/image_1crtsqrhpmbqirf1n2g17p0n2s6s.png" alt="image_1crtsqrhpmbqirf1n2g17p0n2s6s.png-10.2kB"></p><p>这边配置好了之后，我们在吧防火墙关闭一下<br><code>systemctl stop firewalld</code>，我们进入tomcat的bin目录下重启一下服务器。<br><img src="http://static.zybuluo.com/shenweizheng/objwn9diivl04baejjzuw4ru/image_1crtssq284be17641u821v391dgc79.png" alt="image_1crtssq284be17641u821v391dgc79.png-83.6kB"></p><p>如果你在关闭的时候遇到Neither the JAVA_HOME nor the JRE_HOME environment variable is defined这个报错的时候，使用vim修改一下bin目录下的setclasspath.sh，手动添加JAVA_HOME和JRE_HOME两个环境变量。<br><img src="http://static.zybuluo.com/shenweizheng/i7us0bl35qtytmr8ie00rchh/image_1crtt3g1d1lno1552p601sr325f83.png" alt="image_1crtt3g1d1lno1552p601sr325f83.png-269.3kB"></p><p>关闭之后，在启动一下tomcat，打开浏览器，访问公网ip访问，出现tomcat主页。如果还是没有出现的话，就无能为力了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前几天试了一下腾讯云的学生服务器，在配置tomcat的时候，配置了好久，一直都是无法访问主页，翻看了N多的博客，关了防火墙，配置了安全组，依旧无法访问，接下来改了tomcat的配置终于成功，记录一下。&lt;br&gt;我用的是腾讯云的学生服务器，操作系统是CentOS7.2 64位 
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>常用样式汇总</title>
    <link href="http://shenweini.cn/2018/11/01/%E5%B8%B8%E7%94%A8%E6%A0%B7%E5%BC%8F%E6%B1%87%E6%80%BB/"/>
    <id>http://shenweini.cn/2018/11/01/常用样式汇总/</id>
    <published>2018-11-01T13:45:27.000Z</published>
    <updated>2018-11-01T13:45:27.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-小手样式"><a href="#1-小手样式" class="headerlink" title="1.小手样式"></a>1.小手样式</h2><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cursor</span>: pointer</span><br></pre></td></tr></table></figure><h2 id="2-垂直居中"><a href="#2-垂直居中" class="headerlink" title="2.垂直居中"></a>2.垂直居中</h2><p>使用flex布局<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">div</span> <span class="built_in">class</span>=<span class="string">"outer"</span>&gt;</span><br><span class="line">    &lt;<span class="keyword">div</span> <span class="built_in">class</span>=<span class="string">"inner"</span>&gt;&lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">&lt;/<span class="keyword">div</span>&gt;</span><br></pre></td></tr></table></figure></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.outer</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid red;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">justify-content</span>: center;</span><br><span class="line">    <span class="attribute">align-items</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.inner</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid black;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>vertical-align属性<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">div</span> <span class="built_in">class</span>=<span class="string">"outer"</span>&gt;</span><br><span class="line">    &lt;<span class="keyword">div</span> <span class="built_in">class</span>=<span class="string">"inner"</span>&gt;&lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">&lt;/<span class="keyword">div</span>&gt;</span><br></pre></td></tr></table></figure></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.outer</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid red;</span><br><span class="line">    <span class="attribute">display</span>: table-cell;</span><br><span class="line">    <span class="attribute">vertical-align</span>: middle;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.inner</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid black;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>绝对定位<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">div</span> <span class="built_in">class</span>=<span class="string">"outer"</span>&gt;</span><br><span class="line">    &lt;<span class="keyword">div</span> <span class="built_in">class</span>=<span class="string">"inner"</span>&gt;&lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">&lt;/<span class="keyword">div</span>&gt;</span><br></pre></td></tr></table></figure></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.outer</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid red;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.inner</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid black;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">margin</span>: auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>after<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">div</span> <span class="built_in">class</span>=<span class="string">"outer"</span>&gt;</span><br><span class="line">    &lt;<span class="keyword">div</span> <span class="built_in">class</span>=<span class="string">"inner"</span>&gt;&lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">&lt;/<span class="keyword">div</span>&gt;</span><br></pre></td></tr></table></figure></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.outer</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid red;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.outer</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">display</span>: inline-block;</span><br><span class="line">    <span class="attribute">vertical-align</span>: middle;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">''</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.inner</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid black;</span><br><span class="line">    <span class="attribute">display</span>: inline-block;</span><br><span class="line">    <span class="attribute">vertical-align</span>: middle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-vertical-align失效问题"><a href="#3-vertical-align失效问题" class="headerlink" title="3.vertical-align失效问题"></a>3.vertical-align失效问题</h2><p>vertical-align属性只对行内元素有效果，要想在块级元素失效先设置一下displayinline-block</p><h2 id="4-css渐变"><a href="#4-css渐变" class="headerlink" title="4. css渐变"></a>4. css渐变</h2><p>线性渐变-从上到下（默认）<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#grad</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">-webkit-linear-gradient</span>(red, blue); <span class="comment">/* Safari 5.1 - 6.0 */</span></span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">-o-linear-gradient</span>(red, blue); <span class="comment">/* Opera 11.1 - 12.0 */</span></span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">-moz-linear-gradient</span>(red, blue); <span class="comment">/* Firefox 3.6 - 15 */</span></span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">linear-gradient</span>(red, blue); <span class="comment">/* 标准的语法 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>线性渐变-从左到右<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#grad</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">-webkit-linear-gradient</span>(left, red , blue); <span class="comment">/* Safari 5.1 - 6.0 */</span></span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">-o-linear-gradient</span>(right, red, blue); <span class="comment">/* Opera 11.1 - 12.0 */</span></span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">-moz-linear-gradient</span>(right, red, blue); <span class="comment">/* Firefox 3.6 - 15 */</span></span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">linear-gradient</span>(to right, red , blue); <span class="comment">/* 标准的语法 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>线性渐变 - 对角<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#grad</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">-webkit-linear-gradient</span>(left top, red , blue); <span class="comment">/* Safari 5.1 - 6.0 */</span></span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">-o-linear-gradient</span>(bottom right, red, blue); <span class="comment">/* Opera 11.1 - 12.0 */</span></span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">-moz-linear-gradient</span>(bottom right, red, blue); <span class="comment">/* Firefox 3.6 - 15 */</span></span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">linear-gradient</span>(to bottom right, red , blue); <span class="comment">/* 标准的语法 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-小手样式&quot;&gt;&lt;a href=&quot;#1-小手样式&quot; class=&quot;headerlink&quot; title=&quot;1.小手样式&quot;&gt;&lt;/a&gt;1.小手样式&lt;/h2&gt;&lt;figure class=&quot;highlight arduino&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;g
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>window.open被拦截解决</title>
    <link href="http://shenweini.cn/2018/10/28/window.open%E8%A2%AB%E6%8B%A6%E6%88%AA/"/>
    <id>http://shenweini.cn/2018/10/28/window.open被拦截/</id>
    <published>2018-10-28T04:24:46.000Z</published>
    <updated>2018-10-28T04:24:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>项目开发中遇到window.open写在回调里被浏览器拦截.<br>解决办法是在请求时新开一个tab页，然后再请求的回调里修改这个tab页的地址.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> newWindow = <span class="built_in">window</span>.open(<span class="string">'about:blank'</span>); <span class="comment">//  新开一个tab页返回一个window对象</span></span><br><span class="line">axios.post(url&#125;)</span><br><span class="line">    .then(<span class="function"><span class="params">response</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(response.data.status.code === <span class="number">1</span>)&#123;</span><br><span class="line">            newWindow.location.href = <span class="string">''</span> <span class="comment">//  修改新开页面的地址</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(<span class="function"><span class="params">error</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(error);</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;项目开发中遇到window.open写在回调里被浏览器拦截.&lt;br&gt;解决办法是在请求时新开一个tab页，然后再请求的回调里修改这个tab页的地址.&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>react应用中mobx未检测到数组的更新</title>
    <link href="http://shenweini.cn/2018/10/28/react%E5%BA%94%E7%94%A8%E4%B8%ADmobx%E6%9C%AA%E6%A3%80%E6%B5%8B%E5%88%B0%E6%95%B0%E7%BB%84%E7%9A%84%E6%9B%B4%E6%96%B0/"/>
    <id>http://shenweini.cn/2018/10/28/react应用中mobx未检测到数组的更新/</id>
    <published>2018-10-28T03:33:35.000Z</published>
    <updated>2018-10-28T03:33:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>在mobx中定义一个可观察的数组<br><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Store</span>&#123;</span></span><br><span class="line">    @observable testArray = [];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在组件里面引用这个store<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">testArray.map(<span class="function"><span class="params">item</span>=&gt;</span>(</span><br><span class="line">    &lt;span&gt;&#123;item&#125;&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">))</span></span><br></pre></td></tr></table></figure></p><p>这个打印这个testArray数组会发现这个时候的数组类型已经不是我们常规的array类型了，已经被mobx转换成了observableArray类型的数组，这种的如果你的store里面只有这一个数组没有其他变量的时候，更新整个数组，除非你是将这个数组置为空，不然组件是不会观察到他的改变，就不会重新render了<br>解决办法是：<br>在组件中使用这个数组的时候，slice()一下转变成我们正常的js类型的array就可以了<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">testArray.slice().map(<span class="function"><span class="params">item</span>=&gt;</span>(</span><br><span class="line">    &lt;span&gt;&#123;item&#125;&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">))</span></span><br></pre></td></tr></table></figure></p><p>具体slice的地方可以是在store里面也可以在组件里面，组件里面就像上面写的那样,store里面就是先得到testArray然后slice一下，在把新的数组赋值给他。<br>如果遇到使用数组的时候出现一些看不懂的报错，排除数组越界的一些错误，多半是因为observableArray类型的问题，这个时候不妨slice()一下试试。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在mobx中定义一个可观察的数组&lt;br&gt;&lt;figure class=&quot;highlight coffeescript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>第一次使用hexo搭建博客的记录</title>
    <link href="http://shenweini.cn/2018/10/27/%E7%AC%AC%E4%B8%80%E6%AC%A1%E4%BD%BF%E7%94%A8hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E7%9A%84%E8%AE%B0%E5%BD%95/"/>
    <id>http://shenweini.cn/2018/10/27/第一次使用hexo搭建博客的记录/</id>
    <published>2018-10-27T09:50:46.000Z</published>
    <updated>2018-10-27T09:50:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>基于github的博客，搭建过程可谓可歌可泣，翻遍了配置文件，总的来说是成功了百分之八十。基本的形状已经搭建好了，评论的功能还未加入，等待后续添加。刚开始使用的是Jekyll的主题，个人觉得还是hexo的主题好看一点，主要是一开始使用Jekyll的主题直接崩掉了，汗。。。。</p><h2 id="1-创建一个github账户"><a href="#1-创建一个github账户" class="headerlink" title="1.创建一个github账户"></a>1.创建一个github账户</h2><p>这个直接官网创建 <a href="https://github.com/" target="_blank" rel="noopener">GitHub</a></p><h2 id="2-创建一个本地仓库"><a href="#2-创建一个本地仓库" class="headerlink" title="2.创建一个本地仓库"></a>2.创建一个本地仓库</h2><p><img src="http://static.zybuluo.com/shenweizheng/m90nw4nyb9ohg4tqv1ruaw8i/TIM%E6%88%AA%E5%9B%BE20181021221725.png" alt="创建本地仓库"><br><img src="http://static.zybuluo.com/shenweizheng/kcp6ug83piiw75khyr3pjrck/TIM%E6%88%AA%E5%9B%BE20181021221854.png" alt="填写基本信息"><br>这里要注意你的Repository name的格式必须是  用户名.github.io，记得勾选下面的初始化README，当然这个选不选应该是无所谓的.<br>这个创建完之后，你的博客地址就是 https://用户名.github.io</p><h2 id="3-安装Git，node"><a href="#3-安装Git，node" class="headerlink" title="3.安装Git，node"></a>3.安装Git，node</h2><p>我们要用到git命令和node命令的，这边安装教程就没有了，官网上都有的，git不好安装的话直接去360安全管家上安装，反正我是这么安装的git</p><h2 id="4-配置git生成SSHkey"><a href="#4-配置git生成SSHkey" class="headerlink" title="4. 配置git生成SSHkey"></a>4. 配置git生成SSHkey</h2><p>鼠标右击会有一个 Git BashHere的菜单，选择这个，打开的就是我们Git命令行的页面了，首先设置一下全局的name和email<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git<span class="built_in"> config </span>--global user.name <span class="string">"你的GitHub用户名"</span></span><br><span class="line">git<span class="built_in"> config </span>--global user.email <span class="string">"你的GitHub注册邮箱"</span></span><br></pre></td></tr></table></figure></p><p>配置SSHkey<br><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -<span class="built_in">t</span> rsa -C <span class="string">"你的GitHub注册邮箱"</span></span><br></pre></td></tr></table></figure></p><p>如果你不需要修改存放路劲的话，一路回车，最后生成的sshkey在C:\Users\Administrator.ssh\id_rsa.pub这个里面<br>绑定SSHKey<br><img src="http://static.zybuluo.com/shenweizheng/yq5z8046ndm8lwqey2dre8w4/TIM%E6%88%AA%E5%9B%BE20181021223352.png" alt="TIM截图20181021223352.png-13.3kB"><br><img src="http://static.zybuluo.com/shenweizheng/6zihqrjaxju7inxwces2gjp3/TIM%E6%88%AA%E5%9B%BE20181021223452.png" alt="TIM截图20181021223452.png-55.5kB"><br>New SShkey  之后的title这个随意，key的内容是你C:\Users\Administrator.ssh\id_rsa.pub这个文件里面的内容你需要都复制过来</p><h2 id="5-安装Hexo"><a href="#5-安装Hexo" class="headerlink" title="5.安装Hexo"></a>5.安装Hexo</h2><p>在磁盘里新建一个文件夹 例如我在F盘新建一个myBlog的文件夹，进入该文件夹，鼠标右击git bash here<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="keyword">install</span> hexo-cli g</span><br><span class="line">npm <span class="keyword">install</span> hexo -g</span><br></pre></td></tr></table></figure></p><p>hexo-cli和hexo都全局安装一下<br><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">hexo v</span></span><br></pre></td></tr></table></figure></p><p>通过这个命令可以看一下hexo是不是装好了，如果出现 hexo 不是command这种报错的，表明环境变量没有配置好，需要配置一下环境变量，hexo在之前的版本好像是会自己配置环境变量，但是现在不行了，需要我们自己手动配置。<br>首先找到安装 hexo 的路径，例如我的是D:\nodejs\npm_global_modules\node_modules\hexo\node_modules<br>这边有一个问题就是node全局安装的模块的路径，默认都是在C盘，这样太占空间了，这个如有需要自行百度一下如何修改node全局模块的安装路径，我是改过了，C盘太小承受不住。回到正题，找到hexo的安装路径后，打开计算机的环境变量，在系统变量新建 HEXOPATH 变量值是我们找到的hexo安装目录，例如我的是D:\nodejs\npm_global_modules\node_modules\hexo\node_modules 这个要注意要hexo前面的路径每个人不一样，但是从hexo开始到后面的路径肯定是和我一样的。<br>要定位到hexo的node_modules下。创建完系统变量后，在环境变量里找到Path变量，点击编辑，在末尾添加<br><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">;<span class="meta">%</span>HEXOPATH<span class="meta">%</span>\.bi<span class="symbol">n</span></span><br></pre></td></tr></table></figure></p><p>注意这边的分号，如果本来path的末尾有分号的话就不用加了。配置完环境变量之后，cmd进命令行 hexo v看是不是能成功打印出hexo的版本号，类似于这样<br><img src="http://static.zybuluo.com/shenweizheng/qreltan9nvok2lwmp6opnidy/TIM%E6%88%AA%E5%9B%BE20181021225244.png" alt="TIM截图20181021225244.png-13.5kB"></p><h2 id="6-初始化hexo文件夹"><a href="#6-初始化hexo文件夹" class="headerlink" title="6.初始化hexo文件夹"></a>6.初始化hexo文件夹</h2><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">hexo init blog</span></span><br></pre></td></tr></table></figure><p>使用hexo init命令初始化一个叫blog的文件夹，然后<br><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cd</span> <span class="string">./blog</span></span><br></pre></td></tr></table></figure></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="keyword">install</span></span><br></pre></td></tr></table></figure><p>进入刚刚初始化的文件夹,安装hexo的相关配置<br>安装hexo的其他插件，在博客配置中需要用到<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="keyword">install</span> hexo-<span class="keyword">server</span> <span class="comment">--save</span></span><br><span class="line">npm <span class="keyword">install</span> hexo-<span class="keyword">admin</span> <span class="comment">--save</span></span><br><span class="line">npm <span class="keyword">install</span> hexo-generator-<span class="keyword">archive</span> <span class="comment">--save</span></span><br><span class="line">npm <span class="keyword">install</span> hexo-generator-feed <span class="comment">--save</span></span><br><span class="line">npm <span class="keyword">install</span> hexo-generator-<span class="keyword">search</span> <span class="comment">--save</span></span><br><span class="line">npm <span class="keyword">install</span> hexo-generator-tag <span class="comment">--save</span></span><br><span class="line">npm <span class="keyword">install</span> hexo-deployer-git <span class="comment">--save</span></span><br><span class="line">npm <span class="keyword">install</span> hexo-generator-sitemap <span class="comment">--save</span></span><br></pre></td></tr></table></figure></p><h2 id="7-本地访问"><a href="#7-本地访问" class="headerlink" title="7.本地访问"></a>7.本地访问</h2><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">生成静态页面</span><br><span class="line">hexo <span class="keyword">generate</span></span><br><span class="line">开启本地服务器</span><br><span class="line">hexo s</span><br><span class="line">访问地址</span><br><span class="line">http:<span class="comment">//localhost:4000/</span></span><br></pre></td></tr></table></figure><h2 id="8-部署github"><a href="#8-部署github" class="headerlink" title="8.部署github"></a>8.部署github</h2><p>在部署之前我们需要修改一下博客的配置，在blog/_config.yml为文件中找到deploy这个词，这个是配置github的<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">type</span>: git</span><br><span class="line">#这里是第二部创建的仓库的地址</span><br><span class="line"><span class="attribute">repo</span>: git<span class="variable">@github</span>.<span class="attribute">com</span>:git用户名/git用户户名.github.io.git</span><br><span class="line">#部署的分支</span><br><span class="line"><span class="attribute">branch</span>: master</span><br></pre></td></tr></table></figure></p><p>修改完配置之后<br><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#清空静态页面</span></span><br><span class="line">hexo clean</span><br><span class="line"><span class="meta">#生成静态页面</span></span><br><span class="line">hexo generate</span><br><span class="line"><span class="meta">#部署 </span></span><br><span class="line">hexo deploy</span><br></pre></td></tr></table></figure></p><p>输入你的博客地址 https://用户名.github.io 就可以访问了<br>hexo的主题更换配置以及hexo博客的配置将在下一篇写。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;基于github的博客，搭建过程可谓可歌可泣，翻遍了配置文件，总的来说是成功了百分之八十。基本的形状已经搭建好了，评论的功能还未加入，等待后续添加。刚开始使用的是Jekyll的主题，个人觉得还是hexo的主题好看一点，主要是一开始使用Jekyll的主题直接崩掉了，汗。。。。
      
    
    </summary>
    
      <category term="hexo" scheme="http://shenweini.cn/categories/hexo/"/>
    
    
  </entry>
  
  <entry>
    <title>关于springboot post方法参数为两个实体类的解决办法</title>
    <link href="http://shenweini.cn/2018/10/27/%E5%85%B3%E4%BA%8Espringboot%20post%E6%96%B9%E6%B3%95%E5%8F%82%E6%95%B0%E4%B8%BA%E4%B8%A4%E4%B8%AA%E5%AE%9E%E4%BD%93%E7%B1%BB%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"/>
    <id>http://shenweini.cn/2018/10/27/关于springboot post方法参数为两个实体类的解决办法/</id>
    <published>2018-10-27T09:48:55.000Z</published>
    <updated>2018-10-27T09:48:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>前端调用后端api某个post方法的时候，如果发现方法的参数为两个实体类的时候，我们像往常一样传参，后台会发生接收不到参数的问题。</p><h2 id="1-分装成dto"><a href="#1-分装成dto" class="headerlink" title="1.分装成dto"></a>1.分装成dto</h2><p>如果两个参数都是实体类的话，可以采用将两个实体类封装成一个实体类的方法。比如说有两个实体类，Techer和Course 这是两个pojo 那么我们可以定义一个实体类叫做 TeacherCourseDto 他的属性只有两个，一个是Teacher teacher一个是Course course 这样前台传参的时候<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attribute">teacher</span>: value1,</span><br><span class="line">    course: value2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样就可以了</p><h2 id="2-采用-InitBinder注解"><a href="#2-采用-InitBinder注解" class="headerlink" title="2.采用@InitBinder注解"></a>2.采用@InitBinder注解</h2><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@InitBinder</span>(<span class="string">"student"</span>)</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">initBinderStudent</span><span class="params">(WebDataBinder binder)</span></span>&#123;</span><br><span class="line">      binder.setFieldDefaultPrefix(<span class="string">"student."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@InitBinder</span>(<span class="string">"course"</span>)</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">initBinderCourse</span><span class="params">(WebDataBinder binder)</span></span>&#123;</span><br><span class="line">      binder.setFieldDefaultPrefix(<span class="string">"course."</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>@InitBinder() 中间的value值，用于指定表单属性或请求参数的名字，符合该名字的将使用此处的DataBinder<br>注意： binder.setFieldDefaultPrefix(“student.”)，这里的”.”千万别忘记了！！！<br><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword"><span class="keyword">implements</span> <span class="type">Serializable</span></span></span>&#123;  </span><br><span class="line">  <span class="keyword">String</span> id;  </span><br><span class="line">  <span class="keyword">String</span> note;  </span><br><span class="line">  <span class="comment">//get..set....  </span></span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Course</span> <span class="keyword"><span class="keyword">implements</span> <span class="type">Serializable</span></span></span>&#123;  </span><br><span class="line">  <span class="keyword">String</span> id;  </span><br><span class="line">  <span class="keyword">String</span> note;</span><br><span class="line">  <span class="comment">//set..get...  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这边两个实体类，加上我们上面的initBinder注解 还要在ctrl上做点动作<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span>  </span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/classtest"</span>)  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> TestController &#123;  </span><br><span class="line">    <span class="comment">// 绑定变量名字和属性，参数封装进类  </span></span><br><span class="line">    <span class="meta">@InitBinder</span>(<span class="string">"student"</span>)  </span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> initBinderUser(WebDataBinder binder) &#123;  </span><br><span class="line">        binder.setFieldDefaultPrefix(<span class="string">"student."</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">// 绑定变量名字和属性，参数封装进类  </span></span><br><span class="line">    <span class="meta">@InitBinder</span>(<span class="string">"course"</span>)  </span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> initBinderAddr(WebDataBinder binder) &#123;  </span><br><span class="line">        binder.setFieldDefaultPrefix(<span class="string">"course."</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">      </span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/methodtest"</span>)  </span><br><span class="line">    <span class="meta">@ResponseBody</span>  </span><br><span class="line">   <span class="keyword">public</span> Map&lt;<span class="built_in">String</span>,<span class="built_in">Object</span>&gt; test(<span class="meta">@ModelAttribute</span>(<span class="string">"student"</span>) Student student,<span class="meta">@ModelAttribute</span>(<span class="string">"course"</span>) Course course)&#123;  </span><br><span class="line">        Map&lt;<span class="built_in">String</span>,<span class="built_in">Object</span>&gt; map=<span class="keyword">new</span> HashMap&lt;<span class="built_in">String</span>,<span class="built_in">Object</span>&gt;();  </span><br><span class="line">        map.put(<span class="string">"student"</span>, student);  </span><br><span class="line">        map.put(<span class="string">"course"</span>, course);  </span><br><span class="line">        <span class="keyword">return</span> map;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>ctrl上的参数使用@ModelAttribute注解指定，这样就可以实现参数两个实体类，不用再去多写一个dto了<br>当然这种方法也有缺陷，具体参考<a href="https://www.jianshu.com/p/59771cbf373d" target="_blank" rel="noopener">SpringMVC表单多对象传递小技巧——@InitBinder</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前端调用后端api某个post方法的时候，如果发现方法的参数为两个实体类的时候，我们像往常一样传参，后台会发生接收不到参数的问题。&lt;/p&gt;
&lt;h2 id=&quot;1-分装成dto&quot;&gt;&lt;a href=&quot;#1-分装成dto&quot; class=&quot;headerlink&quot; title=&quot;1.分
      
    
    </summary>
    
    
  </entry>
  
</feed>
