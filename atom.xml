<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>唯你の博客</title>
  
  <subtitle>生活需要美好</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://shenweini.cn/"/>
  <updated>2020-02-19T13:13:11.265Z</updated>
  <id>http://shenweini.cn/</id>
  
  <author>
    <name>ShenWeiZheng</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="http://shenweini.cn/2020/02/19/%E6%B5%8B%E8%AF%95Typora/"/>
    <id>http://shenweini.cn/2020/02/19/测试Typora/</id>
    <published>2020-02-19T13:11:34.354Z</published>
    <updated>2020-02-19T13:13:11.265Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>《你不知道的JS》上篇整理</title>
    <link href="http://shenweini.cn/2020/02/14/%E3%80%8A%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JS%E3%80%8B%E4%B8%8A%E7%AF%87%E6%95%B4%E7%90%86%20/"/>
    <id>http://shenweini.cn/2020/02/14/《你不知道的JS》上篇整理 /</id>
    <published>2020-02-14T06:13:25.268Z</published>
    <updated>2020-02-19T13:10:28.572Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>读完《你不知道的js》已经过去很久了，正好顺着春招的气息，整理一波，复习一下JS基础，不得不说这本书刷新了我对JS得认知，看完红色的那本JS经典之后再来看这本你不知道的js简直就是爽爆了，如果能认认真真得啃完这两本书，理解深层次得js基础，那么js水准虽说距离阮一峰老师还有很大一截但至少能在中上游站稳脚跟。春招加油！！！努力进字节！！！</p></blockquote><a id="more"></a><h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>理解作用域首先来理解三个概念</p><ul><li><p>引擎：从头到尾负责整个JS程序得编译及执行过程</p></li><li><p>编译器：负责语法分析及代码生成等脏活累活</p></li><li><p>作用域：负责收集并维护由所有声明得标识符（变量）组成得一系列查询，并实施一套非严格得规则，确定当前执行的代码对这些标识符得访问权限。</p></li></ul><p>知道了这三个概念之后，我们来理解一下<code>var a = 2</code>这句代码的含义。这句代码在js底层会分为一下几步</p><ol><li><p>遇到<code>var a</code>，编译器会询问作用域是否已经有一个该名称的变量存在于同一个作用域得集合中，若有，编译器会跳过这条声明，继续编译。若没有，编译器会要求作用域在当前作用域得集合中生命一个变量并将其命名为 <code>a</code></p></li><li><p>接下来编译器会为引擎生成运行时所需要的代码，来处理 <code>a = 2</code> 这条赋值语句，引擎会询问当前作用域，是否存在一个变量 <code>a</code>，若有，引擎会使用这个变量，若没有，引擎会继续查找该变量（也就是后面说到的作用域连）</p></li><li><p>如果找到了，那么将 <code>2</code> 赋值给该变量，若没有，引擎将会抛出一个异常</p></li></ol><h3 id="LHS-RHS-查询"><a href="#LHS-RHS-查询" class="headerlink" title="LHS RHS 查询"></a>LHS RHS 查询</h3><p>上面说到引擎会去查找使用存在变量 <code>a</code>，这个查询称为<strong>LHS查询</strong>，另一种查询称为<strong>RHS查询</strong></p><p>从字面意思上可以大致猜出一个是‘左’查询，一个是‘右’查询，简单的理解就是当变量出现在赋值操作得左侧的时候就是<code>LHS</code>，反之，出现在右侧得时候就是<code>RHS</code>，这两种查询方式很好理解。</p><p>在通俗一点得讲就是，RHS查询是查找变量对应的值，而LHS查询是查找变量的容器本身，从而可以对其赋值。从这个角度讲，RHS并不是真正意义上的“赋值操作得右侧”，更准确得讲是“非左侧”</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">(a)</span> <span class="comment">&#123;</span></span></span><br><span class="line"><span class="function"><span class="comment">    console.log(a);</span></span></span><br><span class="line"><span class="function"><span class="comment">&#125;</span></span></span><br><span class="line"><span class="function"><span class="title">foo</span><span class="params">(a)</span>;</span></span><br></pre></td></tr></table></figure><p>观察上方一段代码，一个简单的打印形参<code>a</code>得函数。我们来找一下其中的变量查询方式。</p><ul><li>第 1 行，当调用<code>foo</code>函数得时候，会发生一个隐士得赋值操作就是<code>a = 2</code>，将传递得实参传递给形参，这边是对<code>a</code>得LHS查询</li><li>第 2 行，调用<code>console</code>对象重的<code>log</code>方法，是对<code>console</code>变量得RHS查询</li><li>第 2 行，打印<code>a</code>变量，是对<code>a</code>变量得RHS查询</li><li>第 4 行，调用了<code>foo</code>函数，是对<code>foo</code>变量的RHS查询</li></ul><h3 id="作用域嵌套"><a href="#作用域嵌套" class="headerlink" title="作用域嵌套"></a>作用域嵌套</h3><p>当一个块或者一个函数嵌套在另一个块或者另一个函数时，就发生了作用域嵌套。</p><blockquote><p>在es5之前，只有全局作用域和函数作用域<br>es6 出来之后，let const 语句产生了块作用域</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a + b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">foo(<span class="number">2</span>); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure><p>这段代码中，<code>foo</code>函数内部对变量<code>b</code>做了一个RHS查询，但是<code>foo</code>函数内部并没有变量<code>b</code>得声明，于是引擎会向上一级作用域中查找，当前代码中也就是全局作用域，找到了<code>var b = 2</code>，完成了对变量<code>b</code>得查询。</p><p>像这样一级一级得嵌套就产生了<strong>作用域链</strong>的概念。</p><blockquote><p>进行RHS查询时，引擎会在当前作用域中查找，若在当前作用域中没有找到该变量，就会向上一级作用中进行查找，一直到最外层的全局作用域，若还是没有找到所需变量，引擎会抛出<code>ReferenceError</code></p></blockquote><blockquote><p>而LHS查询，未找到变量的话，就会在全局作用域中隐式的创建一个具有该名称的变量，但是在ES5中引入了严格模式，严格模式下有很多不同的行为，其中一个行为就是不允许自动或隐式的创建全局变量</p></blockquote><h2 id="词法作用域"><a href="#词法作用域" class="headerlink" title="词法作用域"></a>词法作用域</h2><blockquote><p>作用域有两种工作模型，第一种是最为普遍的，被大多数编程语言采用的<strong>词法作用域</strong>，我们的JS也是采用的这种工作模型，另一种称为<strong>动态作用域</strong>，比如说Bash脚本，Perl中的一些模式等。后面提到的this的工作机制有一点像动态作用域但也只是有一点像而已，JS里是没有动态作用域的只有词法作用域。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> b = a * <span class="number">2</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">c</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(a, b, c);</span><br><span class="line">    &#125;</span><br><span class="line">    bar(b * <span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line">foo(<span class="number">2</span>); <span class="comment">// 2, 4, 12</span></span><br></pre></td></tr></table></figure><p>来分析一下这一段代码</p><ul><li><p>全局作用域下包含一个标识符<code>foo</code></p></li><li><p><code>foo</code>函数作用域下包含三个标识符<code>a</code> <code>b</code> <code>bar</code></p></li><li><p><code>bar</code>函数作用域下包含一个标识符 <code>c</code></p></li></ul><p>当函数<code>bar</code>在对<code>b</code>进行RHS查询的时候，返现<code>bar</code>函数作用域内没有标识符<code>b</code>，那么引擎就会向上一级作用域也就是<code>foo</code>函数作用域，找到其中的标识符<code>b</code>。</p><blockquote><p>作用域查找会在找到第一个匹配的标识符时停止。在多层的嵌套作用域中可以定义同名的标识符，这叫做 <strong>遮蔽效应</strong>（内部的标识符遮蔽了外部的标识符），作用域查找始终从运行时所处的最内部的作用域开始，逐渐向外或者向上进行，直到遇见第一个匹配的标识符停止。</p></blockquote><p><strong>无论函数在哪被调用，也无论函数如何被调用，他的词法作用域都只由函数被声明时所处的位置决定</strong>（这是理解词法作用域最重要的一点，理解了这一点后面的闭包才能更好的理解）</p><p>考虑如下代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a); <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line">    foo();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">foo();</span><br></pre></td></tr></table></figure><p>这边<code>foo</code>函数最终打印出来的值是<code>2</code>，而不是<code>3</code>，那是因为调用<code>foo</code>函数的时候，<code>foo</code>函数内部没有变量<code>a</code>，那么就会上一级作用域查找，而<code>foo</code>函数是定义在全局作用域的，因此上一级作用域是全局作用域，拿到全局的变量<code>a</code>。要<strong>谨记，js中只有词法作用域，作用域只由函数声明的位置来决定</strong></p><h3 id="eval-with-欺骗词法作用域"><a href="#eval-with-欺骗词法作用域" class="headerlink" title="eval with 欺骗词法作用域"></a>eval with 欺骗词法作用域</h3><p>JS有两种可以实现欺骗词法作用域的方法，这两种方法被各大开发者禁止使用，建议大家直接eslint禁止掉这两个方法的使用，欺骗了词法作用域会导致性能下降。<strong>谨记：不要使用这两个方法</strong></p><h4 id="eval"><a href="#eval" class="headerlink" title="eval"></a>eval</h4><p>考虑一下代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">str, a</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">eval</span>(str);</span><br><span class="line">    <span class="built_in">console</span>.log(a, b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">foo(<span class="string">"var b = 3"</span>, <span class="number">1</span>) <span class="comment">// 1, 3</span></span><br></pre></td></tr></table></figure><p>这段代码不会向预期的那样拿到全局作用域下的<code>b</code>，因为<code>eval</code>方法，导致<code>var b = 3</code>这段代码就好像本来就在<code>foo</code>函数里一样，事实上，引擎的确会在<code>foo</code>函数内部创建一个标识符<code>b</code>，并赋值为 <code>3</code>， 这样就屏蔽了全局作用域，达到了欺骗词法作用域的目的。</p><p>在严格模式下，<code>eval</code>方法有其自己的词法作用域，意味着其中的声明无法影响外部的作用域</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line"><span class="meta">    "use strict"</span></span><br><span class="line">    <span class="built_in">eval</span>(str);</span><br><span class="line">    <span class="built_in">console</span>.log(a); <span class="comment">// ReferenceError: a is not defined</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(<span class="string">"var a = 3"</span>)</span><br></pre></td></tr></table></figure><h4 id="with"><a href="#with" class="headerlink" title="with"></a>with</h4><p>这个就不说了</p><h2 id="函数作用域"><a href="#函数作用域" class="headerlink" title="函数作用域"></a>函数作用域</h2><blockquote><p>函数作用域的定义是：属于这个函数的全部变量都可以在整个函数的范围内使用及复用（事实上在嵌套的作用域中可以使用）</p></blockquote><p>首先来理解两个概念</p><ul><li><p>函数声明：以 <code>function</code> 关键词开始，形如<code>function foo() {}</code>的被称为<strong>函数声明</strong></p></li><li><p>函数表达式：以 <code>(function</code> 开始，形如 <code>(function() {})</code>的被称为<code>函数表达式</code></p></li></ul><p>区分这两种的方法很简单，就是看<code>function</code>是否出现在整个声明的第一个词，如果是的话那就是函数声明，若不是，那么就是函数表达式</p><p>下面来考虑这一段代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(a); <span class="comment">// 3</span></span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>这段代码使用<code>foo</code>函数包裹了一段代码段，避免了函数内部的<code>a</code>影响到外部的标识符<code>a</code>，但是<code>foo</code>这个名称本身“污染”了所在作用域（这个例子也就是全局作用域），理想状态是函数不需要名称这样就不会影响所在作用域，并可以可以自动运行，这是最理想的状态</p><p>考虑这段代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(a); <span class="comment">// 3</span></span><br><span class="line">    </span><br><span class="line">&#125;)();</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>使用函数表达式的形式，可以避免给函数起一个名字，同时直接调用，在代码运行的同时他就会立即调用，这种表达式成为<strong>IIFE（立即执行表达式）</strong></p><h3 id="匿名-具名"><a href="#匿名-具名" class="headerlink" title="匿名/具名"></a>匿名/具名</h3><p>具名很好理解就是一个函数有一个确切的名字，我们可以通过<code>名字()</code>的形式来调用。</p><p>匿名出现最多的场景就是回调函数</p><p>考虑一下代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'I waited 1 second'</span>);</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure><p>这叫做<strong>匿名函数表达式</strong>，因为<code>function() {...}</code>没有具体的名字。函数表达式可以匿名，但是函数声明必须有一个具体的名字。</p><p>匿名函数在开发中被大量使用，但是它具有一下几个小缺点</p><ul><li><p>匿名函数在栈追踪中不会显示出来有意义的函数名，不方便调试</p></li><li><p>如果没有函数名，当函数需要引用自身的话，需要使用已经过期的<code>arguments.callee</code>来使用，比如在递归中，再比如在事件监听器触发后需要解绑自身（这是一个非常令人不舒服的地方，所以我一般都是直接修改<code>window.onkeydown</code>类似属性）</p></li><li><p>匿名函数省略了具有一个描述性的函数名，对代码的可读性造成了些许的影响。</p></li></ul><h2 id="块作用域"><a href="#块作用域" class="headerlink" title="块作用域"></a>块作用域</h2><p>考虑一下代码</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var foo = true;</span><br><span class="line"><span class="keyword">if</span> (foo) &#123;</span><br><span class="line">    var <span class="built_in">bar</span> = foo * <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">bar</span> = something(<span class="built_in">bar</span>);</span><br><span class="line">    console.<span class="built_in">log</span>(<span class="built_in">bar</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>标识符<code>bar</code>仅在 if 声明的上下文中使用，但是但使用 <code>var</code> 关键字声明时，它写在哪里都一样，因为他都属于外部作用域，这个现象也就是后面会说的<strong>变量提升</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (a) &#123;</span><br><span class="line">    <span class="keyword">var</span> b = a * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>我们的理想状态是标识符<code>b</code>只在if声明的上下文中存在。</p><p>在看一个例子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>标识符<code>i</code>只在<code>for</code>循环中使用，我们为什么要让它污染了我们整个所在的作用域呢？</p><h3 id="with-1"><a href="#with-1" class="headerlink" title="with"></a>with</h3><p>严格模式下，用<code>width</code>从对象中创建的作用域仅在<code>with</code>声明中而非外部作用域中有效，这是块作用域的一种形式。</p><h3 id="try-catch"><a href="#try-catch" class="headerlink" title="try/catch"></a>try/catch</h3><p>这是一个很有意思的事情，我也是在看这本书的时候才了解到，<code>try/catch</code>语句中的<code>catch</code>代码块会创建一个块级作用域。</p><p>例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="literal">undefined</span>(); <span class="comment">// 强行制造异常</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error); <span class="comment">// 正常打印</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(error); <span class="comment">// ReferenceError: error is not defined</span></span><br></pre></td></tr></table></figure><p>标识符<code>error</code>只存在与<code>catch</code>语句内部</p><h3 id="let-const"><a href="#let-const" class="headerlink" title="let/const"></a>let/const</h3><p>在ES6出来之后，我们有了另外两种声明变量的关键字<code>let const</code>，这是JS开发者的福音。</p><blockquote><p><code>const</code> 声明的变量是常量，声明时必须赋值，并且之后不可在修改</p></blockquote><p><code>let</code>关键字可以将变量绑定到任意作用域，（通常是<code>{...}</code>内部），并且<strong><code>let const</code>声明的变量不具有变量提升的特性</strong></p><p>考虑以下代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// ReferenceError: a is not defined</span></span><br></pre></td></tr></table></figure><p>很明显<code>a</code>只存在于<code>if</code>上下文的内部。</p><p>考虑一下代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 块及作用域 - 作用域A</span></span><br><span class="line">        <span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(a); <span class="comment">// ReferenceError: a is not defined</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码很好的解释了，<code>let</code>声明的变量被绑定到了if内部的作用域A内部了，通常被绑定到<code>{...}</code>内部，因为在作用域A外部无法拿到标识符<code>a</code></p><p>同样的<code>for循环</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(i); <span class="comment">// ReferenceError: i is not defined</span></span><br></pre></td></tr></table></figure><p>我们通过<code>babel</code>来看一下转换之后的代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 转换前</span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转换后</span></span><br><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> _a = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(_a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br></pre></td></tr></table></figure><p>猜测babel监测到了<code>{}</code> 同时内部使用了<code>let</code>关键字，然后就将使用了<code>let</code>关键子换了个名字</p><h2 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h2><blockquote><p>变量提升在这本书中仅仅讲了三页纸不到，这是一个很简单的问题，我把它理解成一个现象，虽说简单，但是在开发过程中很多刚接触JS新手经常会发生这样一种疑问“为什么能拿到，为什么拿到的是undefined”</p></blockquote><blockquote><p>直觉上会认为JS代码执行时是由上到下一行一行运行的，但实际上并不完全正确，有一种特殊情况会导致这个假设是错误的。</p></blockquote><p>考虑以下代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><blockquote><p>产生这一现象的原因： 编译阶段中的一部分工作就是找到所有的声明，并用合适的作用域将它们关联起来</p></blockquote><p>因此，变量提升的含义可以理解为：<strong>包括变量和函数在内的所有声明都会在任何代码被执行前首先被处理。</strong></p><p>当你看到<code>var a = 2</code>的时候，编译器会将这一条语句理解为两段代码<code>var a</code> 和 <code>a = 2</code>，第一段代码会在编译时运行，而第二段代码会留在原地等待执行阶段。</p><p>因此，我们上方的代码实例可以转换为：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var a<span class="comment">;</span></span><br><span class="line">console.log(a)<span class="comment">;</span></span><br><span class="line"><span class="attribute">a</span> = <span class="number">1</span><span class="comment">;</span></span><br></pre></td></tr></table></figure><p>考虑一下代码</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">foo(); // <span class="keyword">is</span> <span class="keyword">raise</span></span><br><span class="line"><span class="keyword">function</span> <span class="title">foo</span>() &#123;</span><br><span class="line">    console.log('<span class="keyword">is</span> <span class="keyword">raise</span>');</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这个例子我们可以看出来，不仅是<code>var</code>声明的变量会被提升，<strong>函数声明也会被提升，并且函数提升时，会带着其整个函数一起提升</strong>，以上代码可以理解为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'is raise'</span>);</span><br><span class="line">&#125;</span><br><span class="line">foo(); <span class="comment">// is raise</span></span><br></pre></td></tr></table></figure><p>考虑以下代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">foo(); <span class="comment">// TypeError</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'is raise'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>变量标识符<code>foo</code>会被提升，但是赋值操作还留在原地等待执行阶段。上方代码可以理解为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo;</span><br><span class="line">foo(); <span class="comment">// TypeError</span></span><br><span class="line">foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'is raise'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出函数声明会被提升，而函数表达式却不会被提升。</p><p>函数声明和<code>var</code>声明的变量都会提升，那么提升的优先级呢，顺序不一样将会导致不一样的代码。</p><p>结论是<strong>函数提升优先于变量提升</strong></p><h3 id="函数提升优先于变量提升"><a href="#函数提升优先于变量提升" class="headerlink" title="函数提升优先于变量提升"></a>函数提升优先于变量提升</h3><p>考虑以下代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">foo(); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码可以理解为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的实例可以看出，函数声明的提升时优先于变量提升的，而且 <code>var foo</code>这条语句会被引擎给省略掉，因为在当前作用域中，已经有一个名称为<code>foo</code>的标识符了，<strong>重复声明会被引擎给跳过</strong>。这一点在第一节说到了。</p><p>那么如果多个重名的函数声明呢，提升的优先级呢？</p><p>考虑以下代码:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">foo(); <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码可以理解为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>可以看出，多个重名的函数声明，会按照书写的顺序进行提升，后者可以覆盖前者，因此这里会打印出 <code>3</code></p><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><blockquote><p>闭包在开发过程中很常见，你只需要知道去认识它，并知道你写的这一段代码就是闭包，而不应该去为了闭包而闭包</p></blockquote><blockquote><p>闭包是基于词法作用域书写代码所产生的自然结果。</p></blockquote><p>闭包的概念可以定义为：<strong>函数在当前词法作用域之外被调用。</strong></p><p>首先我们来看一下经典闭包代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> bar;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> baz = foo();</span><br><span class="line">baz();</span><br></pre></td></tr></table></figure><p>函数<code>foo</code>内部有一个函数<code>bar</code>并将整个函数返回出来，然后调用这个返回值，这是这段代码的字面意思。事实上标识符<code>baz</code>还是指向的<code>bar</code>函数，但是整个函数却在<code>foo</code>函数外部被调用，也就是说<code>bar</code>函数在自己的词法作用域之外被调用。这一段代码是一段经典闭包代码。</p><blockquote><p>当<code>foo</code>函数被执行之后，通常会期待<code>foo</code>函数内部整个作用域都被销毁，因为JS有一个垃圾回收机制，会释放不再使用的内存，但是在这边，闭包打断了整个回收，因为<code>bar</code>函数本身仍在使用这个作用域，<code>bar</code>函数依然持有该作用域的引用，这个引用就叫做闭包。</p></blockquote><p>考虑下面这段代码，你会对闭包有着更加深刻的认知。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">baz</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bar(baz);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    fn() <span class="comment">// 这就是闭包</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo();</span><br></pre></td></tr></table></figure><p>函数<code>baz</code>被当作参数传递给函数<code>bar</code>的行参<code>fn</code>，之后调这个<code>fn</code>，实质就是调用整个<code>baz</code>，调用位置不再函数<code>baz</code>的词法作用域，而是在<code>bar</code>函数的内部调用，这就是闭包。</p><blockquote><p>无论通过何种手段将内部函数传递到所在的词法作用域以外，它都会持有对原始定义作用域的引用，无论在何处执行这个函数都会使用闭包。</p></blockquote><p>考虑以下代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">wait</span>(<span class="params">message</span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(message);</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">wait(<span class="string">'hello 闭包'</span>);</span><br></pre></td></tr></table></figure><p>这是一段大家都很熟悉的代码，函数<code>timer</code>是<code>setTimeout</code>的回调，但是<code>timer</code>函数内部使用了外部的变量<code>message</code>，涵盖了<code>wait</code>函数的作用域，当<code>wait</code>调用时，其内部的作用域并不会被销毁，因为过一秒后执行的回调<code>timer</code>依然保留着<code>wait</code>的作用域。</p><h3 id="循环-闭包"><a href="#循环-闭包" class="headerlink" title="循环 + 闭包"></a>循环 + 闭包</h3><p>我们来看一段经典的代码</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (var <span class="built_in">i</span> = <span class="number">0</span>; <span class="built_in">i</span> &lt; <span class="number">5</span>; <span class="built_in">i</span>++) &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">timer</span><span class="params">()</span> &#123;</span></span><br><span class="line">        console.<span class="built_in">log</span>(<span class="built_in">i</span>);</span><br><span class="line">    &#125;, <span class="built_in">i</span> * <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>理想状态下是每隔一秒打印出对应的数字，但是实际情况每隔一秒打印一个 <code>5</code></p><p>我们来分析一下产生这个问题的原因，</p><ol><li><p>首先我们知道<code>setTimeout</code>定时器是一个异步任务，会在所用的同步任务执行完成之后再去执行异步任务，这是JS的EventLoop事件循环机制（其中还细分微任务，宏任务两个概念）</p></li><li><p>其次我们发现，内部的回调函数<code>timer</code>是一个闭包，它仍旧引用着外部的变量<code>i</code></p></li><li><p>然后我们回过头来发现，当for循环整个同步执行完成之后，变量<code>i</code>会自增到5，从而退出循环，而这个时候，没有同步任务了，就开始执行异步任务，异步任务时每隔一秒钟打印一下这个<code>i</code>，而现在变量<code>i</code>就是<code>5</code>，因此会产生这种现象。</p></li></ol><p>那么定位到了问题在哪那就好办了，我们可以给每个<code>timer</code>函数一个变量<code>i</code>的副本，也可以理解为一个<code>瞬时值</code>。那么如何给它一个瞬时值呢，答案就是给他创建一个独立的作用域，作用域内部的<code>i</code>会屏蔽掉for循环的游标<code>i</code>，这正是我们一开始说到的<strong>屏蔽效应</strong></p><p>因此我们的代码改写为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    (<span class="function"><span class="keyword">function</span> <span class="title">moment</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(i);</span><br><span class="line">        &#125;, i * <span class="number">1000</span>);</span><br><span class="line">    &#125;)(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>首先还是来一下这个<code>timer</code>函数，依旧是一个闭包，不过这次保留的不是for循环中的<code>i</code>而是<code>moment</code>函数的形参<code>i</code>，而<code>timer</code>保留的也是<code>moment</code>函数内部的作用域。</p></li><li><p>然后我们来看一下<code>moment</code>函数，这是一个<code>IIFE</code>，接受一个形参<code>i</code>，这个形参用来屏蔽循环中的<code>i</code>，这样就可以达到瞬时值的目的。</p></li></ol><p>那么除了这种方法，还有一种更为简单的就是使用ES6的<code>let</code>关键字声明变量<code>i</code>，因为我们只要达到一个块级作用域的目的就可以了。</p><p>代码修改为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i);</span><br><span class="line">    &#125;, i * <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h3><p>模块正是利用了闭包的强大威力。</p><p>考虑如下代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CalModule</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> something = <span class="string">'cool'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> another = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(something);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">doAnother</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(another);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        doSomething: doSomething,</span><br><span class="line">        doAnother: doAnother</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = CalModule();</span><br><span class="line"></span><br><span class="line">foo.doSomething(); <span class="comment">// cool</span></span><br><span class="line">foo.doAnother(); <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure><p>这个模式被称为<strong>模块</strong></p><p>函数<code>CalModule</code>返回一个对象，对象中包含了两个方法，用于在其他的地方进行调用，但是函数内部的变量<code>something another</code>不会被直接修改， 只能通过函数<code>CalModule</code>暴露出来的方法来进行修改数据，这就是模块的魅力，利用了闭包的强大威力。</p><p>模块必须具有两个条件：</p><ul><li><p>必须有外部的封闭函数，该函数必须至少被调用一次（每次调用都会产生一个新的模块实例）</p></li><li><p>封闭函数必须返回至少一个内部函数，这样内部函数才能在私有作用域中形成闭包，并且可以访问或者修改私有的状态。</p></li></ul><h4 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h4><p>每次调用封闭函数的时候都会返回一个新的模块实例，那么当我们只需要一个实例的时候，我们可以使用单例模式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = (<span class="function"><span class="keyword">function</span> <span class="title">CalModule</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> something = <span class="string">'cool'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> another = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(something);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">doAnother</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(another);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        doSomething: doSomething,</span><br><span class="line">        doAnother: doAnother</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">foo.doSomething();</span><br></pre></td></tr></table></figure><p>使用<code>IIFE</code>表达式，得到一个模块实例，这样每次使用的都是同一个实例。</p><h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><blockquote><p><code>this</code>一直都是一个非常神奇的东西，在使用函数的时候经常会用到this，我们首先得搞明白为什么需要<code>this</code>，其次需要理解JS中<code>this</code>的执行机制是什么，只有了解了执行机制我们就能灵活的运用this。</p></blockquote><p>this提供了一种优雅的方式来隐式的传递执行上下文，可以将API设计的更加简洁并易于复用。</p><p><strong>this是在运行时进行绑定的，并不是在编写时绑定的，它的上下文取决于函数调用时的各种条件。this和函数的声明没有任何关系，只取决于函数的调用方式</strong></p><h3 id="默认绑定"><a href="#默认绑定" class="headerlink" title="默认绑定"></a>默认绑定</h3><p><strong>当函数不加任何修饰直接调用时，或者不匹配其他规则时都会引用默认绑定规则</strong>，默认绑定规则下，this 将指向全局，在浏览器环境中也就是<code>window</code></p><p>但是在严格模式下，this 会绑定到 undefined</p><p>考虑如下代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">foo(); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>函数<code>foo</code>不加任何修饰直接调用。</p><p>考虑如下代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    foo: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> bar = obj.foo;</span><br><span class="line">bar(); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>即使函数<code>bar</code>是<code>obj.foo</code>的一个引用，但是<code>bar</code>函数是直接调用的，所以this指向全局。<strong>谨记：this 指向是运行时确定的，和函数声明的位置无关，只与函数的调用方式有关</strong></p><p>考虑如下代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doFoo</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    fn(); <span class="comment">// 不加任何修饰直接调用，指向全局</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a: <span class="number">2</span>,</span><br><span class="line">    foo: foo</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="string">'ops'</span>;</span><br><span class="line"></span><br><span class="line">doFoo(obj.foo); <span class="comment">// ops</span></span><br></pre></td></tr></table></figure><h3 id="隐式绑定"><a href="#隐式绑定" class="headerlink" title="隐式绑定"></a>隐式绑定</h3><p>隐式绑定指的是函数有明确的调用者，这种绑定规则下，this 指向调用者。</p><p>考虑如下代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a: <span class="number">2</span>,</span><br><span class="line">    foo: foo</span><br><span class="line">&#125;;</span><br><span class="line">obj.foo(); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>函数<code>foo</code>并不是不加任何修饰的调用了，他的前面有了一个调用者<code>obj</code>，这个时候函数的this指向是指向的<code>obj</code>调用者了。</p><p>考虑如下代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;</span><br><span class="line">    a: <span class="number">42</span>,</span><br><span class="line">    foo: foo</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a: <span class="number">2</span>,</span><br><span class="line">    obj2: obj2</span><br><span class="line">&#125;;</span><br><span class="line">obj.obj2.foo(); <span class="comment">// 42</span></span><br></pre></td></tr></table></figure><p>函数<code>foo</code>的前面有了多个调用者，这个时候，<strong>foo函数只看最后一层调用</strong>，这边也就是对象<code>obj2</code></p><h3 id="显示的绑定"><a href="#显示的绑定" class="headerlink" title="显示的绑定"></a>显示的绑定</h3><h4 id="call-apply"><a href="#call-apply" class="headerlink" title="call/apply"></a>call/apply</h4><p>使用call函数可以修改一个函数的this指向。</p><p>考虑如下代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">'window'</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a: <span class="string">'obj'</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line">foo.call(obj); <span class="comment">// obj</span></span><br></pre></td></tr></table></figure><p>foo函数在调用时通过call方法修改了this指向，这是显示的绑定。与之类似的是<code>apply</code>，两者的第一个参数都是新的this指向，唯一的区别在于<strong>参数传递的方式不一样</strong></p><p><strong>call传递的是一个参数列表</strong><br><strong>apply传递的是一个数组</strong></p><p> 考虑如下代码：</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">'window'</span>;</span><br><span class="line"><span class="keyword">var</span> obj = <span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    a: 'call'</span></span><br><span class="line"><span class="comment">&#125;</span>;</span><br><span class="line"><span class="keyword">var</span> obj2 = <span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    a: 'apply'</span></span><br><span class="line"><span class="comment">&#125;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">(param1, param2)</span> <span class="comment">&#123;</span></span></span><br><span class="line"><span class="function"><span class="comment">    console.log(this.a, param1, param2);</span></span></span><br><span class="line"><span class="function"><span class="comment">&#125;</span></span></span><br><span class="line"><span class="function"><span class="title">foo</span>.<span class="title">call</span><span class="params">(obj, <span class="string">'param1'</span>, <span class="string">'params2'</span>)</span>;</span> <span class="comment">//call param1 params2</span></span><br><span class="line">foo.apply(obj2, [<span class="string">'param1'</span>, <span class="string">'params2'</span>]); <span class="comment">// apply param1 params2</span></span><br></pre></td></tr></table></figure><h4 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h4><p>bind绑定是<code>call apply</code>绑定得一个变种，是一种显示得强制绑定，被称为“硬绑定”。bind函数返回一个新的函数，这个新的函数不能再被<code>call apply</code>等二次修改this指向。</p><p>使用方式如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a: <span class="string">'bind'</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;</span><br><span class="line">    a: <span class="string">'second change'</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">param1, param2</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a, <span class="built_in">arguments</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> newFoo = foo.bind(obj, <span class="string">'pram1'</span>, <span class="string">'param2'</span>);</span><br><span class="line">newFoo.call(obj2); <span class="comment">// bind ['param1', 'param2']</span></span><br><span class="line">newFoo(<span class="string">'param3'</span>, <span class="string">'param4'</span>); <span class="comment">// bind ['param1', 'param2', 'param3', 'param4']</span></span><br></pre></td></tr></table></figure><ul><li><p>首先第 10 行，我们使用bind方法，返回一个新的函数，第一个参数为新函数的this指向，之后会传递一个参数列表作为函数的参数。最终的<code>foo</code>函数的得到的参数是bind时传递的参数列表加上调用<code>newFoo</code>新函数传递的参数组合起来得一个参数列表</p></li><li><p>第 11 行，可以发现，通过<code>bind</code>修饰后的新函数不能再被<code>call apply</code>等二次修改 this 指向。</p></li></ul><h3 id="new-绑定"><a href="#new-绑定" class="headerlink" title="new 绑定"></a>new 绑定</h3><p>该绑定规则适用于 <code>new</code> 绑定关键字，该规则this指向new出来的那个实例。</p><p>当我们执行<code>new</code>操作的时候，实际上发生了如下步骤：</p><ol><li><p>创建一个全新的对象</p></li><li><p>这个新对象执行[[Prototype]]绑定</p></li><li><p>这个新的对象将会绑定到函数调用得this</p></li><li><p>如果函数没有返回对象，那么new表达式中的函数调用会自动返回这个新对象。</p></li></ol><p>考虑如下代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.a = a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = <span class="keyword">new</span> foo(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(bar.a); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><h3 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h3><p>尤高到底分别为：</p><ol><li><p>new 绑定</p></li><li><p>bind 绑定</p></li><li><p>call, apply绑定</p></li><li><p>隐式绑定</p></li><li><p>默认绑定</p></li></ol><blockquote><p><strong>当你把 null 或者 undefined 作为 this 得绑定对象传入 call, apply, bind，这些值在调用时会被忽略，实际应用的是默认绑定规则</strong></p></blockquote><h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><p>箭头函数是ES6新增一个函数写法，写法非常cool，也非常简洁，至少我本人非常喜欢这个。唯一要注意的是箭头函数得this指向不应用上方介绍的任何一种规则，而是根据外层（函数或者全局）作用域来决定this，这个时候得看箭头函数的词法作用域，并且箭头函数得this不可以经过二次修改。</p><p>总结为以下几点：</p><ul><li><p>箭头函数的this是定义时确定的，继承至父级的（函数或者全局）作用域</p></li><li><p>箭头函数得this不可二次修改</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">a</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">    a: <span class="string">'obj1'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;</span><br><span class="line">    a: <span class="string">'obj2'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> bar = foo.call(obj1);</span><br><span class="line">bar.call(obj2); <span class="comment">// obj1</span></span><br></pre></td></tr></table></figure><p>函数<code>foo</code>返回一个箭头函数，根据我们总结得第一点，我们得箭头函数中的this是父级作用域也就是<code>foo</code>函数内部，这个时候通过<code>call</code>方法修改<code>foo</code>函数得this，使其指向了<code>obj1</code>，也就是说这个箭头函数的this已经定死了执行<code>obj1</code>（除非修改foo函数的this指向）， 之后第 13 行再次使用call试图修改箭头函数的指向，结果证明并没有成功，这也证实了我们的第二点。</p><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><blockquote><p>JS是一门面向对象的语言，而ES6带来了<code>Class</code>语法，但是这并不意味着JS中实际上有类得，看到babel对类解析之后得代码的话就知道，Class 最终还是会被转换为普通的函数，只不过这些函数得函数名首字母大写了，我们称之为“构造函数”，但是没有任何规范要求你构造函数的首字母大写。</p></blockquote><blockquote><p>Class 关键字可以使你创建一个类，然后这个类中使用<code>new</code>关键字来构造一个实例，JS中得类同样满足封装、继承、多态。</p></blockquote><blockquote><p>但是每次<code>new</code>出一个实例的时候，这个实例都是一个单独得实例，它不和其他实例有什么关联，唯一的联系是它们都属于同一个类，所以<strong>无法实现实例间得数据共享</strong>。而使用原生函数加上原型链我们可以轻松的实现数据共享且构造简单。</p></blockquote><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><p>JS中的object是以key-value形式存在的，那么这边要介绍的点是对象上的两种属性描述符：数据描述符和访问描述符</p><p>我们可以通过 <code>Object.defineProperty</code>来给一个对象添加一个 key 并且为这个 key 设置属性描述符。</p><p>考虑如下代码：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">var</span> <span class="string">obj</span> <span class="string">=</span> <span class="string">&#123;&#125;;</span></span><br><span class="line"><span class="string">Object.defineProperty(obj,</span> <span class="string">'foo'</span><span class="string">,</span> <span class="string">&#123;</span></span><br><span class="line"><span class="attr">    configurable:</span> <span class="literal">true</span><span class="string">,</span></span><br><span class="line"><span class="attr">    enumerable:</span> <span class="literal">true</span><span class="string">,</span></span><br><span class="line"><span class="attr">    writable:</span> <span class="literal">true</span><span class="string">,</span></span><br><span class="line"><span class="attr">    value:</span> <span class="string">'obj'</span></span><br><span class="line"><span class="string">&#125;);</span></span><br><span class="line"><span class="string">console.log(obj);</span> <span class="string">//</span> <span class="string">&#123;</span> <span class="attr">foo:</span> <span class="string">'obj'</span> <span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>方法接受三个参数，第一个参数为要操作的对象，第二个参数为添加的 key 值，第三个参数为属性描述符。</p><p>属性描述符可能的参数如下：</p><ul><li><p><code>configurable</code>：boolean，当且仅当该属性的 configurable 为 true 时，该属性描述符才能够被改变，同时该属性也能从对应的对象上被删除。默认为 false。</p></li><li><p><code>enumerable</code>：boolean，当且仅当该属性的enumerable为true时，该属性才能够出现在对象的枚举属性中。默认为 false。</p></li></ul><p>数据描述符同时具有以下可选键值：</p><ul><li><p><code>writable</code>：boolean，当且仅当该属性的writable为true时，value才能被赋值运算符改变。默认为 false。</p></li><li><p><code>value</code>：该属性对应的值。可以是任何有效的 JavaScript 值（数值，对象，函数等）。默认为 undefined。</p></li></ul><p>访问描述符同时具有以下可选键值：</p><ul><li><p><code>get</code>：一个给属性提供 getter 的方法，如果没有 getter 则为 undefined。当访问该属性时，该方法会被执行，方法执行时没有参数传入，但是会传入this对象（由于继承关系，这里的this并不一定是定义该属性的对象）。</p></li><li><p><code>set</code>：一个给属性提供 setter 的方法，如果没有 setter 则为 undefined。当属性值修改时，触发执行该方法。该方法将接受唯一参数，即该属性新的参数值。</p></li></ul><p>数据描述符和访问描述符不可同时存在。</p><p>考虑如下代码：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line">Object.defineProperty(obj, <span class="string">'foo'</span>, &#123;</span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    <span class="keyword">set</span>: <span class="function"><span class="keyword">function</span><span class="params">(val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>._foo_ = val;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">get</span>: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>._foo_</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">obj.foo = <span class="string">'obj'</span>;</span><br><span class="line">console.log(obj); <span class="comment">// &#123; foo: 'obj' &#125;</span></span><br></pre></td></tr></table></figure><p>这边注意的是需要设置名为一个属性，一般以<code>_</code>开始，表示内部元素，如果写成<code>this.foo = val</code>的话，那么会陷入死循环，因为赋值操作就是在调用<code>set</code>方法，方法内部还是在对该属性赋值，所以会陷入死循环，<code>get</code>同理。</p><h2 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h2><p>JS中的对象有一个特殊的名为[[Prototype]]的内置属性，其实就是对其他对象的引用。</p><p>考虑如下代码：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">var</span> obj = &#123;</span><br><span class="line">    <span class="selector-tag">a</span>: <span class="string">'1'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj<span class="selector-class">.a</span> <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>当获取<code>obj.a</code>的时候，首先会检测对象<code>obj</code>中是否具有<code>a</code>属性，如果有的话会触发该属性的[[GET]]方法，若没有的话，就需要用到原型链了，引擎会继续在原型链上继续查找是否具有<code>a</code>这个key值。</p><h3 id="原型链的尽头"><a href="#原型链的尽头" class="headerlink" title="原型链的尽头"></a>原型链的尽头</h3><p>所有普通的原型链最终都会指向<code>Object.prototype</code>，它包含了很多方法，比如说<code>toString, valueOf, hasOwnProperty</code></p><h3 id="属性设置和屏蔽"><a href="#属性设置和屏蔽" class="headerlink" title="属性设置和屏蔽"></a>属性设置和屏蔽</h3><p>这一点是大多数开发者经常会犯的错误，它是一个非常细小的操作，只是一个简单的赋值操作但是产生的结果往往会导致代码运行失败。</p><p>考虑如下代码：</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">    foo: 'obj'</span><br><span class="line">&#125;</span><br><span class="line">var <span class="built_in">bar</span> = Object.<span class="keyword">create</span>(obj);</span><br><span class="line">console.<span class="built_in">log</span>(<span class="built_in">bar</span>); <span class="comment">// &#123;&#125;</span></span><br><span class="line">console.<span class="built_in">log</span>(<span class="built_in">bar</span>.foo); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">bar</span>.foo = '<span class="built_in">bar</span>'</span><br><span class="line">console.<span class="built_in">log</span>(<span class="built_in">bar</span>); <span class="comment">// &#123; foo: 'bar' &#125;</span></span><br><span class="line">console.<span class="built_in">log</span>(Object.getPrototypeOf(<span class="built_in">bar</span>)); <span class="comment">// &#123; foo: 'obj' &#125;</span></span><br></pre></td></tr></table></figure><p>通过<code>Object.create</code>方法将<code>bar</code>的原型指向<code>obj</code>，但是我们现在的<code>bar</code>是一空对象，我们没有设置任何的 key 值，所以直接打印这个 bar 得到的是一个空对象。</p><p>当我们试图打印<code>bar.foo</code>�的时候，引擎首先会检查 bar 中是否具有这个 ke y找不到的话会继续查找其原型链，而原型链上是有一个名为 foo 的key值，他的 value 是 1， 所以打印1</p><p>当我们试图执行<code>bar.foo = &#39;bar&#39;</code>的时候，我们首先看一下打印出来的结果 以及打印 bar 原型链的结果，结果表明这个<code>foo</code>添加在了 bar 上，而不是我们预期的修改原型链上的 foo 属性。这个 foo 属性变成了 bar 对象上的一个私有属性，它屏蔽掉了原型链上的 foo 属性。</p><p>事实上，如果 foo 不存在于 bar 中，而是存在于原型链上时执行 <code>bar.foo = &#39;something&#39;</code> 赋值操作时，会发生三种情况：</p><ul><li><p>如果原型链上存在 foo 属性，并且没有被标记为只读(<code>writable: false</code>)，那么会直接在<code>bar</code>对象上添加一个<code>foo</code>属性</p></li><li><p>如果原型链上存在 foo 属性，并且被标记为只读，那么无法修改已有属性或者在 bar 上创建屏蔽属性，如果运行在严格模式下，代码会抛出一个异常，否则，这条赋值语句会被忽略</p></li><li><p>如果原型链上存在并且是一个 setter（访问描述符），那么会调用这个 setter 方法，foo 属性不会添加到 bar 上，也不会重新定义 foo 这个 setter 方法。</p></li></ul><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>考虑如下代码；</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line">Foo.prototype.constructor === Foo <span class="comment">// true</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> Foo();</span><br><span class="line">a.constructor === Foo <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>当我们执行 new 操作的时候，有一个步骤是原型关联，将<code>a.prototype</code>指向<code>Foo.prototype</code>，而<code>Foo.prototype</code>中有一个公有并且不可枚举的属性<code>constructor</code>，这个属性引用的是对象关联的函数，在这里也就是<code>Foo</code>函数。</p><p>那么Foo函数就是我们所说的<code>构造函数</code>，事实上也只是一个普通的函数，只不过首字母大写了而已，为什么大写呢，类名首字母大写，所以。。。大写。这显然不是将它称之为构造函数的理由，唯一的理由是，这个函数被 new 操作符调用。</p><p>实际上，new 操作会劫持所有的普通函数并且构造对象的形式来调用它。换句话说，在JS 中，对于“构造函数”最准确的解释是，所有带 new 的函数调用</p><p><strong>函数不是构造函数，但是当且仅当使用new时，函数调用会变成“构造函数调用”</strong></p><h3 id="数据共享"><a href="#数据共享" class="headerlink" title="数据共享"></a>数据共享</h3><p>之前说过 class 语法每次new 出来的实例都是一个新的实例，每个实例的数据并没有实现共享。</p><p>考虑如下代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">this</span>.count = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> c1 = <span class="keyword">new</span> C();</span><br><span class="line"><span class="keyword">var</span> c2 = <span class="keyword">new</span> C();</span><br><span class="line">c1.count++;</span><br><span class="line"><span class="built_in">console</span>.log(c1, c2); <span class="comment">// &#123; count: 1 &#125; &#123; count: 0 &#125;</span></span><br></pre></td></tr></table></figure><p>你会发现c1 c2都有一个独立的count，那么如果向要实现一个共享的 count 就必须使用原型链，代码修改为</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        C.prototype.count++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">C.prototype.count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> c1 = <span class="keyword">new</span> C();</span><br><span class="line"><span class="keyword">var</span> c2 = <span class="keyword">new</span> C();</span><br><span class="line"><span class="built_in">console</span>.log(c1.count, c2.count); <span class="comment">// 2 2</span></span><br></pre></td></tr></table></figure><p>但是这不是 class 的本意，class 就是不想把 prototype 暴露出来。所以我们可以使用<code>Object.create</code>我已经爱上了这个方法</p><figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="built_in">parent</span> = &#123;</span><br><span class="line">    <span class="attribute">count</span>: <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">    <span class="attribute">addCount</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">parent</span>.count++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child = <span class="built_in">Object</span>.create(<span class="built_in">parent</span>);</span><br><span class="line">child.addCount();</span><br><span class="line"><span class="keyword">var</span> child2 = <span class="built_in">Object</span>.create(<span class="built_in">parent</span>);</span><br><span class="line"><span class="built_in">console</span>.log(child, child2);</span><br></pre></td></tr></table></figure><p><img src="http://static.zybuluo.com/shenweizheng/i08y8ib6hxtgxddn4m3kjv1d/image_1e1154j1f5qu1m4ft2dglag8b9.png" alt="image_1e1154j1f5qu1m4ft2dglag8b9.png-24.5kB"></p><p>唯一的缺点是我们需要创建一个对象出来。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;读完《你不知道的js》已经过去很久了，正好顺着春招的气息，整理一波，复习一下JS基础，不得不说这本书刷新了我对JS得认知，看完红色的那本JS经典之后再来看这本你不知道的js简直就是爽爆了，如果能认认真真得啃完这两本书，理解深层次得js基础，那么js水准虽说距离阮一峰老师还有很大一截但至少能在中上游站稳脚跟。春招加油！！！努力进字节！！！&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="js" scheme="http://shenweini.cn/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>ReactNative 启动卡死在‘Loading dependency graph, done.’， ‘info Running jetifier to migrate libraries to AndroidX. You can disable it using &quot;--no-jetifier&quot; flag.’</title>
    <link href="http://shenweini.cn/2019/11/01/ReactNative%20%E5%90%AF%E5%8A%A8%E5%8D%A1%E6%AD%BB%E5%9C%A8%E2%80%98Loading%20dependency%20graph,%20done.%E2%80%99%EF%BC%8C%20%E2%80%98info%20Running%20jetifier%20to%20migrate%20libraries%20to%20AndroidX.%20You%20can%20disable%20it%20using%20%22--no-jetifier%22%20flag.%E2%80%99/"/>
    <id>http://shenweini.cn/2019/11/01/ReactNative 启动卡死在‘Loading dependency graph, done.’， ‘info Running jetifier to migrate libraries to AndroidX. You can disable it using &quot;--no-jetifier&quot; flag.’/</id>
    <published>2019-11-01T08:04:47.190Z</published>
    <updated>2019-11-01T08:04:47.190Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>最近在学习rn，各种坑，各种莫名其妙的报错，就比如今天，只想装一下<code>react-navigation</code>之后项目就跑不动了，执行<code>npm run start</code>卡死在<code>Loading dependency graph, done.</code>，执行<code>npm run android</code> 卡死在 <code>info Running jetifier to migrate libraries to AndroidX. You can disable it using &quot;--no-jetifier&quot; flag.</code>，搜了一堆解决方法无果之后，意外的发现了一个方法</p></blockquote><a id="more"></a><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>正常启动项目操作执行命令<code>npm run android</code>，发现卡死在了<code>info Running jetifier to migrate libraries to AndroidX. You can disable it using &quot;--no-jetifier</code>，不会像以前那样刷刷的给我跳。</p><p>执行 <code>npm run start</code> 或者  <code>react-native start</code>的时候卡死在了<code>Loading dependency graph, done.</code>，搜了一堆博客，说这个时候就应该是停在这，因为他没有链接到任何可以链接的设备也就是说没有找到模拟器。可是模拟器确实是开着的。</p><p>打开浏览器输入<code>http://localhost:8081/index.bundle</code>，这个时候会出来一段话，说什么什么没找到，好像是一个node_module模块没找到，这个时候打开刚刚运行<code>npm run start</code>的命令行，发现，<code>react-native</code>给了我们一个解决方法，一共四步。</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><ol><li>执行 <code>watchman watch-del-all</code></li><li>执行 <code>rm node_modules</code> 删掉依赖</li><li>重新装依赖，<strong>注意不要用<code>npm</code></strong>，一定要用<code>yarn install</code></li><li>执行 <code>rm /tmp/metro-*</code></li><li>执行 <code>npm run android</code> 完美解决。</li></ol><h2 id="不要用npm-install-个人感觉-rn-对-npm-不太友好，请使用yarn-安装你需要的模块"><a href="#不要用npm-install-个人感觉-rn-对-npm-不太友好，请使用yarn-安装你需要的模块" class="headerlink" title="不要用npm install 个人感觉 rn 对 npm 不太友好，请使用yarn 安装你需要的模块"></a>不要用<code>npm install</code> 个人感觉 <code>rn</code> 对 <code>npm</code> 不太友好，请使用<code>yarn</code> 安装你需要的模块</h2>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;最近在学习rn，各种坑，各种莫名其妙的报错，就比如今天，只想装一下&lt;code&gt;react-navigation&lt;/code&gt;之后项目就跑不动了，执行&lt;code&gt;npm run start&lt;/code&gt;卡死在&lt;code&gt;Loading dependency graph, done.&lt;/code&gt;，执行&lt;code&gt;npm run android&lt;/code&gt; 卡死在 &lt;code&gt;info Running jetifier to migrate libraries to AndroidX. You can disable it using &amp;quot;--no-jetifier&amp;quot; flag.&lt;/code&gt;，搜了一堆解决方法无果之后，意外的发现了一个方法&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="js" scheme="http://shenweini.cn/tags/js/"/>
    
      <category term="react-native" scheme="http://shenweini.cn/tags/react-native/"/>
    
      <category term="bug" scheme="http://shenweini.cn/tags/bug/"/>
    
  </entry>
  
  <entry>
    <title>History 和 Hash 两种路由的区别</title>
    <link href="http://shenweini.cn/2019/10/12/History%20%E5%92%8C%20Hash%20%E4%B8%A4%E7%A7%8D%E8%B7%AF%E7%94%B1%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://shenweini.cn/2019/10/12/History 和 Hash 两种路由的区别/</id>
    <published>2019-10-12T08:28:36.753Z</published>
    <updated>2019-10-12T08:28:36.753Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>今天遇到一个问题，写Vue项目的时候习惯性的使用 history 模式的路由，但是之前是自己起一个nginx做一个404重定向到index.html，但是发现直接使用hash模式的时候是不用做这些操作的，不会存在这种404的问题，究其原因还是因为history是每次刷新都需要返回html信息的。</p></blockquote><h2 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h2><p><code>hash</code>模式最直观的地方就在于会在路由上加一个<code>#</code>，形如<code>localhost:8080/#/console</code>，这样的。好吧这个路由看起来有点丑，他的特点在于<code>#</code>会存在与理由中，不会存在于HTTP请求中，每次更改路由都是直接修改<code>#</code>后面的东西。不会重新加载页面，所以使用这种模式的时候不会发生刷新也不需要返回html资源。</p><h2 id="History"><a href="#History" class="headerlink" title="History"></a>History</h2><p>这种模式就很有意思了，颜值高，直接就是 <code>localhost:8080/console</code>这样，特点就在于每次修改都需要返回html信息，所以要么后端做个404重定向到index.html要么前端自己配。</p><p>当然在兼容性封面上，</p><p><code>hash</code>模式可以兼容到ie8</p><p>参考别人的博客<br><a href="https://www.jianshu.com/p/9449d7605279" target="_blank" rel="noopener">History 和 Hash 的区别</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;今天遇到一个问题，写Vue项目的时候习惯性的使用 history 模式的路由，但是之前是自己起一个nginx做一个404重定向到index.html，但是发现直接使用hash模式的时候是不用做这些操作的，不会存在这种404的问题，究其原因还是因为h
      
    
    </summary>
    
    
      <category term="前端" scheme="http://shenweini.cn/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>React@15.6.2源码解析-挂载阶段完成---从 ReactDOM.render 到页面渲染(5) ReactCompositeComponent</title>
    <link href="http://shenweini.cn/2019/10/07/React@15.6.2%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-%E6%8C%82%E8%BD%BD%E9%98%B6%E6%AE%B5%E5%AE%8C%E6%88%90---%E4%BB%8E%20ReactDOM.render%20%E5%88%B0%E9%A1%B5%E9%9D%A2%E6%B8%B2%E6%9F%93(5)%20ReactCompositeComponent/"/>
    <id>http://shenweini.cn/2019/10/07/React@15.6.2源码解析-挂载阶段完成---从 ReactDOM.render 到页面渲染(5) ReactCompositeComponent/</id>
    <published>2019-10-07T03:42:46.518Z</published>
    <updated>2019-10-07T03:42:46.519Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>上回说到了<code>ReactMount._renderNewRootComponent</code>中调用了<code>ReactUpdates.batchedUpdates</code>方法，实质上调用的是<code>ReactDefaultBatchingStrategy.batchedUpdates</code>，然后就讲了一下<code>Transaction</code>。那么现在回到流程上来，继续往下走，现在Transaction也了解了，那么剩下的就好办了。</p></blockquote><a id="more"></a><p>回到流程来，我们来看一下<code>ReactDefaultBatchingStrategy.batchedUpdates</code>，首先先说一下参数</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">callback</span>: batchedMountComponentIntoNode // 是在ReactMount文件里</span><br><span class="line"></span><br><span class="line"><span class="attribute">a</span>: componentInstance // 执行instantiateComponent得到的结果，那么当前得到的实例是ReactCompositeComponent</span><br><span class="line"></span><br><span class="line"><span class="attribute">b</span>: container</span><br><span class="line"></span><br><span class="line"><span class="attribute">c</span>: shouleReuseMarkup // false</span><br><span class="line"></span><br><span class="line"><span class="attribute">d</span>: context // &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="attribute">e</span>: null</span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ReactDefaultBatchingStrategy.js</span></span><br><span class="line">batchedUpdates: <span class="function"><span class="keyword">function</span> <span class="params">(callback, a, b, c, d, e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> alreadyBatchingUpdates = ReactDefaultBatchingStrategy.isBatchingUpdates;</span><br><span class="line">    ReactDefaultBatchingStrategy.isBatchingUpdates = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">// The code is written this way to avoid extra allocations</span></span><br><span class="line">    <span class="keyword">if</span> (alreadyBatchingUpdates) &#123;</span><br><span class="line">      <span class="keyword">return</span> callback(a, b, c, d, e);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> transaction.perform(callback, <span class="keyword">null</span>, a, b, c, d, e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>首先拿到当前的<code>isBatchingUpdates</code>，那么肯定是 false 了啊</p><p>然后设置为 true</p><p>那么判断<code>isBatchingUpdates</code> 赋值的时候是 false，所以执行<code>transaction.perform</code>，那么这边的<code>transaction</code>指的是<code>ReactDefaultBatchingStrategyTransaction</code></p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ReactDefaultBatchingStrategy.js</span></span><br><span class="line"><span class="keyword">var</span> transaction = <span class="keyword">new</span> <span class="type">ReactDefaultBatchingStrategyTransaction</span>();</span><br></pre></td></tr></table></figure><p>那么这边执行<code>perform</code>，根据上一篇博客讲的，会首先执行所有wrapper的initialize方法。</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">perform: <span class="function"><span class="keyword">function</span> <span class="params">(method, scope, a, b, c, d, e, f)</span> </span>&#123;</span><br><span class="line">    !!<span class="keyword">this</span>.isInTransaction() ? <span class="comment">/**/</span></span><br><span class="line">    <span class="keyword">var</span> errorThrown;</span><br><span class="line">    <span class="keyword">var</span> ret;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>._isInTransaction = <span class="literal">true</span>;</span><br><span class="line">      errorThrown = <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">this</span>.initializeAll(<span class="number">0</span>);</span><br><span class="line">      ret = method.call(scope, a, b, c, d, e, f);</span><br><span class="line">      errorThrown = <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (errorThrown) &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.closeAll(<span class="number">0</span>);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (err) &#123;&#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">this</span>.closeAll(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>._isInTransaction = <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>但是<code>ReactDefaultBatchingStrategyTransaction</code>包裹的<code>wrapper</code>都是空函数。</p><p>那就到了这一步<code>ret = method.call(scope, a, b, c, d, e, f);</code>开始执行我们传递的这个方法。也就是执行<code>ReactMout</code>里的<code>batchedMountComponentIntoNode</code></p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ReactMount.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">batchedMountComponentIntoNode</span><span class="params">(componentInstance, container, shouldReuseMarkup, context)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> transaction = ReactUpdates.ReactReconcileTransaction.getPooled(</span><br><span class="line">  !shouldReuseMarkup &amp;&amp; ReactDOMFeatureFlags.useCreateElement);</span><br><span class="line">  transaction.perform(mountComponentIntoNode, <span class="literal">null</span>, componentInstance, container, transaction, shouldReuseMarkup, context);</span><br><span class="line">  ReactUpdates.ReactReconcileTransaction.release(transaction);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先从<code>ReactUpdates.ReactReconcileTransaction.getPooled(true)</code>拿到池子里的一个<code>ReactReconcileTransaction</code>实例。<code>ReactUpdates</code>和<code>getPooled</code>在之前的博客已经做过声明了，需要的同学可以自行查看。</p><p>然后执行<code>perform</code>方法，这边执行的是<code>ReactReconcileTransaction.perform</code>。</p><p>最后释放这个transaction</p><p>那么关键的地方在于这边又执行了一个Transction(ReactReconcileTransaction)。</p><p>一样的我们先记录一下传递的参数。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">callback:</span> mountComponentIntoNode <span class="comment">// ReactMount.js里的</span></span><br><span class="line"><span class="string">scope:</span> <span class="literal">null</span></span><br><span class="line"><span class="string">a:</span> componentInstance</span><br><span class="line"><span class="string">b:</span> container</span><br><span class="line"><span class="string">c:</span> transaction <span class="comment">// ReactReconcileTransaction</span></span><br><span class="line"><span class="string">d:</span> shouldReuseMarkup <span class="comment">// false</span></span><br><span class="line"><span class="string">e:</span> context <span class="comment">// &#123;&#125;</span></span><br></pre></td></tr></table></figure><p>那么先执行所有的<code>initialize</code></p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ReactReconcileTransaction.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> SELECTION_RESTORATION = &#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * @return &#123;Selection&#125; Selection information.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  initialize: ReactInputSelection.getSelectionInformation,</span><br><span class="line">  <span class="comment">/**/</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> EVENT_SUPPRESSION = &#123;</span><br><span class="line">    initialize: <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> currentlyEnabled = ReactBrowserEventEmitter.isEnabled();</span><br><span class="line">        ReactBrowserEventEmitter.setEnabled(<span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">return</span> currentlyEnabled;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ON_DOM_READY_QUEUEING = &#123;</span><br><span class="line">  initialize: <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.reactMountReady.reset();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>第三个wrapper的初始化执行<code>this.reactMountReady.reset()</code>实质上就是执行<code>callbackQueue.reset</code>，这个函数很简单就是将callbackQueue的<code>_callbacks</code> <code>_contexts</code> 都清空设为<code>null</code></p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CallbackQueue.prototype.reset = <span class="function"><span class="keyword">function</span> <span class="title">reset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>._callbacks = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">this</span>._contexts = <span class="literal">null</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>之后就是执行包装的这个函数<code>mountComponentIntoNode</code></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ReactMount.js</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mountComponentIntoNode</span>(<span class="params">wrapperInstance, container, transaction, shouldReuseMarkup, context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> markerName;</span><br><span class="line">  <span class="comment">// false</span></span><br><span class="line">  <span class="keyword">if</span> (ReactFeatureFlags.logTopLevelRenders) &#123;</span><br><span class="line">    <span class="keyword">var</span> wrappedElement = wrapperInstance._currentElement.props.child;</span><br><span class="line">    <span class="keyword">var</span> <span class="keyword">type</span> = wrappedElement.type;</span><br><span class="line">    markerName = <span class="string">'React mount: '</span> + (<span class="keyword">typeof</span> <span class="keyword">type</span> === <span class="string">'string'</span> ? <span class="keyword">type</span> : <span class="keyword">type</span>.displayName || <span class="keyword">type</span>.name);</span><br><span class="line">    <span class="built_in">console</span>.time(markerName);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> markup = ReactReconciler.mountComponent(wrapperInstance, transaction, <span class="literal">null</span>, ReactDOMContainerInfo(wrapperInstance, container), context, <span class="number">0</span> <span class="comment">/* parentDebugID */</span></span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">if</span> (markerName) &#123;</span><br><span class="line">    <span class="built_in">console</span>.timeEnd(markerName);</span><br><span class="line">  &#125;</span><br><span class="line">  wrapperInstance._renderedComponent._topLevelWrapper = wrapperInstance;</span><br><span class="line">  ReactMount._mountImageIntoNode(markup, container, wrapperInstance, shouldReuseMarkup, transaction);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判断<code>ReactFeatureFlags.logTopLevelRenders</code>，当前值为<code>false</code>，接下来执行<code>ReactReconciler.mountComponent</code>，这个方法也是一个重点。拿到<code>markup</code>后，会执行<code>ReactMount._mountImageIntoNode</code>，这个函数开始将dom挂载在container上。从这就开始有点挂载的样子了。</p><p>这边可以看到参数中调用了一个<code>ReactDOMContainerInfo(wrapperInstance, container)</code>，这个函数主要的作用就是封装了一下节点的信息，例如节点类型，节点的namespaceURI之类的。那么在函数调用时，首先是先调用这个函数拿到他的返回值之后作为形参然后调用原函数。</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// ReactDOMContainer<span class="literal">Inf</span>o.js</span><br><span class="line"></span><br><span class="line">function ReactDOMContainer<span class="literal">Inf</span>o(topLevelWrapper, <span class="keyword">node</span><span class="title">) &#123;</span></span><br><span class="line"><span class="title">  var</span> <span class="literal">inf</span>o = &#123;</span><br><span class="line">    _topLevelWrapper: topLevelWrapper,</span><br><span class="line">    _idCounter: <span class="number">1</span>,</span><br><span class="line">    _ownerDocument: <span class="keyword">node</span> <span class="title">? node</span>.nodeType === DOC_NODE_TYPE ? <span class="keyword">node</span> <span class="title">: node</span>.ownerDocument : null,</span><br><span class="line">    _node: <span class="keyword">node</span><span class="title">,</span></span><br><span class="line"><span class="title">    _tag</span>: <span class="keyword">node</span> <span class="title">? node</span>.nodeName.toLowerCase() : null,</span><br><span class="line">    _namespaceURI: <span class="keyword">node</span> <span class="title">? node</span>.namespaceURI : null</span><br><span class="line">  &#125;;</span><br><span class="line">  if (process.env.NODE_ENV !== 'production') &#123;</span><br><span class="line">    /**/</span><br><span class="line">  &#125;</span><br><span class="line">  return <span class="literal">inf</span>o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这个返回的<code>info</code>就是封装的节点信息对象。</p><p>先记录一下参数</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">internalInstance：wrapperInstance，这边的wrapperInstance还是上一个函数的形参，所以需要用流程图好好的记录一下参数的传递。</span></span><br><span class="line"></span><br><span class="line"><span class="attr">transaction:</span> <span class="string">ReconcileTransaction</span></span><br><span class="line"></span><br><span class="line"><span class="attr">hostParent:</span> <span class="literal">null</span></span><br><span class="line"></span><br><span class="line"><span class="attr">hostContainerInfo:</span> <span class="string">ReactDOMContainerInfo(wrapperInstance,</span> <span class="string">container)</span></span><br><span class="line"></span><br><span class="line"><span class="attr">context:</span> <span class="string">&#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">parentDebugId:</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ReactReconcile.js</span></span><br><span class="line"></span><br><span class="line">  mountComponent: <span class="function"><span class="keyword">function</span> (<span class="params">internalInstance, transaction, hostParent, hostContainerInfo, context, parentDebugID</span>) // 0 <span class="title">in</span> <span class="title">production</span> <span class="title">and</span> <span class="title">for</span> <span class="title">roots</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">      <span class="comment">/**/</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> markup = internalInstance.mountComponent(transaction, hostParent, hostContainerInfo, context, parentDebugID);</span><br><span class="line">    <span class="keyword">if</span> (internalInstance._currentElement &amp;&amp; internalInstance._currentElement.ref != <span class="literal">null</span>) &#123;</span><br><span class="line">      transaction.getReactMountReady().enqueue(attachRefs, internalInstance);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">      <span class="comment">/**/</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> markup;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><p>内部首先执行实例的<code>mountComponent</code>，当前传入的实例是<code>wrapperInstance</code>，那么这个实例是<code>ReactCompositeComponentWrapper</code>的一个实例。所以这边转到<code>ReactCompositeComponent.js</code>文件</p><h2 id="ReactCompositeComponent"><a href="#ReactCompositeComponent" class="headerlink" title="ReactCompositeComponent"></a>ReactCompositeComponent</h2><p>在讲解<code>ReactCompositeComponent.mountComponent</code>之前，先看一下React15中的生命周期。React16的生命周期和15是不一样的话，废除了几个换成了几个新的，这边就不涉及了。</p><p><img src="http://static.zybuluo.com/shenweizheng/7imzku3yusixaidpkf7xhvnn/image_1dmanchkt1h9sgvsl4bq3e2k69.png" alt="image_1dmanchkt1h9sgvsl4bq3e2k69.png-186kB"></p><p>那么这张图写的就很清楚了</p><p>在挂载阶段</p><ul><li>根组件的<code>constructor</code></li><li>根组件的<code>componentWillMount</code></li><li>根组件的<code>render</code><ul><li>子组件的<code>constructor</code></li><li>子组件的<code>componentWillMount</code></li><li>子组件的<code>render</code></li><li>子组件的<code>componentDidMount</code></li></ul></li><li>根组件的<code>componentDidMount</code></li></ul><p>更新阶段 同 挂在阶段</p><p>卸载阶段</p><ul><li>根组件的<code>componentWillUnMount</code></li><li>子组件的<code>componentWillUnMount</code></li><li>子组件销毁</li><li>根组件销毁</li></ul><p>那么按照我们的例子就是</p><ul><li><code>TopLevelWrapper</code>的<code>constructor</code></li><li><code>TopLevelWrapper</code>的<code>componentWillMount</code></li><li><code>TopLevelWrapper</code>的<code>render</code><ul><li><code>App</code>的<code>constructor</code></li><li><code>App</code>的<code>componentWillMount</code></li><li><code>App</code>的<code>render</code></li><li><code>App</code>的<code>componentDidMount</code></li></ul></li><li><code>TopLevelWrapper</code>的<code>componentDidMount</code></li></ul><h3 id="mountComponent"><a href="#mountComponent" class="headerlink" title="mountComponent"></a>mountComponent</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ReactCompositeComponent.js</span></span><br><span class="line"></span><br><span class="line">  mountComponent: <span class="function"><span class="keyword">function</span> (<span class="params">transaction, hostParent, hostContainerInfo, context</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> _this = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">this</span>._context = context;</span><br><span class="line">    <span class="keyword">this</span>._mountOrder = nextMountID++;</span><br><span class="line">    <span class="keyword">this</span>._hostParent = hostParent;</span><br><span class="line">    <span class="keyword">this</span>._hostContainerInfo = hostContainerInfo;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> publicProps = <span class="keyword">this</span>._currentElement.props;</span><br><span class="line">    <span class="keyword">var</span> publicContext = <span class="keyword">this</span>._processContext(context);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> Component = <span class="keyword">this</span>._currentElement.type;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> updateQueue = transaction.getUpdateQueue();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize the public class</span></span><br><span class="line">    <span class="keyword">var</span> doConstruct = shouldConstruct(Component);</span><br><span class="line">    <span class="keyword">var</span> inst = <span class="keyword">this</span>._constructComponent(doConstruct, publicProps, publicContext, updateQueue);</span><br><span class="line">    <span class="keyword">var</span> renderedElement;</span><br><span class="line">    <span class="comment">// Support functional components</span></span><br><span class="line">    <span class="keyword">if</span> (!doConstruct &amp;&amp; (inst == <span class="literal">null</span> || inst.render == <span class="literal">null</span>)) &#123;</span><br><span class="line">      renderedElement = inst;</span><br><span class="line">      warnIfInvalidElement(Component, renderedElement);</span><br><span class="line">      !(inst === <span class="literal">null</span> || inst === <span class="literal">false</span> || React.isValidElement(inst)) ? process.env.NODE_ENV !== <span class="string">'production'</span> ? <span class="comment">/**/</span></span><br><span class="line">      inst = <span class="keyword">new</span> StatelessComponent(Component);</span><br><span class="line">      <span class="keyword">this</span>._compositeType = CompositeTypes.StatelessFunctional;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (isPureComponent(Component)) &#123;</span><br><span class="line">        <span class="keyword">this</span>._compositeType = CompositeTypes.PureClass;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>._compositeType = CompositeTypes.ImpureClass;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">      <span class="comment">// This will throw later in _renderValidatedComponent, but add an early</span></span><br><span class="line">      <span class="comment">// warning now to help debugging</span></span><br><span class="line">      <span class="keyword">if</span> (inst.render == <span class="literal">null</span>) &#123;</span><br><span class="line">        process.env.NODE_ENV !== <span class="string">'production'</span> ? <span class="comment">/**/</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">var</span> propsMutated = inst.props !== publicProps;</span><br><span class="line">      <span class="keyword">var</span> componentName = Component.displayName || Component.name || <span class="string">'Component'</span>;</span><br><span class="line"></span><br><span class="line">      process.env.NODE_ENV !== <span class="string">'production'</span> ? <span class="comment">/**/</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// These should be set up in the constructor, but as a convenience for</span></span><br><span class="line">    <span class="comment">// simpler class abstractions, we set them up after the fact.</span></span><br><span class="line">    <span class="comment">// 这些应该在构造函数中设置，但是为了方便更简单的类抽象，我们在事后才设置它们。</span></span><br><span class="line">    inst.props = publicProps;</span><br><span class="line">    inst.context = publicContext;</span><br><span class="line">    inst.refs = emptyObject;</span><br><span class="line">    inst.updater = updateQueue;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>._instance = inst;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Store a reference from the instance back to the internal representation</span></span><br><span class="line">    ReactInstanceMap.set(inst, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">      <span class="comment">/**/</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> initialState = inst.state;</span><br><span class="line">    <span class="keyword">if</span> (initialState === <span class="literal">undefined</span>) &#123;</span><br><span class="line">      inst.state = initialState = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    !(<span class="keyword">typeof</span> initialState === <span class="string">'object'</span> &amp;&amp; !<span class="built_in">Array</span>.isArray(initialState)) ? <span class="comment">/**/</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>._pendingStateQueue = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">this</span>._pendingReplaceState = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">this</span>._pendingForceUpdate = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">var</span> markup;</span><br><span class="line">    <span class="keyword">if</span> (inst.unstable_handleError) &#123;</span><br><span class="line">      markup = <span class="keyword">this</span>.performInitialMountWithErrorHandling(renderedElement, hostParent, hostContainerInfo, transaction, context);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      markup = <span class="keyword">this</span>.performInitialMount(renderedElement, hostParent, hostContainerInfo, transaction, context);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (inst.componentDidMount) &#123;</span><br><span class="line">      <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">        transaction.getReactMountReady().enqueue(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">          measureLifeCyclePerf(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> inst.componentDidMount();</span><br><span class="line">          &#125;, _this._debugID, <span class="string">'componentDidMount'</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        transaction.getReactMountReady().enqueue(inst.componentDidMount, inst);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> markup;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><p>代码有点长，那么来一块一块的看。</p><p>那么首先是给当前实例添加一些属性</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>._context = context;</span><br><span class="line"><span class="keyword">this</span>._mountOrder = nextMountID++;</span><br><span class="line"><span class="keyword">this</span>._hostParent = hostParent;</span><br><span class="line"><span class="keyword">this</span>._hostContainerInfo = hostContainerInfo;</span><br></pre></td></tr></table></figure><p>这边呢有一个<code>nextMountID</code>变量，这是外部闭包的一个变量，用于记录着挂载的顺序的。</p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * An incrementing ID assigned <span class="keyword">to</span> <span class="keyword">each</span> <span class="keyword">when</span> it <span class="keyword">is</span> mounted. This <span class="keyword">is</span></span><br><span class="line"> * used <span class="keyword">to</span> enforce the <span class="keyword">order</span> <span class="keyword">in</span> which `ReactUpdates` updates dirty components.</span><br><span class="line"> * 这用于强制执行“ReactUpdates”更新脏组件的顺序。</span><br><span class="line"> * @<span class="keyword">private</span></span><br><span class="line"> */</span><br><span class="line">var nextMountID = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>再往下</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">var updateQueue</span> = transaction.getUpdateQueue();</span><br></pre></td></tr></table></figure><p>这边获取了当前事务的<code>ReactUpdateQueue</code>实例。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Initialize the public class</span></span><br><span class="line">    <span class="keyword">var</span> Component = <span class="keyword">this</span>._currentElement.type;</span><br><span class="line">    <span class="keyword">var</span> doConstruct = shouldConstruct(Component); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>这边调用<code>shouldConstruct</code>函数对<code>this._currentElement.type</code>做一个判断，判断原型链中是否是<code>isReactComponent</code>属性。而当前的<code>_currentElement</code>是一开始的<code>nextWrapperElement</code>他是对<code>TopLevelWrapper</code>执行<code>ReactElement</code>方法得到的ReactElement。那么当前的<code>type</code>就是这边的<code>TopLevelWrapper</code>。那么找<code>ReactMount.js</code>发现，<code>TopLevelWrapper</code>的原型链上是有<code>isReactComponent</code>属性的。</p><h3 id="shouldConstruct"><a href="#shouldConstruct" class="headerlink" title="shouldConstruct"></a>shouldConstruct</h3><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ReactCompositeComponent.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shouldConstruct</span><span class="params">(Component)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> !!(Component.prototype &amp;&amp; Component.prototype.isReactComponent);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ReactMount.js</span></span><br><span class="line"><span class="keyword">var</span> TopLevelWrapper = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.rootID = topLevelRootCounter++;</span><br><span class="line">&#125;;</span><br><span class="line">TopLevelWrapper.prototype.isReactComponent = &#123;&#125;;</span><br></pre></td></tr></table></figure><p>接下来执行<code>this._constructComponent</code>方法。传递参数为</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">doConstruct</span>: true</span><br><span class="line"></span><br><span class="line"><span class="attribute">publicProps</span>: this._currentElement.props // 当前为nextWrapperElement的props，存储的是type为App构造函数的ReactElement</span><br><span class="line"></span><br><span class="line"><span class="attribute">publicContext</span>: this._processContext(context) // &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="attribute">updateQueue</span>: transaction.getUpdateQueue() // ReactUpdateQueue实例</span><br></pre></td></tr></table></figure><h3 id="constructComponent"><a href="#constructComponent" class="headerlink" title="_constructComponent"></a>_constructComponent</h3><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">_constructComponent: <span class="function"><span class="keyword">function</span> <span class="params">(doConstruct, publicProps, publicContext, updateQueue)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; !doConstruct) &#123;</span><br><span class="line">    <span class="comment">/**/</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>._constructComponentWithoutOwner(doConstruct, publicProps, publicContext, updateQueue);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>本质上是执行的<code>this._constructComponentWithoutOwner</code>，参数还是原封不动的传递过去</p><h3 id="constructComponentWithoutOwner"><a href="#constructComponentWithoutOwner" class="headerlink" title="_constructComponentWithoutOwner"></a>_constructComponentWithoutOwner</h3><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">_constructComponentWithoutOwner: <span class="function"><span class="keyword">function</span> <span class="params">(doConstruct, publicProps, publicContext, updateQueue)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> Component = <span class="keyword">this</span>._currentElement.type;</span><br><span class="line">  <span class="keyword">if</span> (doConstruct) &#123;</span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">      <span class="comment">/**/</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Component(publicProps, publicContext, updateQueue);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// This can still be an instance in case of factory components</span></span><br><span class="line">  <span class="comment">// but we'll count this as time spent rendering as the more common case.</span></span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">    <span class="comment">/**/</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Component(publicProps, publicContext, updateQueue);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>如果这边的<code>doConstruct</code>是<code>true</code>的话，那么就会返回一个<code>this._currentElement.type</code>的实例，否则的话则会调用<code>this._currentElement.type</code>返回其返回值。这边笼统的说就是要实例化一个<code>this._currentElement.type</code>存储的值。</p><p>那么当前<code>doConstruct</code>是为<code>true</code>的，也就是说会返回一个<code>TopLevelWrapper</code>实例。</p><p>那么回到<code>mountComponent方法</code>中继续往下走</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> inst = <span class="keyword">this</span>._constructComponent(doConstruct, publicProps, publicContext, updateQueue);</span><br></pre></td></tr></table></figure><p>这边的<code>inst</code>现在就是<code>TopLevelWrapper</code>实例了。继续往下走</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Support functional components</span></span><br><span class="line"><span class="keyword">if</span> (!doConstruct &amp;&amp; (inst == <span class="literal">null</span> || inst.render == <span class="literal">null</span>)) &#123;</span><br><span class="line">  renderedElement = inst;</span><br><span class="line">  warnIfInvalidElement(Component, renderedElement);</span><br><span class="line">  !(inst === <span class="literal">null</span> || inst === <span class="literal">false</span> || React.isValidElement(inst)) ? process.env.NODE_ENV !== <span class="string">'production'</span> ? <span class="comment">/**/</span></span><br><span class="line">  inst = <span class="keyword">new</span> <span class="type">StatelessComponent</span>(Component);</span><br><span class="line">  <span class="built_in">this</span>._compositeType = CompositeTypes.StatelessFunctional;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (isPureComponent(Component)) &#123;</span><br><span class="line">    <span class="built_in">this</span>._compositeType = CompositeTypes.PureClass; <span class="comment">// 1</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>._compositeType = CompositeTypes.ImpureClass; <span class="comment">// 0</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一个<code>if</code>根据注释猜测是函数式组件才会调用。那么当前的情况是进入到了<code>else</code>内部。主要操作在于给当前实例添加<code>_compositeType</code>对象。值是根据<code>isPureComponent</code>函数来决定的。</p><p>这边的<code>CompositeTypes</code>是外部闭包的一个对象，其实就是一个枚举。</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var CompositeTypes = &#123;</span><br><span class="line"><span class="symbol">  ImpureClass:</span> <span class="number">0</span>, <span class="comment">// 非 PureClass</span></span><br><span class="line"><span class="symbol">  PureClass:</span> <span class="number">1</span>, <span class="comment">// PureClass</span></span><br><span class="line"><span class="symbol">  StatelessFunctional:</span> <span class="number">2</span> <span class="comment">// 无状态的函数式组件</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>那么总的来说就是如果我们这个<code>Component</code>是<code>PureClass</code>的话，<code>_compositeType</code>对应<code>CompositeTypes.ImpureClass</code>，否则的话就是<code>CompositeTypes.PureClass</code>。在第一篇博客讲解React的全局API时，对于<code>PureComponent</code>是有一个特殊的标志的<code>isPureReactComponent</code>。</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ReactCompositeComponent.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isPureComponent</span><span class="params">(Component)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> !!(Component.prototype &amp;&amp; Component.prototype.isPureReactComponent);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// react/lib/ReactBaseClass.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ReactPureComponent</span><span class="params">(props, context, updater)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Duplicated from ReactComponent.</span></span><br><span class="line">  <span class="keyword">this</span>.props = props;</span><br><span class="line">  <span class="keyword">this</span>.context = context;</span><br><span class="line">  <span class="keyword">this</span>.refs = emptyObject;</span><br><span class="line">  <span class="keyword">this</span>.updater = updater || ReactNoopUpdateQueue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactPureComponent.prototype.isPureReactComponent = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><p>那么接着往下</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// These should be <span class="keyword">set</span> up <span class="keyword">in</span> the <span class="keyword">constructor</span>, but <span class="keyword">as</span> a convenience <span class="keyword">for</span></span><br><span class="line">// simpler <span class="keyword">class</span> abstractions, we <span class="keyword">set</span> them up <span class="keyword">after</span> the fact.</span><br><span class="line">// 这些应该在构造函数中设置，但是为了方便更简单的类抽象，我们在事后才设置它们。</span><br><span class="line">inst.props = publicProps;</span><br><span class="line">inst.context = publicContext;</span><br><span class="line">inst.refs = emptyObject;</span><br><span class="line">inst.updater = updateQueue;</span><br></pre></td></tr></table></figure><p>给<code>inst</code>附加属性，官方注释的解释是这些属性本应在构造函数中设置但是为了更简单的类抽象，才在这边进行附加。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>._instance = inst;</span><br></pre></td></tr></table></figure><p>给当前实例附加<code>_instance</code>属性，值为<code>inst</code></p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// Store a reference from the<span class="built_in"> instance </span>back to the internal representation</span><br><span class="line">ReactInstanceMap.set(inst, this);</span><br></pre></td></tr></table></figure><p>将当前的<code>inst</code>存储起来。<code>ReactInstanceMap</code>对象做的事情就是一件事，维护来自面向公共的有状态实例(键)和内部表示(值)的映射。这允许公共方法接受面向用户的实例作为参数，并将它们映射回内部方法。</p><p>说白了给key值附加一个属性<code>_reactInternalInstance</code>，值为传入的value。</p><p>那么这边就是给<code>inst</code>附加一个<code>_reactInternalInstance</code>属性，值为<code>this</code>也就是当前<code>ReactCompositeComponent</code>实例。</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var initialState = inst.<span class="keyword">state</span>;</span><br><span class="line">if (initialState === undefined) &#123;</span><br><span class="line">  inst.<span class="keyword">state</span> = initialState = null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取初始的<code>state</code>，不存在的话初始化为<code>null</code></p><p>走这开始就可以把生命周期给连上了。这一步对应着我们在构造函数里写的<code>this.state = {}</code>，例子如下</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    constructor(props) &#123;</span><br><span class="line">        <span class="keyword">super</span>(props);</span><br><span class="line">        <span class="comment">// 对应着这里</span></span><br><span class="line">        <span class="keyword">this</span>.state = &#123;</span><br><span class="line">            name: <span class="symbol">'Hello</span> <span class="type">World</span>'</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是我们当前的<code>inst</code>是<code>TopLevelWrapper</code>显然没有这么个东西。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>._pendingStateQueue = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">this</span>._pendingReplaceState = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">this</span>._pendingForceUpdate = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><p>附加几个属性，这几个属性用在更新的时候。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> markup;</span><br><span class="line"><span class="keyword">if</span> (inst.unstable_handleError) &#123;</span><br><span class="line">  markup = <span class="keyword">this</span>.performInitialMountWithErrorHandling(renderedElement, hostParent, hostContainerInfo, transaction, context);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  markup = <span class="keyword">this</span>.performInitialMount(renderedElement, hostParent, hostContainerInfo, transaction, context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这边对<code>inst.unstable_handleError</code>判断之后执行初始化的挂载，那么这边显然没有这个属性。这个<code>performInitialMount</code>方法就对应着我们的<code>componentWillMount</code>生命周期。</p><h3 id="performInitialMount"><a href="#performInitialMount" class="headerlink" title="performInitialMount"></a>performInitialMount</h3><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">performInitialMount: <span class="function"><span class="keyword">function</span> <span class="params">(renderedElement, hostParent, hostContainerInfo, transaction, context)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> inst = <span class="keyword">this</span>._instance;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> debugID = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">    debugID = <span class="keyword">this</span>._debugID;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (inst.componentWillMount) &#123;</span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">      <span class="comment">/**/</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      inst.componentWillMount();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// When mounting, calls to `setState` by `componentWillMount` will set</span></span><br><span class="line">    <span class="comment">// `this._pendingStateQueue` without triggering a re-render.</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>._pendingStateQueue) &#123;</span><br><span class="line">      inst.state = <span class="keyword">this</span>._processPendingState(inst.props, inst.context);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// If not a stateless component, we now render</span></span><br><span class="line">  <span class="keyword">if</span> (renderedElement === <span class="literal">undefined</span>) &#123;</span><br><span class="line">    renderedElement = <span class="keyword">this</span>._renderValidatedComponent();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> nodeType = ReactNodeTypes.getType(renderedElement);</span><br><span class="line">  <span class="keyword">this</span>._renderedNodeType = nodeType;</span><br><span class="line">  <span class="keyword">var</span> child = <span class="keyword">this</span>._instantiateReactComponent(renderedElement, nodeType !== ReactNodeTypes.EMPTY <span class="comment">/* shouldHaveDebugID */</span></span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">this</span>._renderedComponent = child;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> markup = ReactReconciler.mountComponent(child, transaction, hostParent, hostContainerInfo, <span class="keyword">this</span>._processChildContext(context), debugID);</span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">    <span class="comment">/**/</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> markup;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>那么上面也提到了这个函数相当于<code>componentWillMount</code>，执行初始化的挂载。</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (inst.componentWillMount) &#123;</span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">    measureLifeCyclePerf(<span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> inst.componentWillMount();</span><br><span class="line">    &#125;, debugID, <span class="string">'componentWillMount'</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    inst.componentWillMount();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// When mounting, calls to `setState` by `componentWillMount` will set</span></span><br><span class="line">  <span class="comment">// `this._pendingStateQueue` without triggering a re-render.</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>._pendingStateQueue) &#123;</span><br><span class="line">    inst.state = <span class="keyword">this</span>._processPendingState(inst.props, inst.context);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么这边判断<code>componentWillMount</code>是否存在，存在的话就执行，在执行期间执行的<code>setState</code>将会加入到<code>_pendingStateQueue</code>，这边需要注意的是，在<code>componentWillMount</code>期间执行的<code>setState</code>并不会引发重新的<code>render</code>。</p><p>执行完之后判断<code>_pendingStateQueue</code>是否存在，也就是判断在执行期间是否调用了<code>setState</code>，如果有的话会将这个队列中的state进行比较，得到一个最终的state。</p><h3 id="processPendingState"><a href="#processPendingState" class="headerlink" title="_processPendingState"></a>_processPendingState</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">_processPendingState: function (props, context) &#123;</span><br><span class="line">  <span class="keyword">var</span> inst = <span class="keyword">this</span>._instance;</span><br><span class="line">  <span class="keyword">var</span> queue = <span class="keyword">this</span>._pendingStateQueue;</span><br><span class="line">  <span class="keyword">var</span> replace = <span class="keyword">this</span>._pendingReplaceState;</span><br><span class="line">  <span class="keyword">this</span>._pendingReplaceState = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">this</span>._pendingStateQueue = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!queue) &#123;</span><br><span class="line">    <span class="keyword">return</span> inst.state;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (replace &amp;&amp; queue.length === <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> queue[<span class="number">0</span>];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> nextState = _assign(&#123;&#125;, replace ? queue[<span class="number">0</span>] : inst.state);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = replace ? <span class="number">1</span> : <span class="number">0</span>; i &lt; queue.length; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> partial = queue[i];</span><br><span class="line">    _assign(nextState, typeof partial === <span class="string">'function'</span> ? partial.call(inst, nextState, props, context) : partial);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> nextState;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过<code>Object.assign</code>一个一个的覆盖前者得到一个最终的state。得到最终的一个state之后赋值给<code>inst.state</code>，之后就是判断传入的这个<code>renderedElement</code>是否是<code>undefined</code>了。</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// If not a stateless component, we now render</span></span><br><span class="line"><span class="keyword">if</span> (renderedElement === <span class="literal">undefined</span>) &#123;</span><br><span class="line">  renderedElement = <span class="keyword">this</span>._renderValidatedComponent();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据这个英文注释了解到如果是一个无状态组件组件，那么就渲染他，突然发现我们的<code>TopLevelWrapper</code>就是一个无状态的组件，那么当前就是<code>undefined</code>，ok，渲染他。</p><h3 id="renderValidatedComponent"><a href="#renderValidatedComponent" class="headerlink" title="_renderValidatedComponent"></a>_renderValidatedComponent</h3><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">_renderValidatedComponent: <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> renderedElement;</span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> || <span class="keyword">this</span>._compositeType !== CompositeTypes.StatelessFunctional) &#123;</span><br><span class="line">    ReactCurrentOwner.current = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      renderedElement = <span class="keyword">this</span>._renderValidatedComponentWithoutOwnerOrContext();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      ReactCurrentOwner.current = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    renderedElement = <span class="keyword">this</span>._renderValidatedComponentWithoutOwnerOrContext();</span><br><span class="line">  &#125;</span><br><span class="line">  !(</span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> An `isValidNode` function would probably be more appropriate</span></span><br><span class="line">  renderedElement === <span class="literal">null</span> || renderedElement === <span class="literal">false</span> || React.isValidElement(renderedElement)) ? process.env.NODE_ENV !== <span class="string">'production'</span> ? <span class="comment">/**/</span></span><br><span class="line">  <span class="keyword">return</span> renderedElement;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>那么实际上就是执行<code>_renderValidatedComponentWithoutOwnerOrContext</code>函数并将返回值返回出来。</p><h3 id="renderValidatedComponentWithoutOwnerOrContext"><a href="#renderValidatedComponentWithoutOwnerOrContext" class="headerlink" title="_renderValidatedComponentWithoutOwnerOrContext"></a>_renderValidatedComponentWithoutOwnerOrContext</h3><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">_renderValidatedComponentWithoutOwnerOrContext: <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> inst = <span class="keyword">this</span>._instance;</span><br><span class="line">  <span class="keyword">var</span> renderedElement;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">    renderedElement = measureLifeCyclePerf(<span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> inst.render();</span><br><span class="line">    &#125;, <span class="keyword">this</span>._debugID, <span class="string">'render'</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    renderedElement = inst.render();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">    <span class="comment">// We allow auto-mocks to proceed as if they're returning null.</span></span><br><span class="line">    <span class="keyword">if</span> (renderedElement === <span class="literal">undefined</span> &amp;&amp; inst.render._isMockFunction) &#123;</span><br><span class="line">      <span class="comment">// This is probably bad practice. Consider warning here and</span></span><br><span class="line">      <span class="comment">// deprecating this convenience.</span></span><br><span class="line">      renderedElement = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> renderedElement;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>这个就简单了，直接执行<code>this._instance.render</code>，那么当前的<code>_instance</code>是<code>TopLevelWrapper</code>实例，他的render方法就是返回他的<code>props.child</code></p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ReactMount.js</span></span><br><span class="line">TopLevelWrapper.prototype.render = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.props.child;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>那么这边的<code>child</code>就是我们的<code>React.createElement(App)</code>的结果。将返回值依次返回那么就回到了<code>performInitialMount</code>函数。</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ReactCompositeComponent.performInitialMount</span></span><br><span class="line">    <span class="comment">// If not a stateless component, we now render</span></span><br><span class="line">    <span class="keyword">if</span> (renderedElement === <span class="literal">undefined</span>) &#123;</span><br><span class="line">      renderedElement = <span class="keyword">this</span>._renderValidatedComponent();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>也就是回到了这，如果有童鞋打断点的话，那么可以看</p><p><img src="http://static.zybuluo.com/shenweizheng/gz7716se4p4a7151nqgh69q2/image_1dmas88kcrvr73v5r116c4mskm.png" alt="image_1dmas88kcrvr73v5r116c4mskm.png-9kB"></p><p>Chrome 里面的<code>Call Stack</code>看整个流程的函数调用栈。</p><p>那么继续往下走</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> nodeType = ReactNodeTypes.getType(renderedElement);</span><br><span class="line"><span class="keyword">this</span>._renderedNodeType = nodeType;</span><br></pre></td></tr></table></figure><p>这边给当前实例附加一个<code>_renderedNodeType</code>属性，调用了一个<code>ReactNodeTypes.getType()</code>方法，</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// ReactNodeType.js</span><br><span class="line">var ReactNodeTypes = &#123;</span><br><span class="line">  HOST: <span class="number">0</span>,</span><br><span class="line">  COMPOSITE: <span class="number">1</span>,</span><br><span class="line">  EMPTY: <span class="number">2</span>,</span><br><span class="line"></span><br><span class="line">  getType: function (<span class="keyword">node</span><span class="title">) &#123;</span></span><br><span class="line"><span class="title">    if</span> (<span class="keyword">node</span> <span class="title">=== null</span> || <span class="keyword">node</span> <span class="title">=== false</span>) &#123;</span><br><span class="line">      return ReactNodeTypes.EMPTY;</span><br><span class="line">    &#125; else if (React.isValidElement(<span class="keyword">node</span><span class="title">)) &#123;</span></span><br><span class="line"><span class="title">      if</span> (typeof <span class="keyword">node</span>.<span class="title">type</span> === 'function') &#123;</span><br><span class="line">        return ReactNodeTypes.COMPOSITE;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        return ReactNodeTypes.HOST;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    !<span class="literal">false</span> ? process.env.NODE_ENV !== 'production' ? /**/</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>根据<code>node</code>型和<code>node.type</code>进行判断，主要目的就是判断当前的<code>node</code>是哪一种类型的组件，这个操作在<code>instantiateReactComponent</code>中有类似的操作。继续往下</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> child = <span class="keyword">this</span>._instantiateReactComponent(renderedElement, nodeType !== ReactNodeTypes.EMPTY);</span><br></pre></td></tr></table></figure><p>调用<code>_instantiateReactComponent</code>函数，该函数是在实例化当前实例时进行赋值的也就是<code>instantiateReactComponent.js</code>里面的方法，重要目的就是创建一个ReactComponent实例。</p><p>具体的操作就不去看了之前已经介绍过，那么我们需要注意的是这边传入的<code>renderedElement</code>参数是我们的类型为<code>App</code>的<code>ReactElement</code>，那么根据之前的介绍，这个方法会返回一个<code>ReactCompositeComponent</code>的实例。</p><p>那么继续往下</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>._renderedComponent = child;</span><br></pre></td></tr></table></figure><p>附加<code>_renderedComponent</code>属性值为上一步得到的<code>child</code></p><p>继续往下</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> markup = ReactReconciler.mountComponent(child, transaction, hostParent, hostContainerInfo, <span class="keyword">this</span>._processChildContext(context), debugID);</span><br></pre></td></tr></table></figure><p>执行<code>ReactReconcile.mountComponent</code>，那么又回到了<code>ReactCompositeComponent.mountComponent</code>函数，只不过<code>this</code>指向了这个<code>child</code></p><p>那么我们来看一下当前的调用栈</p><p><img src="http://static.zybuluo.com/shenweizheng/0ieca3y5vwwl3xhp7jbmqq4x/image_1dmatnili77t1lrm1o5c4sskmo1g.png" alt="image_1dmatnili77t1lrm1o5c4sskmo1g.png-84.3kB"></p><p>再来看一下<code>this</code>指向</p><p><img src="http://static.zybuluo.com/shenweizheng/g1gbtrpky3xx1jwxi75flnaf/image_1dmatp5rn816s3f1cka14hp1og91t.png" alt="image_1dmatp5rn816s3f1cka14hp1og91t.png-58.5kB"></p><p>可以看到<code>this._currentElement</code>是type为App的ReactElement。</p><p>那么还是一样的附加几个属性，这边的<code>_mountOrder</code>就是<code>2</code>了</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>._mountOrder = nextMountID++;</span><br></pre></td></tr></table></figure><p>再往下经过一系列平淡无奇的操作之后到了这</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> inst = <span class="keyword">this</span>._constructComponent(doConstruct, publicProps, publicContext, updateQueue);</span><br></pre></td></tr></table></figure><p>这边需要注意的是实例化App时，传入了这个<code>updateQueue</code>，而App的构造函数内部调用了<code>super(props)</code>调用了一次父类的构造函数也就是<code>React.Component</code>的构造函数，</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ReactBaseClasses.js</span></span><br><span class="line">function ReactComponent(props, context, updater) &#123;</span><br><span class="line">  <span class="keyword">this</span>.props = props;</span><br><span class="line">  <span class="keyword">this</span>.context = context;</span><br><span class="line">  <span class="keyword">this</span>.refs = emptyObject;</span><br><span class="line">  <span class="comment">// We initialize the default updater but the real one gets injected by the</span></span><br><span class="line">  <span class="comment">// renderer.</span></span><br><span class="line">  <span class="keyword">this</span>.updater = updater || ReactNoopUpdateQueue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么这边只传递了<code>props</code>，其余两个变量都是<code>undefined</code>，那么重点在这</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.updater = updater || ReactNoopUpdateQueue;</span><br></pre></td></tr></table></figure><p>这边的<code>this.updater</code>赋值的是<code>ReactNoopUpdateQueue</code>对象。</p><p>那么我们来看一下这个App的实例有哪些属性。</p><p><img src="http://static.zybuluo.com/shenweizheng/enkhkm9q3erqcrffn6rubjwj/image_1dmbb0tsm1pkc187u9nv19ut16df2n.png" alt="image_1dmbb0tsm1pkc187u9nv19ut16df2n.png-111.4kB"></p><p>原型链上的几个方法是通过babel打进去的。</p><p>在往下又经历了一系列的操作到了这</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inst.props </span>= publicProps<span class="comment">;</span></span><br><span class="line"><span class="keyword">inst.context </span>= publicContext<span class="comment">;</span></span><br><span class="line"><span class="keyword">inst.refs </span>= emptyObject<span class="comment">;</span></span><br><span class="line"><span class="keyword">inst.updater </span>= updateQueue<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>重点在于最后一句，对<code>inst.updater</code>重新赋值了，一开始实例化App的时候用的是缺省的<code>ReactNoopUpdateQueue</code>，那么这边是重新改成<code>ReactUpdateQueue</code>，我估计是防止有人在执行<code>super()</code>的时候，传了不止<code>props</code>一个参数，这边做一个重新赋值保证<code>updater</code>一定是<code>ReactUpdateQueue</code>.</p><p>再次经历一系列的操作之后进入了<code>performInitialMount</code>函数，开始执行<code>componentWillMount</code>方法，但是我们的<code>componentWillMount</code>方法里调用了<code>setState</code>，我们来看一下React对<code>setState</code>的处理。</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ReactComponent.prototype.setState = <span class="function"><span class="keyword">function</span> <span class="params">(partialState, callback)</span> </span>&#123;</span><br><span class="line">  !(<span class="keyword">typeof</span> partialState === <span class="string">'object'</span> || <span class="keyword">typeof</span> partialState === <span class="string">'function'</span> || partialState == <span class="literal">null</span>) ? <span class="comment">/**/</span></span><br><span class="line">  <span class="keyword">this</span>.updater.enqueueSetState(<span class="keyword">this</span>, partialState);</span><br><span class="line">  <span class="keyword">if</span> (callback) &#123;</span><br><span class="line">    <span class="keyword">this</span>.updater.enqueueCallback(<span class="keyword">this</span>, callback, <span class="string">'setState'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>调用<code>this.updater.enqueueSetState</code>方法，那么我们这边的<code>updater</code>上面也说了是一个<code>ReactUpdateQueue</code>，来看一下这个对象里的方法。</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ReactUpdateQueue.js</span></span><br><span class="line">  enqueueSetState: <span class="function"><span class="keyword">function</span> <span class="params">(publicInstance, partialState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">      <span class="comment">/**/</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> internalInstance = getInternalInstanceReadyForUpdate(publicInstance, <span class="string">'setState'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!internalInstance) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> queue = internalInstance._pendingStateQueue || (internalInstance._pendingStateQueue = []);</span><br><span class="line">    queue.push(partialState);</span><br><span class="line"></span><br><span class="line">    enqueueUpdate(internalInstance);</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><p>那么这边调用<code>getInternalInstanceReadyForUpdate</code>方法从<code>ReactInstanceMap</code>�中查找对应的key值，主要就是查找对应的实例是否存在，不存在的话就报错退出。</p><p>之后就是将新的state加入到实例的<code>_pendingStateQueue</code>里面，上文也说了执行完<code>componentWillMount</code>之后会检查<code>_pendingStateQueue</code>得到最新的state之后对实例的state进行赋值。</p><p>之后调用<code>enqueueUpdate</code>方法</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ReactUpdateQueue.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">enqueueUpdate</span><span class="params">(internalInstance)</span> </span>&#123;</span><br><span class="line">  ReactUpdates.enqueueUpdate(internalInstance);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上就是执行<code>ReactUpdates.enqueueUpdate</code>，ok，我们跳到这里看一下发生了什么。</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">enqueueUpdate</span><span class="params">(component)</span> </span>&#123;</span><br><span class="line">  ensureInjected();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Various parts of our code (such as ReactCompositeComponent's</span></span><br><span class="line">  <span class="comment">// _renderValidatedComponent) assume that calls to render aren't nested;</span></span><br><span class="line">  <span class="comment">// verify that that's the case. (This is called by each top-level update</span></span><br><span class="line">  <span class="comment">// function, like setState, forceUpdate, etc.; creation and</span></span><br><span class="line">  <span class="comment">// destruction of top-level components is guarded in ReactMount.)</span></span><br><span class="line">  <span class="comment">// 我们代码的各个部分(比如ReactCompositeComponent的_renderValidatedComponent)</span></span><br><span class="line">  <span class="comment">// 假设render调用不是嵌套的;验证一下。(这是由每个顶级更新函数调用，如setState、forceUpdate等;</span></span><br><span class="line">  <span class="comment">//   顶级组件的创建和销毁在ReactMount中受到保护。)</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!batchingStrategy.isBatchingUpdates) &#123;</span><br><span class="line">    batchingStrategy.batchedUpdates(enqueueUpdate, component);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  dirtyComponents.push(component);</span><br><span class="line">  <span class="keyword">if</span> (component._updateBatchNumber == <span class="literal">null</span>) &#123;</span><br><span class="line">    component._updateBatchNumber = updateBatchNumber + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先确保依赖注入，之后判断<code>batchingStrategy.isBatchingUpdates</code>变量，那么当前值还是true的。所以下面就将该组件push进<code>dirtyComponents</code>，并且给组件添加一个<code>_updateBatchNumber</code>值，这个<code>updateBatchNumber</code>是外部闭包的一个变量。</p><p>一路return回到了<code>performInitialMount</code>函数，开始检测<code>_pendingStateQueue</code>，这边按照我们的示例是有一个的，那么就计算出最新的state，那么可以发现React是进行批处理的。</p><p>之后因为<code>renderedElement</code>是<code>undefined</code>开始执行<code>render</code>，就到了<code>_renderValidatedComponent</code>函数，继而又到了<code>_renderValidatedComponentWithoutOwnerOrContext</code>函数，执行实例的<code>render</code>方法，我们来看一下<code>App</code>的render方法</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">    console.<span class="keyword">log</span>('render');</span><br><span class="line">    return (</span><br><span class="line">        <span class="variable">&lt;div&gt;</span></span><br><span class="line">            &#123; this.<span class="keyword">state</span>.name &#125;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>render</code>函数打印一句话然后返回一个DOM节点。然后一路返回到了<code>performInitialMount</code>方法。</p><p>一路平淡无奇到了这</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> child = <span class="keyword">this</span>._instantiateReactComponent(renderedElement, nodeType !== ReactNodeTypes.EMPTY);</span><br></pre></td></tr></table></figure><p>那么这会的<code>renderedElement</code>就是我们render返回出来的那个DOM节点，只不过被babel调用了React.createElement解析成了一个ReactElement。我们来看一下当前的这个ReactElement</p><p><img src="http://static.zybuluo.com/shenweizheng/1ghvrhki0h4bzmp6px8spd7h/image_1dmd8olb09ie2vd1u2v1v461c2l34.png" alt="image_1dmd8olb09ie2vd1u2v1v461c2l34.png-32.8kB"></p><p>那么这边调用<code>_instantiateReactComponent</code>实际上也就是<code>instantiateReactComponent</code>方法，这边因为<code>node.type</code>是一个字符串，那么会调用<code>ReactHostComponent.createInternalComponent</code>创建一个<code>ReactHostComponent</code>实例，实际上也就是<code>ReactDOMComponent</code>实例。</p><p>拿到了<code>child</code>之后，又开始对<code>child</code>执行挂载，这会执行的就是<code>ReactDOMComponent.mountComponent</code>。</p><p>一系列操作完之后，回到了<code>ReactCompositeComponent.mountComponnet</code>中继续往下执行。到了这也就是App以下的都挂载完了，开始执行App的<code>componentDidMount</code></p><figure class="highlight mercury"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">if</span> (<span class="keyword">inst</span>.componentDidMount) &#123;</span><br><span class="line">  <span class="built_in">if</span> (process.env.NODE_ENV !<span class="built_in">=</span><span class="built_in">=</span> <span class="string">'production'</span>) &#123;</span><br><span class="line">    <span class="comment">/**/</span></span><br><span class="line">  &#125; <span class="built_in">else</span> &#123;</span><br><span class="line">    transaction.getReactMountReady().enqueue(<span class="keyword">inst</span>.componentDidMount, <span class="keyword">inst</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这边直接是把<code>componentDidMount</code>方法压入ReactReconcileTransaction的callbackQueue队列中。因为这边<code>transaction.getReactMountReady()</code>是返回的一个callbackQueue。</p><p>到此App的<code>componentDidMount</code>之前的都已经执行完了，回到了<code>ReactReconcile.mountComponent</code>.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">mountComponent: <span class="function"><span class="keyword">function</span> (<span class="params">internalInstance, transaction, hostParent, hostContainerInfo, context, parentDebugID</span>) // 0 <span class="title">in</span> <span class="title">production</span> <span class="title">and</span> <span class="title">for</span> <span class="title">roots</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">      <span class="comment">/**/</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 走这开始调用实例的挂载</span></span><br><span class="line">    <span class="keyword">var</span> markup = internalInstance.mountComponent(transaction, hostParent, hostContainerInfo, context, parentDebugID);</span><br><span class="line">    <span class="keyword">if</span> (internalInstance._currentElement &amp;&amp; internalInstance._currentElement.ref != <span class="literal">null</span>) &#123;</span><br><span class="line">      transaction.getReactMountReady().enqueue(attachRefs, internalInstance);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (internalInstance._debugID !== <span class="number">0</span>) &#123;</span><br><span class="line">        ReactInstrumentation.debugTool.onMountComponent(internalInstance._debugID);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> markup;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>那么到现在我们可以理会到了<code>ReactReconcile</code>的作用了，他内部的<code>mountComponent</code>是所有实例挂载的入口，在<code>ReactReconcile</code>内部才会开始调用实例自己的<code>mountComponent</code>。而<code>Reconcile</code>调度也就是这个意思。</p><p>那么再执行完实例自己的<code>mountComponent</code>之后，判断实例是否具有<code>ref</code>属性，如果有的话会将一个函数名为<code>attachRefs</code>，调用上下文为当前传入的实例(internalInstance)压入到事务的callbackQueue中。那么之所以要将函数和上下文都一起保存是因为是要确保回调函数的内部this指向。</p><p>那么之后就是一路的return，回到了<code>mountComponentIntoNode</code>，开始执行<code>ReactMount._mountImageIntoNode</code>方法</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">_mountImageIntoNode: function (markup, <span class="keyword">container</span>, <span class="keyword">instance</span>, shouldReuseMarkup, transaction) &#123;</span><br><span class="line">  <span class="comment">/**/</span></span><br><span class="line">  <span class="keyword">if</span> (shouldReuseMarkup) &#123;</span><br><span class="line">    var rootElement = getReactRootElementInContainer(<span class="keyword">container</span>);</span><br><span class="line">    <span class="keyword">if</span> (ReactMarkupChecksum.canReuseMarkup(markup, rootElement)) &#123;</span><br><span class="line">      ReactDOMComponentTree.precacheNode(<span class="keyword">instance</span>, rootElement);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      var checksum = rootElement.getAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);</span><br><span class="line">      rootElement.removeAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);</span><br><span class="line"></span><br><span class="line">      var rootMarkup = rootElement.outerHTML;</span><br><span class="line">      rootElement.setAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME, checksum);</span><br><span class="line"></span><br><span class="line">      var normalizedMarkup = markup;</span><br><span class="line">      <span class="keyword">if</span> (process.<span class="keyword">env</span>.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">       <span class="comment">/**/</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      var diffIndex = firstDifferenceIndex(normalizedMarkup, rootMarkup);</span><br><span class="line">      var difference = <span class="string">' (client) '</span> + normalizedMarkup.<span class="keyword">substring</span>(diffIndex - <span class="number">20</span>, diffIndex + <span class="number">20</span>) + <span class="string">'\n (server) '</span> + rootMarkup.<span class="keyword">substring</span>(diffIndex - <span class="number">20</span>, diffIndex + <span class="number">20</span>);</span><br><span class="line">       <span class="comment">/**/</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**/</span></span><br><span class="line">  <span class="keyword">if</span> (transaction.useCreateElement) &#123;</span><br><span class="line">    <span class="comment">// 清空容器子节点，换行符也算一个childNode，lastChild,firstChild是取的childNodes，不是children，换行符也算一个childNode</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">container</span>.lastChild) &#123;</span><br><span class="line">      <span class="keyword">container</span>.removeChild(<span class="keyword">container</span>.lastChild);</span><br><span class="line">    &#125;</span><br><span class="line">    DOMLazyTree.insertTreeBefore(<span class="keyword">container</span>, markup, null);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    setInnerHTML(<span class="keyword">container</span>, markup);</span><br><span class="line">    ReactDOMComponentTree.precacheNode(<span class="keyword">instance</span>, <span class="keyword">container</span>.firstChild);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (process.<span class="keyword">env</span>.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">    <span class="comment">/**/</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先对<code>shouleReuseMarkup</code>做判断，当前为<code>false</code>，往下就是判断<code>transaction.useCreateElement</code>，那么这个<code>useCreateElement</code>是在实例化<code>ReactReconcileTransaction</code>时，传给构造函数的一个参数，当前为<code>true</code>。ok，进入这个if内部</p><p>一个while清空<code>container</code>内部的所有子节点</p><p><img src="http://static.zybuluo.com/shenweizheng/rmv5u5yaqx4ymdk8s63xauyq/image_1dmdm98isnrc1cdg1midkj611v23u.png" alt="image_1dmdm98isnrc1cdg1midkj611v23u.png-157.4kB"></p><p><img src="http://static.zybuluo.com/shenweizheng/5bc4zxhzzjdpcg2puxto58vy/image_1dmdm8cot1bad1h1ttihcmbte63h.png" alt="image_1dmdm8cot1bad1h1ttihcmbte63h.png-58.5kB"></p><p>打断点走到这可以看出<code>root</code>节点里的子节点都被清空了，然后开始执行<code>DOMLazyTree.insertTreeBefore</code>方法，开始将虚拟DOM插入到真实DOM中。</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">var insertTreeBefore = createMicrosoftUnsafeLocalFunction(function (parentNode, <span class="keyword">tree</span>, referenceNode) &#123;</span><br><span class="line">  <span class="comment">// DocumentFragments aren't actually part of the DOM after insertion so</span></span><br><span class="line">  <span class="comment">// appending children won't update the DOM. We need to ensure the fragment</span></span><br><span class="line">  <span class="comment">// is properly populated first, breaking out of our lazy approach for just</span></span><br><span class="line">  <span class="comment">// this level. Also, some &lt;object&gt; plugins (like Flash Player) will read</span></span><br><span class="line">  <span class="comment">// &lt;param&gt; nodes immediately upon insertion into the DOM, so &lt;object&gt;</span></span><br><span class="line">  <span class="comment">// must also be populated prior to insertion into the DOM.</span></span><br><span class="line">  <span class="comment">// 文档片段在插入之后实际上不是DOM的一部分，所以附加的子元素不会更新DOM。</span></span><br><span class="line">  <span class="comment">// 我们需要确保首先正确填充了片段，从而打破只针对这个级别的惰性方法。</span></span><br><span class="line">  <span class="comment">// 此外，一些&lt;object&gt;插件(如Flash Player)在插入到DOM时将立即读取&lt;param&gt;节点，因此在插入到DOM之前还必须填充&lt;object&gt;。</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">tree</span>.node.nodeType === DOCUMENT_FRAGMENT_NODE_TYPE || <span class="keyword">tree</span>.node.nodeType === ELEMENT_NODE_TYPE &amp;&amp; <span class="keyword">tree</span>.node.nodeName.toLowerCase() === <span class="string">'object'</span> &amp;&amp; (<span class="keyword">tree</span>.node.namespaceURI == null || <span class="keyword">tree</span>.node.namespaceURI === DOMNamespaces.html)) &#123;</span><br><span class="line">    insertTreeChildren(<span class="keyword">tree</span>);</span><br><span class="line">    parentNode.insertBefore(<span class="keyword">tree</span>.node, referenceNode);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    parentNode.insertBefore(<span class="keyword">tree</span>.node, referenceNode);</span><br><span class="line">    insertTreeChildren(<span class="keyword">tree</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>对<code>tree.node.nodeType</code>做判断，当前进入else代码块，只看代码的话会发现if和else的代码块只是顺序不一样。那么接下来就是DOM操作了，将<code>tree.node</code>插入到<code>parent</code>的子节点中，这边的<code>referenceNode</code>是<code>null</code>，表明在<code>parentNode</code>的子节点末尾插。</p><p><img src="http://static.zybuluo.com/shenweizheng/sqekm98wt1z8hcc2pkbw22e1/image_1dmdmr8991jui1vmlf90ies1tao4r.png" alt="image_1dmdmr8991jui1vmlf90ies1tao4r.png-45.8kB"></p><p>那么这个时候我们发现这个时候节点已经插进去了</p><p><img src="http://static.zybuluo.com/shenweizheng/iwznk23gz7wqge9d3v4asfok/image_1dmdna6lb1t0uum6rlasa113j058.png" alt="image_1dmdna6lb1t0uum6rlasa113j058.png-14.7kB"></p><p>接下来调用`insertTreeChildren方法</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insertTreeChildren</span><span class="params">(tree)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!enableLazy) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> node = tree.node;</span><br><span class="line">  <span class="keyword">var</span> children = tree.children;</span><br><span class="line">  <span class="keyword">if</span> (children.length) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; children.length; i++) &#123;</span><br><span class="line">      insertTreeBefore(node, children[i], <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tree.html != <span class="literal">null</span>) &#123;</span><br><span class="line">    setInnerHTML(node, tree.html);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tree.text != <span class="literal">null</span>) &#123;</span><br><span class="line">    setTextContent(node, tree.text);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这边用到了一个变量<code>enableLazy</code>，这是根据不同的浏览器来判定的。理由在源码的英文注释中给出了</p><blockquote><p> In IE (8-11) and Edge, appending nodes with no children is dramatically<br> faster than appending a full subtree, so we essentially queue up the<br> .appendChild calls here and apply them so each node is added to its parent<br> before any children are added.</p></blockquote><blockquote><p>In other browsers, doing so is slower or neutral compared to the other order<br> (in Firefox, twice as slow) so we only do this inversion in IE.</p></blockquote><p>大致意思就是在IE浏览器和Edge浏览器(Microsoft Edge)中，添加没有子节点的节点比直接添加完整的DOM树要快得多。</p><p>在其他浏览器中，这样做比另一种顺序(在Firefox中，是两倍慢)更慢或更中立，所以我们只在IE中做这种倒置。</p><p>然后就对浏览器做了一个判断</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> enableLazy = <span class="keyword">typeof</span> <span class="built_in">document</span> !== <span class="string">'undefined'</span> &amp;&amp; <span class="keyword">typeof</span> <span class="built_in">document</span>.documentMode === <span class="string">'number'</span> || <span class="keyword">typeof</span> navigator !== <span class="string">'undefined'</span> &amp;&amp; <span class="keyword">typeof</span> navigator.userAgent === <span class="string">'string'</span> &amp;&amp; <span class="regexp">/\bEdge\/\d/</span>.test(navigator.userAgent);</span><br></pre></td></tr></table></figure><p>如果是IE的话那么<code>enableLazy</code>就是true，那么当前是用的Chrome。所以这个方法就直接return了。这一块做的就是对IE浏览器做不同的插入操作。IE真的是前端的。。。。。</p><p>那么到这整个<code>ReactReconcileTransaction.perform</code>里的<code>callback</code>就都执行完了，虚拟节点已经转换为真实的DOM节点完成了挂载，但是我们还没有执行<code>componentDidMount</code>生命周期方法。</p><p>之前也看到这个方法是添加到了事务的callbackQueue队列中了，事实上，这个生命周期会在事务关闭的时候被执行，别忘了�事务在关闭的时候会执行所有的<code>close</code>的。</p><p><img src="http://static.zybuluo.com/shenweizheng/1d4coqj1uverxh6zooocfvc9/image_1dmdnn8btodomsg69g2uhg5s5l.png" alt="image_1dmdnn8btodomsg69g2uhg5s5l.png-163.9kB"></p><p>整个流程已经走到了这。下面就开始执行<code>closeAll</code>方法执行外层包裹的wrapper的close方法了。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ReactReconcileTransaction.js</span></span><br><span class="line"><span class="keyword">var</span> SELECTION_RESTORATION = &#123;</span><br><span class="line">  <span class="comment">/**/</span></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> &#123;Selection&#125; sel Selection information returned from `initialize`.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  close: ReactInputSelection.restoreSelection</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> EVENT_SUPPRESSION = &#123;</span><br><span class="line">  <span class="comment">/**/</span></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> &#123;boolean&#125; previouslyEnabled Enabled status of</span></span><br><span class="line"><span class="comment">   *   `ReactBrowserEventEmitter` before the reconciliation occurred. `close`</span></span><br><span class="line"><span class="comment">   *   restores the previous value.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  close: <span class="function"><span class="keyword">function</span> <span class="params">(previouslyEnabled)</span> </span>&#123;</span><br><span class="line">    ReactBrowserEventEmitter.setEnabled(previouslyEnabled);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ON_DOM_READY_QUEUEING = &#123;</span><br><span class="line">  <span class="comment">/**/</span></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * After DOM is flushed, invoke all registered `onDOMReady` callbacks.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  close: <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    this.reactMountReady.notifyAll();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>那么前两个close我们就不关注了，来看第三个<code>close</code>，执行<code>reactMountReady.notifyAll()</code>方法。</p><p>那么这个<code>reactMountReady</code>本质上是一个<code>callbackQueue</code>，而<code>notifyAll</code>方法就是来执行收集到了所有的回调，并通过<code>call</code>方法将回调函数的this指向到对应的<code>context</code>。</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">CallbackQueue.prototype.notifyAll = <span class="function"><span class="keyword">function</span> <span class="title">notifyAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> callbacks = <span class="keyword">this</span>._callbacks;</span><br><span class="line">  <span class="keyword">var</span> contexts = <span class="keyword">this</span>._contexts;</span><br><span class="line">  <span class="keyword">var</span> arg = <span class="keyword">this</span>._arg;</span><br><span class="line">  <span class="keyword">if</span> (callbacks &amp;&amp; contexts) &#123;</span><br><span class="line">    !(callbacks.length === contexts.length) ? process.env.NODE_ENV !== <span class="string">'production'</span> ? <span class="comment">/**/</span></span><br><span class="line">    <span class="keyword">this</span>._callbacks = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">this</span>._contexts = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; callbacks.length; i++) &#123;</span><br><span class="line">      callbacks[i].call(contexts[i], arg);</span><br><span class="line">    &#125;</span><br><span class="line">    callbacks.length = <span class="number">0</span>;</span><br><span class="line">    contexts.length = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>那么目前收集到的回调只有一个<code>componentDidMount</code>，我们的示例中，在这个生命周期函数中打印了一句话调用了一次<code>setState</code>，那么根据上面说的<code>setState</code>会将组件标记为<code>dirtyComponent</code>并将新的state添加进实例的<code>_pendingStateQueue</code>。</p><p>调用完所有收集到的回调之后就清空<code>_callback</code>， <code>_context</code>两个数组。</p><p>执行完<code>ReactReconcileTransaction</code>所有的close之后，将<code>wrapperInitData</code>清空，在事务的最后也就是<code>finally</code>代码快，将事务正在执行事务的标记变量记为<code>false</code>。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (errorThrown) &#123;</span><br><span class="line">      <span class="comment">// If `method` throws, prefer to show that stack trace over any thrown</span></span><br><span class="line">      <span class="comment">// by invoking `closeAll`.</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.closeAll(<span class="number">0</span>);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (err) &#123;&#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// Since `method` didn't throw, we don't want to silence the exception</span></span><br><span class="line">      <span class="comment">// here.</span></span><br><span class="line">      <span class="keyword">this</span>.closeAll(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>._isInTransaction = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么整个调度事务到这就都执行完了。那么到这整个流程就回到了<code>batchedMountComponentIntoNode</code>方法，接下来就是需要调用<code>ReactUpdates.ReactReconcileTransaction.release</code>释放这个调度事务。</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ReactMount.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">batchedMountComponentIntoNode</span><span class="params">(componentInstance, container, shouldReuseMarkup, context)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> transaction = ReactUpdates.ReactReconcileTransaction.getPooled(</span><br><span class="line">  !shouldReuseMarkup &amp;&amp; ReactDOMFeatureFlags.useCreateElement);</span><br><span class="line">  transaction.perform(mountComponentIntoNode, <span class="literal">null</span>, componentInstance, container, transaction, shouldReuseMarkup, context);</span><br><span class="line">  ReactUpdates.ReactReconcileTransaction.release(transaction);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么到这整个<code>batchedMountComponentIntoNode</code>方法就算执行完了，但是这个方法是<code>ReactDefaultBatchingStrategyTransaction</code>事务的回调。根据事务的规矩，执行完回调就需要执行<code>close</code>了。</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ReactDefaultBatchingStrategy.js</span></span><br><span class="line"><span class="keyword">var</span> RESET_BATCHED_UPDATES = &#123;</span><br><span class="line">  <span class="comment">/**/</span></span><br><span class="line">  close: <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    ReactDefaultBatchingStrategy.isBatchingUpdates = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> FLUSH_BATCHED_UPDATES = &#123;</span><br><span class="line">  initialize: emptyFunction,</span><br><span class="line">  close: ReactUpdates.flushBatchedUpdates.bind(ReactUpdates)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>那么第一个就不说了，设置一下<code>isBatchingUpdates</code>，第二个才是关键，调用了<code>ReactUpdates.flushBatchedUpdates</code>刷新更新队列。下面的东西就是更新阶段的事情了，因为我们在挂载阶段的两个生命周期调用了<code>setState</code>，当前<code>dirtyComponents</code>中包含两项，这个<code>flushBatchedUpdates</code>就是要刷新<code>dirtyComponents</code>来完成更新。更新阶段的事下回再说。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;上回说到了&lt;code&gt;ReactMount._renderNewRootComponent&lt;/code&gt;中调用了&lt;code&gt;ReactUpdates.batchedUpdates&lt;/code&gt;方法，实质上调用的是&lt;code&gt;ReactDefaultBatchingStrategy.batchedUpdates&lt;/code&gt;，然后就讲了一下&lt;code&gt;Transaction&lt;/code&gt;。那么现在回到流程上来，继续往下走，现在Transaction也了解了，那么剩下的就好办了。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="js" scheme="http://shenweini.cn/tags/js/"/>
    
      <category term="react" scheme="http://shenweini.cn/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>React@15.6.2源码解析---从 ReactDOM.render 到页面渲染（4）Transaction</title>
    <link href="http://shenweini.cn/2019/09/28/React@15.6.2%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90---%E4%BB%8E%20ReactDOM.render%20%E5%88%B0%E9%A1%B5%E9%9D%A2%E6%B8%B2%E6%9F%93%EF%BC%884%EF%BC%89Transaction/"/>
    <id>http://shenweini.cn/2019/09/28/React@15.6.2源码解析---从 ReactDOM.render 到页面渲染（4）Transaction/</id>
    <published>2019-09-28T08:57:30.356Z</published>
    <updated>2019-09-28T08:57:30.356Z</updated>
    
    <content type="html"><![CDATA[<p>英文注释翻译</p><blockquote><p>React 中的 Transaction 创建一个黑盒环境来对方法进行封装，它能够封装任何方法，以便在调用方法之前和之后维护某些不变量(即使在调用封装的方法时抛出异常)。</p><p>任何实例化事务的人都可以在创建时提供不变量的实施者。“Transaction”类本身将为您提供一个额外的自动不变量（_isInTransaction）——任何事务实例在已经运行时不应该运行这个不变量。您通常会创建一个“事务”的单一实例，以便多次重用，该实例可能用于包装几个不同的方法。包装器非常简单——它们只需要实现两个方法。</p></blockquote><blockquote><p>使用范围</p><ol><li>保存‘调和’前后的输入选择范围。恢复选择，即使在发生意外错误的情况下。</li><li>重排Dom时，禁用事件，避免引发多余的 blur/focus 事件，同时确保重排之后重新激活事件系统</li><li>work线程调和后，由主线程更新UI</li><li>渲染完成之后，调用所有的componentDidUpdate</li><li>(Future case)包装“ReactWorker”队列的特定刷新，以保存“scrollTop”(自动滚动感知DOM)。</li><li>(Future case)DOM更新前后的布局计算。</li></ol><p>事务性插件API</p><ol><li>‘initialize’: 具有“初始化”方法的模块，该方法返回任何预计算。</li><li>‘close’: 以及接受预计算的“close”方法。“close”在包装的流程完成或失败时调用。</li></ol><p>自定义Transaction: 通过将Tracaction中的属性通过Object.assign添加到自定义transaction的原型链中</p></blockquote><p>个人理解</p><blockquote><p>Transaction 对我们所要执行的方法进行一个封装，创建了一个黑盒环境。每个 Transaction 都会被一个或多个 wrapper 包裹，每一个 wrapper 都包含两个属性，一个是<code>initialize</code> 一个是 <code>close</code>，当 transaction执行的时候，首先会执行所有的<code>initialize</code>并添加异常机制，之后执行我们包装的方法，最后在执行所有的<code>close</code>并添加异常机制。</p><p>属性概述<br><code>_isInTransaction</code>：Transaction是否在运行</p><p><code>reinitializeTransaction</code>：初始化Transaction</p><p><code>getTransactionWrappers</code>：获取包裹的wrapper</p><p><code>isInTransaction</code>：判断当前是否在运行的方法</p><p><code>perform</code>：Transaction的核心方法，用来执行包裹的<code>method</code></p><p><code>inistializeAll</code>：执行所有<code>wrapper</code>的 <code>initialize</code></p><p><code>closeAll</code>：执行所有<code>wrapper</code>的<code>close</code></p><p>自定义Transaction</p><p>当我们衍生出一个自定义Transaction时，只需要使用Object.assign将Transaction的所有方法添加到我们自定义的Transaction上，然后重写<code>getTransactionWrappers</code>方法。</p></blockquote><a id="more"></a><p>官方给的一个图很形象</p><p><img src="http://static.zybuluo.com/shenweizheng/0b9bfta7vxhs16s9jbshyfji/image_1dlr6lhv411hf178i13l51mk91ik99.png" alt="image_1dlr6lhv411hf178i13l51mk91ik99.png-98.7kB"></p><p><code>wrappers</code>是在Transaction被创建时注入的，实质上是通过上面说的通过Object.assign方法重写<code>getTransactionWrappers</code>方法得到包裹的<code>wrappers</code>，当运行<code>perform</code>方法时，首先执行的是所有的<code>initialize</code>之后是<code>method</code>最后是所有的<code>close</code></p><h2 id="Transaction"><a href="#Transaction" class="headerlink" title="Transaction"></a>Transaction</h2><h3 id="reinitializeTransaction"><a href="#reinitializeTransaction" class="headerlink" title="reinitializeTransaction"></a>reinitializeTransaction</h3><p>用于 Transaction 初始化，在实例化Transaction时，都执行了这个方法。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Transaction.js</span></span><br><span class="line">reinitializeTransaction: function () &#123;</span><br><span class="line">    <span class="keyword">this</span>.transactionWrappers = <span class="keyword">this</span>.getTransactionWrappers();</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.wrapperInitData) &#123;</span><br><span class="line">      <span class="keyword">this</span>.wrapperInitData.length = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.wrapperInitData = [];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>._isInTransaction = <span class="literal">false</span>;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><p>通过调用<code>getTransactionWrappers</code>方法，给Transaction实例添加<code>transactionWrappers</code>属性，之后附加<code>wrapperInitData</code>为空数组，并将运行标志<code>_isInTransaction</code>设为<code>false</code>。</p><p>其中<code>wrapperInitData</code>数组是用来存储<code>initialize</code>的返回值的，用原文注释中的说法就是，存储<code>initialize</code>返回的预计算数据，在<code>close</code>方法中需要用到这些预计算，实质上就是用来判断是否出现了异常。</p><h3 id="getTransactionWrappers"><a href="#getTransactionWrappers" class="headerlink" title="getTransactionWrappers"></a>getTransactionWrappers</h3><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// Transaction.js</span><br><span class="line">/**</span><br><span class="line"> * @<span class="keyword">abstract</span></span><br><span class="line"> * @<span class="keyword">return</span> &#123;<span class="keyword">Array</span>&lt;TransactionWrapper&gt;&#125; <span class="keyword">Array</span> <span class="keyword">of</span> transaction wrappers.</span><br><span class="line"> */</span><br><span class="line">getTransactionWrappers: null,</span><br></pre></td></tr></table></figure><p>这个属性用来获取Transaction外部的<code>wrappers</code>，在定义Transaction时，会通过Object.assign方法重写该属性</p><h3 id="isInTransaction"><a href="#isInTransaction" class="headerlink" title="isInTransaction"></a>isInTransaction</h3><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Transaction.js</span></span><br><span class="line">isInTransaction: <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> !!<span class="keyword">this</span>._isInTransaction;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>判断当前<code>Transaction</code>是否在执行，使用<code>!!</code>两个感叹号，是可以做类型判断</p><h3 id="perform"><a href="#perform" class="headerlink" title="perform"></a>perform</h3><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Transaction.js</span></span><br><span class="line">perform: <span class="function"><span class="keyword">function</span> <span class="params">(method, scope, a, b, c, d, e, f)</span> </span>&#123;</span><br><span class="line">  <span class="comment">/* eslint-enable space-before-function-paren */</span></span><br><span class="line">  !!<span class="keyword">this</span>.isInTransaction() ? <span class="comment">/**/</span></span><br><span class="line">  <span class="keyword">var</span> errorThrown;</span><br><span class="line">  <span class="keyword">var</span> ret;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>._isInTransaction = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// Catching errors makes debugging more difficult, so we start with</span></span><br><span class="line">    <span class="comment">// errorThrown set to true before setting it to false after calling</span></span><br><span class="line">    <span class="comment">// close -- if it's still set to true in the finally block, it means</span></span><br><span class="line">    <span class="comment">// one of these calls threw.</span></span><br><span class="line">    <span class="comment">// 先设置为 true 在调用 close 之后设置 false，如果最后还是 true 的话 那么中途出现了异常</span></span><br><span class="line">    errorThrown = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">this</span>.initializeAll(<span class="number">0</span>);</span><br><span class="line">    ret = method.call(scope, a, b, c, d, e, f);</span><br><span class="line">    errorThrown = <span class="literal">false</span>;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (errorThrown) &#123;</span><br><span class="line">        <span class="comment">// If `method` throws, prefer to show that stack trace over any thrown</span></span><br><span class="line">        <span class="comment">// by invoking `closeAll`.</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">this</span>.closeAll(<span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (err) &#123;&#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Since `method` didn't throw, we don't want to silence the exception</span></span><br><span class="line">        <span class="comment">// here.</span></span><br><span class="line">        <span class="keyword">this</span>.closeAll(<span class="number">0</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>._isInTransaction = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><ul><li><p><code>Transaction</code>的核心方法，用来执行包裹的<code>method</code>。</p></li><li><p>首先会判断当前<code>Transaction</code>是否在运行，是的话会报错</p></li></ul><p>之后会将<code>_isInTransaction</code>设为<code>true</code>，表明该Transaction在执行</p><ul><li><p>调用<code>initializeAll(0)</code>参数<code>0</code>表示从第一个wrapper开始运行，<code>0</code>表示wrappers数组的下标</p></li><li><p><code>errorThrown</code> 用来判断执行<code>method</code>期间是否出现了异常</p></li><li><p>执行<code>method</code></p></li><li><p>执行所有的<code>close</code></p></li><li><p>将<code>_isInTransaction</code> 设为<code>false</code> 表明<code>Transaction</code>执行完成</p></li><li><p>返回<code>method</code> 的返回值</p></li></ul><h3 id="initializeAll"><a href="#initializeAll" class="headerlink" title="initializeAll"></a>initializeAll</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Transaction.js </span></span><br><span class="line">initializeAll: function (startIndex) &#123;</span><br><span class="line">  <span class="keyword">var</span> transactionWrappers = <span class="keyword">this</span>.transactionWrappers;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = startIndex; i &lt; transactionWrappers.length; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> wrapper = transactionWrappers[i];</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// Catching errors makes debugging more difficult, so we start with the</span></span><br><span class="line">      <span class="comment">// OBSERVED_ERROR state before overwriting it with the real return value</span></span><br><span class="line">      <span class="comment">// of initialize -- if it's still set to OBSERVED_ERROR in the finally</span></span><br><span class="line">      <span class="comment">// block, it means wrapper.initialize threw.</span></span><br><span class="line">      <span class="keyword">this</span>.wrapperInitData[i] = OBSERVED_ERROR;</span><br><span class="line">      <span class="keyword">this</span>.wrapperInitData[i] = wrapper.initialize ? wrapper.initialize.call(<span class="keyword">this</span>) : <span class="literal">null</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.wrapperInitData[i] === OBSERVED_ERROR) &#123;</span><br><span class="line">        <span class="comment">// The initializer for wrapper i threw an error; initialize the</span></span><br><span class="line">        <span class="comment">// remaining wrappers but silence any exceptions from them to ensure</span></span><br><span class="line">        <span class="comment">// that the first error is the one to bubble up.</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">this</span>.initializeAll(i + <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (err) &#123;&#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>执行所有的<code>initialize</code>方法，这边做了异常处理，异常逻辑为：将对应的<code>wrapperInitData</code>设为<code>OBSERVED_ERROR</code>,之后将<code>initialize</code>的返回值设为新的<code>wrapperInitData</code>，最后判断<code>wrapperInitData</code>的值，如果仍为<code>OBSERVED_ERROR</code>表明在执行initialize的过程中发生了异常。</p><h3 id="closeAll"><a href="#closeAll" class="headerlink" title="closeAll"></a>closeAll</h3><p>执行所有的close，其中的异常处理机制和<code>initializeAll</code>相类似</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">closeAll: <span class="function"><span class="keyword">function</span> <span class="params">(startIndex)</span> </span>&#123;</span><br><span class="line">    !<span class="keyword">this</span>.isInTransaction() ? <span class="comment">/**/</span></span><br><span class="line">    <span class="keyword">var</span> transactionWrappers = <span class="keyword">this</span>.transactionWrappers;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = startIndex; i &lt; transactionWrappers.length; i++) &#123;</span><br><span class="line">      <span class="keyword">var</span> wrapper = transactionWrappers[i];</span><br><span class="line">      <span class="keyword">var</span> initData = <span class="keyword">this</span>.wrapperInitData[i];</span><br><span class="line">      <span class="keyword">var</span> errorThrown;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// Catching errors makes debugging more difficult, so we start with</span></span><br><span class="line">        <span class="comment">// errorThrown set to true before setting it to false after calling</span></span><br><span class="line">        <span class="comment">// close -- if it's still set to true in the finally block, it means</span></span><br><span class="line">        <span class="comment">// wrapper.close threw.</span></span><br><span class="line">        errorThrown = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (initData !== OBSERVED_ERROR &amp;&amp; wrapper.close) &#123;</span><br><span class="line">          wrapper.close.call(<span class="keyword">this</span>, initData);</span><br><span class="line">        &#125;</span><br><span class="line">        errorThrown = <span class="literal">false</span>;</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (errorThrown) &#123;</span><br><span class="line">          <span class="comment">// The closer for wrapper i threw an error; close the remaining</span></span><br><span class="line">          <span class="comment">// wrappers but silence any exceptions from them to ensure that the</span></span><br><span class="line">          <span class="comment">// first error is the one to bubble up.</span></span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.closeAll(i + <span class="number">1</span>);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (e) &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.wrapperInitData.length = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>执行完之后将<code>wrapperInitData</code>清空。</p><h2 id="ReactDefaultBatchingStrategyTransaction"><a href="#ReactDefaultBatchingStrategyTransaction" class="headerlink" title="ReactDefaultBatchingStrategyTransaction"></a>ReactDefaultBatchingStrategyTransaction</h2><p>在<code>ReactDefaultBatchingStrategy.js</code>中定义了一个默认批处理策略事务。</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ReactDefaultBatchingStrategy.js</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ReactDefaultBatchingStrategyTransaction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.reinitializeTransaction();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_assign(ReactDefaultBatchingStrategyTransaction.prototype, Transaction, &#123;</span><br><span class="line">  getTransactionWrappers: <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> TRANSACTION_WRAPPERS;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>通过<code>Object.assign</code>将Transaction的属性添加到自定义Transaction的原型链中，并重写<code>getTransactionWrappers</code>方法，并且在实例化时，都会调用<code>reinitializeTransaction</code>方法进行初始化，这就是自定义一个Transaction的过程。</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> RESET_BATCHED_UPDATES = &#123;</span><br><span class="line">  initialize: emptyFunction,</span><br><span class="line">  close: <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    ReactDefaultBatchingStrategy.isBatchingUpdates = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> FLUSH_BATCHED_UPDATES = &#123;</span><br><span class="line">  initialize: emptyFunction,</span><br><span class="line">  close: ReactUpdates.flushBatchedUpdates.bind(ReactUpdates)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> TRANSACTION_WRAPPERS = [FLUSH_BATCHED_UPDATES, RESET_BATCHED_UPDATES];</span><br></pre></td></tr></table></figure><p>这个Transaction被两个wrapper包裹。他们的<code>initialize</code>方法都是空函数，那么关注点就转移到<code>close</code>方法，在该Transaction方法直接完之后，首先会将<code>ReactDefaultBatchingStrategy.isBatchingUpdates</code>设为<code>false</code>，之后就调用<code>ReactUpdates.flushBatchedUpdates</code>刷新更新队列。</p><h2 id="ReactReconcileTransaction"><a href="#ReactReconcileTransaction" class="headerlink" title="ReactReconcileTransaction"></a>ReactReconcileTransaction</h2><p>调和事务</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Currently:</span></span><br><span class="line"><span class="comment"> * - The order that these are listed in the transaction is critical:</span></span><br><span class="line"><span class="comment"> * - Suppresses events.</span></span><br><span class="line"><span class="comment"> * - Restores selection range.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Future:</span></span><br><span class="line"><span class="comment"> * - Restore document/overflow scroll positions that were unintentionally</span></span><br><span class="line"><span class="comment"> *   modified via DOM insertions above the top viewport boundary.</span></span><br><span class="line"><span class="comment"> * - Implement/integrate with customized constraint based layout system and keep</span></span><br><span class="line"><span class="comment"> *   track of which dimensions must be remeasured.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@class</span> ReactReconcileTransaction</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">function ReactReconcileTransaction(useCreateElement) &#123;</span><br><span class="line">  <span class="keyword">this</span>.reinitializeTransaction();</span><br><span class="line">  <span class="comment">// Only server-side rendering really needs this option (see</span></span><br><span class="line">  <span class="comment">// `ReactServerRendering`), but server-side uses</span></span><br><span class="line">  <span class="comment">// `ReactServerRenderingTransaction` instead. This option is here so that it's</span></span><br><span class="line">  <span class="comment">// accessible and defaults to false when `ReactDOMComponent` and</span></span><br><span class="line">  <span class="comment">// `ReactDOMTextComponent` checks it in `mountComponent`.`</span></span><br><span class="line">  <span class="keyword">this</span>.renderToStaticMarkup = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">this</span>.reactMountReady = CallbackQueue.getPooled(<span class="literal">null</span>);</span><br><span class="line">  <span class="keyword">this</span>.useCreateElement = useCreateElement;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造函数内部包含了三个属性</p><ul><li><p><code>renderToStaticMarkup</code>：只有在服务器端运行时用到</p></li><li><p><code>reactMountReady</code>：通过<code>CallbackQueue.getPooled</code>获取，实质上返回一个<code>CallbackQueue</code>实例</p></li><li><p><code>useCreateElement</code>：值为构造函数实例化时传入的参数</p></li></ul><p>调和事务的属性稍微多了一点，通过混合<code>Mixin</code>注入原型链</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Mixin = &#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@see</span> Transaction</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@abstract</span></span></span><br><span class="line"><span class="comment">   * <span class="doctag">@final</span></span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> &#123;array&lt;object&gt;&#125; List of operation wrap procedures.</span></span><br><span class="line"><span class="comment">   *   <span class="doctag">TODO:</span> convert to array&lt;TransactionWrapper&gt;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  getTransactionWrappers: <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> TRANSACTION_WRAPPERS;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> &#123;object&#125; The queue to collect `onDOMReady` callbacks with.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  getReactMountReady: <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> this.reactMountReady;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> &#123;object&#125; The queue to collect React async events.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  getUpdateQueue: <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ReactUpdateQueue;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Save current transaction state -- if the return value from this method is</span></span><br><span class="line"><span class="comment">   * passed to `rollback`, the transaction will be reset to that state.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  checkpoint: <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// reactMountReady is the our only stateful wrapper</span></span><br><span class="line">    <span class="keyword">return</span> this.reactMountReady.checkpoint();</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  rollback: <span class="function"><span class="keyword">function</span> <span class="params">(checkpoint)</span> </span>&#123;</span><br><span class="line">    this.reactMountReady.rollback(checkpoint);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * `PooledClass` looks for this, and will invoke this before allowing this</span></span><br><span class="line"><span class="comment">   * instance to be reused.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  destructor: <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    CallbackQueue.release(this.reactMountReady);</span><br><span class="line">    this.reactMountReady = <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这边提到了<code>ReactUpdateQueue</code>，也是一个重点。</p><p>外部包含了三个wrapper</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> TRANSACTION_WRAPPERS = [SELECTION_RESTORATION, EVENT_SUPPRESSION, ON_DOM_READY_QUEUEING];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 确保下拉框选择的数据在transaction后仍被选择</span></span><br><span class="line"><span class="keyword">var</span> SELECTION_RESTORATION = &#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> &#123;Selection&#125; Selection information.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  initialize: ReactInputSelection.getSelectionInformation,</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> &#123;Selection&#125; sel Selection information returned from `initialize`.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  close: ReactInputSelection.restoreSelection</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抑制可能由于高级DOM操作(如临时从DOM中删除文本输入)而意外分派的事件(blur/focus)。</span></span><br><span class="line"><span class="keyword">var</span> EVENT_SUPPRESSION = &#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> &#123;boolean&#125; The enabled status of `ReactBrowserEventEmitter` before</span></span><br><span class="line"><span class="comment">   * the reconciliation.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  initialize: <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> currentlyEnabled = ReactBrowserEventEmitter.isEnabled();</span><br><span class="line">    ReactBrowserEventEmitter.setEnabled(<span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">return</span> currentlyEnabled;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> &#123;boolean&#125; previouslyEnabled Enabled status of</span></span><br><span class="line"><span class="comment">   *   `ReactBrowserEventEmitter` before the reconciliation occurred. `close`</span></span><br><span class="line"><span class="comment">   *   restores the previous value.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  close: <span class="function"><span class="keyword">function</span> <span class="params">(previouslyEnabled)</span> </span>&#123;</span><br><span class="line">    ReactBrowserEventEmitter.setEnabled(previouslyEnabled);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提供一个队列，来收集在 componentDidMount 和 componentDidUpdate 回调</span></span><br><span class="line"><span class="comment">// 在执行事务期间，遇到这两个生命周期，会将回调押入到队列中。在close的时候在去执行</span></span><br><span class="line"><span class="keyword">var</span> ON_DOM_READY_QUEUEING = &#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Initializes the internal `onDOMReady` queue.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  initialize: <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    this.reactMountReady.reset();</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * After DOM is flushed, invoke all registered `onDOMReady` callbacks.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  close: <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    this.reactMountReady.notifyAll();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">_<span class="selector-tag">assign</span>(<span class="selector-tag">ReactReconcileTransaction</span><span class="selector-class">.prototype</span>, <span class="selector-tag">Transaction</span>, <span class="selector-tag">Mixin</span>);</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">PooledClass</span><span class="selector-class">.addPoolingTo</span>(<span class="selector-tag">ReactReconcileTransaction</span>);</span><br></pre></td></tr></table></figure><p>再往下就是这两句，第一句是将<code>Transaction</code>,<code>Mixin</code>都添加到原型链中。</p><p>第二句是调用<code>PooledClass.addPoolingTo</code>用到了<code>PoolClass</code>属性。</p><h2 id="PoolClass"><a href="#PoolClass" class="headerlink" title="PoolClass"></a>PoolClass</h2><p><code>PoolClass</code>主要目的就是减少内存消耗。</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PoolClass.js</span></span><br><span class="line">var PooledClass = &#123;</span><br><span class="line"><span class="symbol">  addPoolingTo:</span> addPoolingTo,</span><br><span class="line"><span class="symbol">  oneArgumentPooler:</span> oneArgumentPooler,</span><br><span class="line"><span class="symbol">  twoArgumentPooler:</span> twoArgumentPooler,</span><br><span class="line"><span class="symbol">  threeArgumentPooler:</span> threeArgumentPooler,</span><br><span class="line"><span class="symbol">  fourArgumentPooler:</span> fourArgumentPooler</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PoolClass.js</span></span><br><span class="line"><span class="keyword">var</span> addPoolingTo = <span class="function"><span class="keyword">function</span> <span class="params">(CopyConstructor, pooler)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Casting as any so that flow ignores the actual implementation and trusts</span></span><br><span class="line">  <span class="comment">// it to match the type we declared</span></span><br><span class="line">  <span class="keyword">var</span> NewKlass = CopyConstructor;</span><br><span class="line">  NewKlass.instancePool = [];</span><br><span class="line">  NewKlass.getPooled = pooler || DEFAULT_POOLER;</span><br><span class="line">  <span class="keyword">if</span> (!NewKlass.poolSize) &#123;</span><br><span class="line">    NewKlass.poolSize = DEFAULT_POOL_SIZE;</span><br><span class="line">  &#125;</span><br><span class="line">  NewKlass.release = standardReleaser;</span><br><span class="line">  <span class="keyword">return</span> NewKlass;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>通过<code>addPoolingTo</code>方法给传入的构造函数添加<code>instancePool</code>属性和<code>getPooled</code>，以及一个释放池的函数<code>NewKlass.release = standardReleaser</code>，默认池大小为10。默认的<code>getPooled</code>是带一个参数的池函数。PoolClass提供了很多个池函数，他们的区别就是参数的多少，默认是一个参数的。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PoolClass.js</span></span><br><span class="line"><span class="keyword">var</span> oneArgumentPooler = <span class="keyword">function</span> (copyFieldsFrom) &#123;</span><br><span class="line">  <span class="keyword">var</span> Klass = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">if</span> (Klass<span class="variable">.instancePool</span><span class="variable">.length</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> <span class="keyword">instance</span> = Klass<span class="variable">.instancePool</span><span class="variable">.pop</span>();</span><br><span class="line">    Klass<span class="variable">.call</span>(<span class="keyword">instance</span>, copyFieldsFrom);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">instance</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Klass(copyFieldsFrom);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这边可以看到如果池子里有的话，那么就直接弹出一个然后重新实例化，没有的话则重新创建。使用池来储存，减少内存消耗。</p><p>所以这边看到<code>getPooled</code>方法那就是返回一个实例调用者的实例。</p><h2 id="ReactUpdatesFlushTransaction"><a href="#ReactUpdatesFlushTransaction" class="headerlink" title="ReactUpdatesFlushTransaction"></a>ReactUpdatesFlushTransaction</h2><p>更新刷新事务，定义在<code>ReactUpdates.js</code>中，在执行ReactUpdates.flushBatchedUpdates时开启。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ReactUpdates.js</span></span><br><span class="line">function ReactUpdatesFlushTransaction() &#123;</span><br><span class="line">  <span class="keyword">this</span>.reinitializeTransaction();</span><br><span class="line">  <span class="keyword">this</span>.dirtyComponentsLength = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">this</span>.callbackQueue = CallbackQueue.getPooled();</span><br><span class="line">  <span class="keyword">this</span>.reconcileTransaction = ReactUpdates.ReactReconcileTransaction.getPooled(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_assign(ReactUpdatesFlushTransaction.prototype, Transaction, &#123;</span><br><span class="line">  getTransactionWrappers: function () &#123;</span><br><span class="line">    <span class="keyword">return</span> TRANSACTION_WRAPPERS;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  destructor: function () &#123;</span><br><span class="line">    <span class="keyword">this</span>.dirtyComponentsLength = <span class="literal">null</span>;</span><br><span class="line">    CallbackQueue.release(<span class="keyword">this</span>.callbackQueue);</span><br><span class="line">    <span class="keyword">this</span>.callbackQueue = <span class="literal">null</span>;</span><br><span class="line">    ReactUpdates.ReactReconcileTransaction.release(<span class="keyword">this</span>.reconcileTransaction);</span><br><span class="line">    <span class="keyword">this</span>.reconcileTransaction = <span class="literal">null</span>;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  perform: function (method, scope, a) &#123;</span><br><span class="line">    <span class="comment">// Essentially calls `this.reconcileTransaction.perform(method, scope, a)`</span></span><br><span class="line">    <span class="comment">// with this transaction's wrappers around it.</span></span><br><span class="line">    <span class="keyword">return</span> Transaction.perform.call(<span class="keyword">this</span>, <span class="keyword">this</span>.reconcileTransaction.perform, <span class="keyword">this</span>.reconcileTransaction, method, scope, a);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">PooledClass.addPoolingTo(ReactUpdatesFlushTransaction);</span><br></pre></td></tr></table></figure><p>需要注意的是这边重写了<code>perform</code>方法。并且使用<code>PoolClass.addPoolingTo</code>添加了池属性。</p><p>外部包裹了两个<code>wrapper</code></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> NESTED_UPDATES = &#123;</span><br><span class="line">  initialize: <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    this.dirtyComponentsLength = dirtyComponents.length;</span><br><span class="line">  &#125;,</span><br><span class="line">  close: <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (this.dirtyComponentsLength !== dirtyComponents.length) &#123;</span><br><span class="line">      <span class="comment">// Additional updates were enqueued by componentDidUpdate handlers or</span></span><br><span class="line">      <span class="comment">// similar; before our own UPDATE_QUEUEING wrapper closes, we want to run</span></span><br><span class="line">      <span class="comment">// these new updates so that if A's componentDidUpdate calls setState on</span></span><br><span class="line">      <span class="comment">// B, B will update before the callback A's updater provided when calling</span></span><br><span class="line">      <span class="comment">// setState.</span></span><br><span class="line">      <span class="comment">// 额外的更新是由于 componentDidUpdate 或其他类似的操作。</span></span><br><span class="line">      <span class="comment">// 在 update_queue wrapper close之前 我们希望运行这些新的更新以至于 如果 A 的componenDidUpdate 调用 B的 setState</span></span><br><span class="line">      <span class="comment">// 那么 B 会在 A 的updater提供的回调之前更新</span></span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      <span class="comment">// 在我们自己的UPDATE_QUEUEING包装器关闭之前，我们希望运行这些新更新</span></span><br><span class="line">      <span class="comment">// 以便如果A的componentDidUpdate在B上调用setState，那么B将在调用setState时提供回调A的updater之前更新。</span></span><br><span class="line">      dirtyComponents.splice(<span class="number">0</span>, this.dirtyComponentsLength);</span><br><span class="line">      flushBatchedUpdates();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      dirtyComponents.length = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> UPDATE_QUEUEING = &#123;</span><br><span class="line">  initialize: <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    this.callbackQueue.reset();</span><br><span class="line">  &#125;,</span><br><span class="line">  close: <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    this.callbackQueue.notifyAll();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> TRANSACTION_WRAPPERS = [NESTED_UPDATES, UPDATE_QUEUEING];</span><br></pre></td></tr></table></figure><p>需要注意的是。在第一个wrapper<code>NESTED_UPDATES</code>中的<code>initialize</code>函数，初始化当前实例的<code>dirtyComponentsLength = dirtyComponents.length</code>，之后在<code>close</code>的时候，发现他们两长度不一样了，说明在执行<code>method</code>时引起了额外的更新。这个时候就需要刷新这些新的更新。</p><p>而第二wrapper<code>UPDATE_QUEUEING</code>在会close的时候执行<code>callbackQueue.notifyAll</code>，这个方法是用来之前收集到的所有的回调。</p><p>这三个事务时目前我看到的三个，后面如果有其他的我会在加以分析。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这一篇是介绍 React 中的Transaction, 以及目前三种自定义的事务内部的一些属性及包裹的wrapper</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;英文注释翻译&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;React 中的 Transaction 创建一个黑盒环境来对方法进行封装，它能够封装任何方法，以便在调用方法之前和之后维护某些不变量(即使在调用封装的方法时抛出异常)。&lt;/p&gt;
&lt;p&gt;任何实例化事务的人都可以在创建时提供不变量的实施者。“Transaction”类本身将为您提供一个额外的自动不变量（_isInTransaction）——任何事务实例在已经运行时不应该运行这个不变量。您通常会创建一个“事务”的单一实例，以便多次重用，该实例可能用于包装几个不同的方法。包装器非常简单——它们只需要实现两个方法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;使用范围&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;保存‘调和’前后的输入选择范围。恢复选择，即使在发生意外错误的情况下。&lt;/li&gt;
&lt;li&gt;重排Dom时，禁用事件，避免引发多余的 blur/focus 事件，同时确保重排之后重新激活事件系统&lt;/li&gt;
&lt;li&gt;work线程调和后，由主线程更新UI&lt;/li&gt;
&lt;li&gt;渲染完成之后，调用所有的componentDidUpdate&lt;/li&gt;
&lt;li&gt;(Future case)包装“ReactWorker”队列的特定刷新，以保存“scrollTop”(自动滚动感知DOM)。&lt;/li&gt;
&lt;li&gt;(Future case)DOM更新前后的布局计算。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;事务性插件API&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;‘initialize’: 具有“初始化”方法的模块，该方法返回任何预计算。&lt;/li&gt;
&lt;li&gt;‘close’: 以及接受预计算的“close”方法。“close”在包装的流程完成或失败时调用。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;自定义Transaction: 通过将Tracaction中的属性通过Object.assign添加到自定义transaction的原型链中&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;个人理解&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Transaction 对我们所要执行的方法进行一个封装，创建了一个黑盒环境。每个 Transaction 都会被一个或多个 wrapper 包裹，每一个 wrapper 都包含两个属性，一个是&lt;code&gt;initialize&lt;/code&gt; 一个是 &lt;code&gt;close&lt;/code&gt;，当 transaction执行的时候，首先会执行所有的&lt;code&gt;initialize&lt;/code&gt;并添加异常机制，之后执行我们包装的方法，最后在执行所有的&lt;code&gt;close&lt;/code&gt;并添加异常机制。&lt;/p&gt;
&lt;p&gt;属性概述&lt;br&gt;&lt;code&gt;_isInTransaction&lt;/code&gt;：Transaction是否在运行&lt;/p&gt;
&lt;p&gt;&lt;code&gt;reinitializeTransaction&lt;/code&gt;：初始化Transaction&lt;/p&gt;
&lt;p&gt;&lt;code&gt;getTransactionWrappers&lt;/code&gt;：获取包裹的wrapper&lt;/p&gt;
&lt;p&gt;&lt;code&gt;isInTransaction&lt;/code&gt;：判断当前是否在运行的方法&lt;/p&gt;
&lt;p&gt;&lt;code&gt;perform&lt;/code&gt;：Transaction的核心方法，用来执行包裹的&lt;code&gt;method&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;inistializeAll&lt;/code&gt;：执行所有&lt;code&gt;wrapper&lt;/code&gt;的 &lt;code&gt;initialize&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;closeAll&lt;/code&gt;：执行所有&lt;code&gt;wrapper&lt;/code&gt;的&lt;code&gt;close&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;自定义Transaction&lt;/p&gt;
&lt;p&gt;当我们衍生出一个自定义Transaction时，只需要使用Object.assign将Transaction的所有方法添加到我们自定义的Transaction上，然后重写&lt;code&gt;getTransactionWrappers&lt;/code&gt;方法。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="js" scheme="http://shenweini.cn/tags/js/"/>
    
      <category term="react" scheme="http://shenweini.cn/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>React@15.6.2源码解析---从 ReactDOM.render 到页面渲染（3）ReactUpdates</title>
    <link href="http://shenweini.cn/2019/09/28/React@15.6.2%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90---%E4%BB%8E%20ReactDOM.render%20%E5%88%B0%E9%A1%B5%E9%9D%A2%E6%B8%B2%E6%9F%93%EF%BC%883%EF%BC%89ReactUpdates/"/>
    <id>http://shenweini.cn/2019/09/28/React@15.6.2源码解析---从 ReactDOM.render 到页面渲染（3）ReactUpdates/</id>
    <published>2019-09-28T03:05:58.462Z</published>
    <updated>2019-09-28T03:05:58.463Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>上篇博客介绍了<code>instantiateReactComponent</code>方法，方法内部实现还是很简单的，那么回到react得渲染流程里，接下来就是执行<code>ReactUpdates.batchedUpdates</code>方法，所以本篇博客讲解<code>ReactUpdates</code>操作，从名字可以看出这是处理React更新的文件，内部用到一个很重要得东西就是<code>Transaction</code>，对于这个词想必大家还是很熟悉得。<code>ReactUpdates</code>内部实现也是很简单，内部封装了<code>batchedUpdates</code>，<code>enqueueUpdate</code>，<code>flushBatchedUpdates</code>等方法，而这三个是最重要的操作。内部也用到了一些全局依赖注入得东西，和上一篇博客提到的是一样的。</p></blockquote><a id="more"></a><h2 id="ReactUpdates"><a href="#ReactUpdates" class="headerlink" title="ReactUpdates"></a>ReactUpdates</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">var</span> <span class="string">ReactUpdates</span> <span class="string">=</span> <span class="string">&#123;</span></span><br><span class="line">  <span class="string">/**</span></span><br><span class="line">   <span class="string">*</span> <span class="string">React</span> <span class="string">references</span> <span class="string">`ReactReconcileTransaction`</span> <span class="string">using</span> <span class="string">this</span> <span class="string">property</span> <span class="string">in</span> <span class="string">order</span></span><br><span class="line">   <span class="string">*</span> <span class="string">to</span> <span class="string">allow</span> <span class="string">dependency</span> <span class="string">injection.</span></span><br><span class="line">   <span class="string">*</span></span><br><span class="line">   <span class="string">*</span> <span class="string">@internal</span></span><br><span class="line">   <span class="string">*/</span></span><br><span class="line"><span class="attr">  ReactReconcileTransaction:</span> <span class="literal">null</span><span class="string">,</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  batchedUpdates:</span> <span class="string">batchedUpdates,</span></span><br><span class="line"><span class="attr">  enqueueUpdate:</span> <span class="string">enqueueUpdate,</span></span><br><span class="line"><span class="attr">  flushBatchedUpdates:</span> <span class="string">flushBatchedUpdates,</span></span><br><span class="line"><span class="attr">  injection:</span> <span class="string">ReactUpdatesInjection,</span></span><br><span class="line"><span class="attr">  asap:</span> <span class="string">asap</span></span><br><span class="line"><span class="string">&#125;;</span></span><br></pre></td></tr></table></figure><p>这是最终的<code>ReactUpdates</code>对象，内部得属性还是很少的，这边的<code>asap</code>不做说明，我没看懂这个东西，还望各位大牛指导！，下面就一一为这些属性说明</p><h3 id="ReactUpdates-injection"><a href="#ReactUpdates-injection" class="headerlink" title="ReactUpdates.injection"></a>ReactUpdates.injection</h3><p>将<code>injection</code>放在第一个是因为，这个方法在全局以来注入的时候就被执行了，论执行顺序的话，这个方法是第一个被执行的方法，而且下面的方法需要用到依赖注入的东西，本着不让看官不知道这个变量是从哪里来的原则，所以这个方法放在第一位。</p><p><code>injection</code>对应着<code>ReactUpdatesInjection</code></p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ReactUpdates.js</span></span><br><span class="line"><span class="keyword">var</span> ReactUpdatesInjection = &#123;</span><br><span class="line">  injectReconcileTransaction: <span class="function"><span class="keyword">function</span> <span class="params">(ReconcileTransaction)</span> </span>&#123;</span><br><span class="line">    !ReconcileTransaction ? <span class="comment">/**/</span></span><br><span class="line">    ReactUpdates.ReactReconcileTransaction = ReconcileTransaction;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  injectBatchingStrategy: <span class="function"><span class="keyword">function</span> <span class="params">(_batchingStrategy)</span> </span>&#123;</span><br><span class="line">    !_batchingStrategy ? <span class="comment">/**/</span></span><br><span class="line">    batchingStrategy = _batchingStrategy;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>内部有两个函数，分别用于给<code>ReactUpdates.ReactReconcileTransaction</code> 和 外部闭包的<code>batchingStrategy</code>变量赋值。每个函数内部都会首先对传入的参数做一个是否存在的验证。那么来看传递的实参是什么，回到<code>ReactDefaultInjection.js</code>文件</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ReactDefaultInjection.js</span></span><br><span class="line"><span class="selector-tag">ReactInjection</span><span class="selector-class">.Updates</span><span class="selector-class">.injectReconcileTransaction</span>(ReactReconcileTransaction);</span><br><span class="line"><span class="selector-tag">ReactInjection</span><span class="selector-class">.Updates</span><span class="selector-class">.injectBatchingStrategy</span>(ReactDefaultBatchingStrategy);</span><br></pre></td></tr></table></figure><p>那么这边可以看到一个是<code>ReactReconcileTransaction</code> 对象，一个是<code>ReactDefaultBatchingStrategy</code>对象，这两个都是重点。拿起小笔开始画重点了！！！依旧留坑，以后会说的。本人是讲信用的人，你看这两篇博客不就是在填坑。</p><h3 id="ReactUpdates-ReactReconcileTransaction"><a href="#ReactUpdates-ReactReconcileTransaction" class="headerlink" title="ReactUpdates.ReactReconcileTransaction"></a>ReactUpdates.ReactReconcileTransaction</h3><p><code>ReactReconcileTransaction</code> 属性是全局依赖注入通过<code>ReactUpdates.injection.injectReconcileTransaction</code>方法完成赋值操作。</p><p>该属性翻译为中文就是 ‘React 调和事务’。这边<code>reconcile</code>调和调节得意思，实质上就是一个过程，state改变导致VDom改变，然后计算真实Dom的过程。这边用到了<code>Transaction</code>将在下一篇博客进行讲解。并将React中得各个Transaction衍生而来得自定义Transaction做一个总结。</p><h3 id="ReactUpdates-batchedUpdates"><a href="#ReactUpdates-batchedUpdates" class="headerlink" title="ReactUpdates.batchedUpdates"></a>ReactUpdates.batchedUpdates</h3><p><code>batchedUpdates</code> 翻译为中文就是‘批量更新’，大家都知道在React中，<code>setState</code>方法是批处理的。这也是为什么React会渲染很快的原因，内部的更新进行批处理操作，避免不必要的渲染。</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function <span class="keyword">batchedUpdates(callback, </span>a, <span class="keyword">b, </span>c, d, e) &#123;</span><br><span class="line">  ensureInjected()<span class="comment">;</span></span><br><span class="line">  return <span class="keyword">batchingStrategy.batchedUpdates(callback, </span>a, <span class="keyword">b, </span>c, d, e)<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这边首先执行一个<code>ensureInjected()</code>方法，目的是确保之前依赖注入的两个变量都完成了注入。</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ensureInjected</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  !(ReactUpdates.ReactReconcileTransaction &amp;&amp; batchingStrategy)</span><br><span class="line">    ? process.env.NODE_ENV !== <span class="string">'production'</span> ? invariant(<span class="literal">false</span>, <span class="string">'ReactUpdates: must inject a reconcile transaction class and batching strategy'</span>)</span><br><span class="line">    : _prodInvariant(<span class="string">'123'</span>) : <span class="keyword">void</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>顺便一提，这边有一个小东西 <code>void 0</code>，在我的博客网站有做过说明，附上传送门<a href="https://www.jianshu.com/p/deab8d4ea9ca" target="_blank" rel="noopener">void (0) ??? undefined</a></p><p>那么回到正题，这个方法本质上是调用的<code>batchingStrategy.batchedUpdates(callback, a, b, c, d, e)</code>，这边的<code>batchingStrategy</code>就是一开始依赖注入的<code>ReactDefaultBatchingStrategy</code>，是React的默认批处理策略。下一片博客的主题就是这个。</p><h3 id="ReactUpdates-flushBatchedUpdates"><a href="#ReactUpdates-flushBatchedUpdates" class="headerlink" title="ReactUpdates.flushBatchedUpdates"></a>ReactUpdates.flushBatchedUpdates</h3><p>这边提到一个对象叫<code>dirtyComponents</code>，因为还没有用到，所以这边只是大概的描述一下，在你的React中，当你调用<code>setState</code>时，React会将你传入的值压倒一个队列中，然后将该组件标记为一个<code>dirtyComponent</code>，最后会回过头来查看这个更新队列，遍历队列计算出最终的值，然后进行渲染，这样就达到了批处理的操作，避免了大量不必要的渲染。</p><p>那么这边用到了一个<code>ReactUpdatesFlushTransaction</code> ‘更新刷新事务’</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">var flushBatchedUpdates = function () &#123;</span><br><span class="line">  // ReactUpdatesFlushTransaction's wrappers will clear the dirtyComponents</span><br><span class="line">  //<span class="built_in"> array </span>and perform any updates enqueued by mount-ready handlers (i.e.,</span><br><span class="line">  // componentDidUpdate) but we need to<span class="built_in"> check </span>here too in order to catch</span><br><span class="line">  // updates enqueued by setState callbacks<span class="built_in"> and </span>asap calls.</span><br><span class="line">  while (dirtyComponents.length || asapEnqueued) &#123;</span><br><span class="line">   <span class="built_in"> if </span>(dirtyComponents.length) &#123;</span><br><span class="line">      var transaction = ReactUpdatesFlushTransaction.getPooled();</span><br><span class="line">      transaction.perform(runBatchedUpdates, null, transaction);</span><br><span class="line">      ReactUpdatesFlushTransaction.release(transaction);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="built_in"> if </span>(asapEnqueued) &#123;</span><br><span class="line">      asapEnqueued = false;</span><br><span class="line">      var queue = asapCallbackQueue;</span><br><span class="line">      asapCallbackQueue = CallbackQueue.getPooled();</span><br><span class="line">      queue.notifyAll();</span><br><span class="line">      CallbackQueue.release(queue);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="ReactUpdates-asap"><a href="#ReactUpdates-asap" class="headerlink" title="ReactUpdates.asap"></a>ReactUpdates.asap</h3><p>不知道是个啥东西。。。</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Enqueue a callback to be run <span class="keyword">at</span> the <span class="keyword">end</span> <span class="keyword">of</span> the current batching cycle. Throws</span><br><span class="line"> * <span class="keyword">if</span> no updates are currently being performed.</span><br><span class="line"> * 在当前批处理周期结束时运行回调。如果当前没有执行更新，则引发。</span><br><span class="line"> */</span><br><span class="line"><span class="keyword">function</span> <span class="title">asap</span>(callback, context) &#123;</span><br><span class="line">  invariant(batchingStrategy.<span class="keyword">is</span>BatchingUpdates, <span class="string">"ReactUpdates.asap: Can't enqueue an asap callback in a context where"</span> + <span class="symbol">'updates</span> are <span class="keyword">not</span> being batched.');</span><br><span class="line">  asapCallbackQueue.enqueue(callback, context);</span><br><span class="line">  asapEnqueued = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>那么这边是执行<code>ReactUpdates.batchedUpdates</code>，它实质上是执行的<code>ReactDefaultBatchingStrategy.batchedUpdates</code>，这样我们的渲染流程到此就又加上一笔。</p><p><img src="http://static.zybuluo.com/shenweizheng/19lxubwgvx9zgjxvcjg30w1i/image_1dlqt4cau18a5109u1rrf19dd1l39.png" alt="image_1dlqt4cau18a5109u1rrf19dd1l39.png-68.1kB"></p><blockquote><p>本篇留坑</p><p>Transaction 及尤其衍生出的自定义事务</p><p>ReactDefaultBatchingStrategy</p><p>下篇博客：ReactDefaultBatchingStrategy</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;上篇博客介绍了&lt;code&gt;instantiateReactComponent&lt;/code&gt;方法，方法内部实现还是很简单的，那么回到react得渲染流程里，接下来就是执行&lt;code&gt;ReactUpdates.batchedUpdates&lt;/code&gt;方法，所以本篇博客讲解&lt;code&gt;ReactUpdates&lt;/code&gt;操作，从名字可以看出这是处理React更新的文件，内部用到一个很重要得东西就是&lt;code&gt;Transaction&lt;/code&gt;，对于这个词想必大家还是很熟悉得。&lt;code&gt;ReactUpdates&lt;/code&gt;内部实现也是很简单，内部封装了&lt;code&gt;batchedUpdates&lt;/code&gt;，&lt;code&gt;enqueueUpdate&lt;/code&gt;，&lt;code&gt;flushBatchedUpdates&lt;/code&gt;等方法，而这三个是最重要的操作。内部也用到了一些全局依赖注入得东西，和上一篇博客提到的是一样的。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="js" scheme="http://shenweini.cn/tags/js/"/>
    
      <category term="react" scheme="http://shenweini.cn/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>React@15.6.2源码解析---从 ReactDOM.render 到页面渲染（2）instantiateReactComponent</title>
    <link href="http://shenweini.cn/2019/09/27/React@15.6.2%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90---%E4%BB%8E%20ReactDOM.render%20%E5%88%B0%E9%A1%B5%E9%9D%A2%E6%B8%B2%E6%9F%93%EF%BC%882%EF%BC%89instantiateReactComponent/"/>
    <id>http://shenweini.cn/2019/09/27/React@15.6.2源码解析---从 ReactDOM.render 到页面渲染（2）instantiateReactComponent/</id>
    <published>2019-09-27T13:12:44.317Z</published>
    <updated>2019-09-27T13:12:44.317Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>instantiateReactComponent 方法是React中的一个很重要的方法，主要作用是根据给定的node(ReactElement类型)对象，实例化出一个将被挂载的实例。实例化出的实例大体有三种，ReactEmptyComponent、ReactCompositeComponent、ReactHostComponent，其中ReactCompositeComponent是重点，内部包装了很多方法，而ReactHostComponent主要用来实例化文本组件实例。</p><p>概述<br>Given a ReactNode, create an instance that will actually be mounted.<br>给一个ReactNode 指的是 ReactElement 对象，根据该对象创建一个实际要挂载的实例</p><p>大致流程<br>判断 node 的类型以及 node.type 的类型，根据不同的类型创建不同的实例</p></blockquote><a id="more"></a><h2 id="node-为-null-false"><a href="#node-为-null-false" class="headerlink" title="node 为 null | false"></a>node 为 null | false</h2><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">if (node === null || node === false) &#123;</span><br><span class="line">   <span class="built_in"> instance </span>= ReactEmptyComponent.create(instantiateReactComponent);</span><br><span class="line">  &#125; else<span class="built_in"> if </span>(typeof node === 'object') &#123;</span><br><span class="line">    var element = node;</span><br><span class="line">    var type = element.type; // function</span><br><span class="line">   <span class="built_in"> if </span>(typeof type !== 'function' &amp;&amp; typeof type !== 'string') &#123;</span><br><span class="line">      var info = '';</span><br><span class="line">     <span class="built_in"> if </span>(process.env.NODE_ENV !== 'production') &#123;</span><br><span class="line">        /**/</span><br><span class="line">      &#125;</span><br><span class="line">      info += getDeclarationErrorAddendum(element._owner); // ''</span><br><span class="line">      !false ? /**/</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Special case string values</span><br><span class="line">   <span class="built_in"> if </span>(typeof element.type === 'string') &#123;</span><br><span class="line">     <span class="built_in"> instance </span>= ReactHostComponent.createInternalComponent(element);</span><br><span class="line">    &#125; else<span class="built_in"> if </span>(isInternalComponentType(element.type)) &#123;</span><br><span class="line">     <span class="built_in"> if </span>(!instance.getHostNode) &#123;</span><br><span class="line">        instance.getHostNode = instance.getNativeNode;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">     <span class="built_in"> instance </span>=<span class="built_in"> new </span>ReactCompositeComponentWrapper(element);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else<span class="built_in"> if </span>(typeof node === 'string' || typeof node === 'number') &#123;</span><br><span class="line">   <span class="built_in"> instance </span>= ReactHostComponent.createInstanceForText(node);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    !false ? /**/</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>若 <code>node</code> 的类型是<code>null</code>或者为<code>false</code>，创建一个<code>ReactEmptyComponent</code>实例。</p><p><strong>ReactEmptyComponent</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ReactEmptyComponent.js</span></span><br><span class="line"><span class="keyword">var</span> emptyComponentFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ReactEmptyComponentInjection = &#123;</span><br><span class="line">  injectEmptyComponentFactory: <span class="function"><span class="keyword">function</span> (<span class="params">factory</span>) </span>&#123;</span><br><span class="line">    emptyComponentFactory = factory;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ReactEmptyComponent = &#123;</span><br><span class="line">  create: <span class="function"><span class="keyword">function</span> (<span class="params">instantiate</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> emptyComponentFactory(instantiate);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ReactEmptyComponent.injection = ReactEmptyComponentInjection;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = ReactEmptyComponent;</span><br></pre></td></tr></table></figure><p>这边可以看出<code>ReactEmptyComponent.create</code>方法就是调用<code>emptyComponentFactory()</code>方法，而<code>emptyComponentFactory</code>是外部闭包的一个对象，是在全局依赖注入是调用<code>ReactEmptyComponent.injection</code>时进行注入的。注入的地方在<code>ReactDefaultInjection.js</code>文件，这也是上一篇博客的开头所阐述的全局依赖注入，作用就在于给一些函数外部闭包的变量对象某个属性进行赋值，这样做方便管理，神乎其技的封装。我觉得这种优秀的封装也是我们该学习的一部分。有助于我们写出更加完善的代码。</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ReactInjection.EmptyComponent.injectEmptyComponentFactory(<span class="function"><span class="keyword">function</span> <span class="params">(instantiate)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ReactDOMEmptyComponent(instantiate);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>那么这边给<code>emptyComponentFactory</code>赋值的是一个函数，这个函数返回一个<code>new ReactDOMEmptyComponent(instantiate);</code>ReactDOMEmptyComponent实例。</p><p><strong>ReactDOMEmptyComponent实例</strong></p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ReactDOMEmptyComponent = <span class="function"><span class="keyword">function</span> <span class="params">(instantiate)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ReactCompositeComponent uses this:</span></span><br><span class="line">  <span class="keyword">this</span>._currentElement = <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">// ReactDOMComponentTree uses these:</span></span><br><span class="line">  <span class="keyword">this</span>._hostNode = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">this</span>._hostParent = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">this</span>._hostContainerInfo = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">this</span>._domID = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line">_assign(ReactDOMEmptyComponent.prototype, &#123;</span><br><span class="line">  mountComponent: <span class="function"><span class="keyword">function</span> <span class="params">(transaction, hostParent, hostContainerInfo, context)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**/</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  receiveComponent: <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;&#125;,</span><br><span class="line">  getHostNode: <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ReactDOMComponentTree.getNodeFromInstance(<span class="keyword">this</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  unmountComponent: <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    ReactDOMComponentTree.uncacheNode(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这边我们大致了解一下有那些属性等用到时在做阐述。那么由此可以看出，ReactEmptyComponent创建的实例实质上就是<code>ReactDOMEmptyComponent</code>。</p><h2 id="node-为-object"><a href="#node-为-object" class="headerlink" title="node 为 object"></a>node 为 object</h2><p>当 node 的类型为一个object时，这边大多数情况指的是我们的<code>node</code>是一个ReactElement。接下来会对<code>node.type</code>做判断。</p><h3 id="node-type-function-node-type-string"><a href="#node-type-function-node-type-string" class="headerlink" title="node.type !== function || node.type !== string"></a>node.type !== function || node.type !== string</h3><p>当 <code>type</code> 既不是 function 也不是一个 string 那么会报一个警告，讲道理要么是一个构造函数例如我们的<code>App</code>，那么是一个字符串例如一个<code>div</code>标签，下面给一个例子</p><p><img src="http://static.zybuluo.com/shenweizheng/nfd2ayxt0ojjxpvqztav78p5/image_1dlpb73ib1li31kp01u8v1el10g9.png" alt="image_1dlpb73ib1li31kp01u8v1el10g9.png-48.6kB"></p><p>把<code>node</code>一层层剥开，看他的<code>child</code>，剧透一下，后面一步步的忘深处创建实例，那么肯定会遇到一个<code>type: &#39;div&#39;</code>的ReactElement，这个时候 <code>type</code> 就是string了</p><h3 id="node-type-string"><a href="#node-type-string" class="headerlink" title="node.type === string"></a>node.type === string</h3><p>那么当<code>node.type</code>是一个字符串的时候，会创建一个<code>ReactHostComponet</code>实例，这边和文本节点有所区别，这边调用的是<code>ReactHostComponet.createInternalComponent</code>方法，文本节点的话会调用<code>ReactHostComponet.createInstanceForText</code>下方会遇到。</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ReactHostComponent.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createInternalComponent</span><span class="params">(element)</span> </span>&#123;</span><br><span class="line">  !genericComponentClass <span class="comment">/**/</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> genericComponentClass(element);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数首先会判断<code>genericComponentClass</code>是否存在，而这个变量是函数外部闭包的一个变量，和之前一样是在全局依赖注入的时候完成了赋值。</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ReactHostComponentInjection = &#123;</span><br><span class="line">  <span class="comment">// This accepts a class that receives the tag string. This is a catch all</span></span><br><span class="line">  <span class="comment">// that can render any kind of tag.</span></span><br><span class="line">  injectGenericComponentClass: <span class="function"><span class="keyword">function</span> <span class="params">(componentClass)</span> </span>&#123;</span><br><span class="line">    genericComponentClass = componentClass;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// This accepts a text component class that takes the text string to be</span></span><br><span class="line">  <span class="comment">// rendered as props.</span></span><br><span class="line">  injectTextComponentClass: <span class="function"><span class="keyword">function</span> <span class="params">(componentClass)</span> </span>&#123;</span><br><span class="line">    textComponentClass = componentClass;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>那么回到<code>ReactDefaultInjection</code>继续查找这边注入的是什么</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">ReactInjection</span><span class="selector-class">.HostComponent</span><span class="selector-class">.injectGenericComponentClass</span>(<span class="selector-tag">ReactDOMComponent</span>);</span><br></pre></td></tr></table></figure><p>那么此时<code>genericComponentClass</code>就是这边传入的<code>ReactDOMComponent</code>，那么就是返回一个<code>ReactDOMComponent</code>实例</p><h3 id="isInternalComponentType-element-type"><a href="#isInternalComponentType-element-type" class="headerlink" title="isInternalComponentType(element.type)"></a>isInternalComponentType(element.type)</h3><p>检测 <code>node.type</code> 是不是内部组件类型</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isInternalComponentType</span>(<span class="params"><span class="keyword">type</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> <span class="keyword">type</span> === <span class="string">'function'</span> &amp;&amp; <span class="keyword">typeof</span> <span class="keyword">type</span>.prototype !== <span class="string">'undefined'</span> &amp;&amp; <span class="keyword">typeof</span> <span class="keyword">type</span>.prototype.mountComponent === <span class="string">'function'</span> &amp;&amp; <span class="keyword">typeof</span> <span class="keyword">type</span>.prototype.receiveComponent === <span class="string">'function'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果是内部的类型的化，那么就直接实例化传入的<code>node</code>，具体例子我还没有遇到过，就不做过多理解了，有例子的同学欢迎指教。</p><h3 id="node-type-不是上述类型"><a href="#node-type-不是上述类型" class="headerlink" title="node.type 不是上述类型"></a>node.type 不是上述类型</h3><p>其实这边的意思就是 <code>node.type</code> 是一个<code>function</code>，因为 <code>node.type</code> 只能是 <code>function</code> 或者 <code>string</code>。只不过逃过了上述<code>isInternalComponentType</code>函数的检测。<br>那么这边是创建的一个<code>ReactCompositeComponentWrapper</code>实例，这个构造函数是React的一大重点，根据我的四级英语翻译为 ‘ React复合类型 ‘ 他的本质是<code>ReactCompositeComponet</code>内部实现了React的组件生命周期，挂载卸载等操作。具体的后面会有很大一部分讲解他。这也是代码量可以说最大的几个文件之一了。</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这边是定义了一下这个构造函数，在该文件的最下面，对该构造函数的原型链添加了一系列的方法</span></span><br><span class="line"><span class="keyword">var</span> ReactCompositeComponentWrapper = <span class="function"><span class="keyword">function</span> <span class="params">(element)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.construct(element);</span><br><span class="line">  <span class="comment">// console.log(this);</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">_assign(ReactCompositeComponentWrapper.prototype, ReactCompositeComponent, &#123;</span><br><span class="line">  _instantiateReactComponent: instantiateReactComponent</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这边可以看出<code>ReactCompositeComponentWrapper</code>的主要操作都在<code>ReactCompositeComponent</code>文件里，而这边覆盖了一个<code>_instantiateReactComponent</code>属性，值为当前讲解的这个创建实例的函数<code>instantiateReactComponent</code></p><h2 id="node-为-string-number"><a href="#node-为-string-number" class="headerlink" title="node 为 string | number"></a>node 为 string | number</h2><p>当 node 为 string 或者 number 时，表明这是一个文本组件，对调用<code>ReactHostComponent.createInstanceForText</code>，那么加上当 node.type 为 string 时的讲解，可以看出<code>ReactHostComponent</code>组件描述的都是React中的文本组件。而<code>ReactHostComponent.createInstanceForText</code>方法引用的是外部闭包的<code>textComponentClass</code>，一样也是在全局依赖注入的时候赋值的。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ReactHostComponent.js</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;ReactText&#125; text</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;ReactComponent&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createInstanceForText</span><span class="params">(text)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> textComponentClass(text);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ReactDefaultInjection.js</span></span><br><span class="line">ReactInjection.HostComponent.injectTextComponentClass(ReactDOMTextComponent);</span><br></pre></td></tr></table></figure><p>那么本质就是创建一个 <code>ReactDOMTextComponent</code> 实例。</p><h2 id="node-不是上述类型"><a href="#node-不是上述类型" class="headerlink" title="node 不是上述类型"></a>node 不是上述类型</h2><p>这边不是上述类型，那么就报错了。</p><h2 id="新增-mountIndex-mountIage"><a href="#新增-mountIndex-mountIage" class="headerlink" title="新增 _mountIndex _mountIage"></a>新增 _mountIndex _mountIage</h2><p>在得到实例之后，会给<code>instance</code>添加两个额外的属性。根据官方给的英文注释，大致可以猜出这两个字段是用于 DOM 和 Diff 算法上的。React的Diff算法我也会写博客讲解，只不过得等这个渲染的一系列写完。React万岁！！！</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// These two fields are used by the DOM and ART diffing algorithms</span></span><br><span class="line"> <span class="comment">// respectively. Instead of using expandos on components, we should be</span></span><br><span class="line"> <span class="comment">// storing the state needed by the diffing algorithms elsewhere.</span></span><br><span class="line"> <span class="comment">// 这两个字段是 DOM 和 ART diff算法所需要的字段。我们应该在其他地方存储diff算法所需要的state，</span></span><br><span class="line"> <span class="comment">// 而不是在组件上扩展他</span></span><br><span class="line"> <span class="comment">// 这两个字段分别用于DOM和ART diffing算法。我们不应该在组件上使用expandos，而是应该存储其他不同算法所需的状态。</span></span><br><span class="line"> <span class="keyword">instance</span><span class="variable">._mountIndex</span> = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">instance</span><span class="variable">._mountIage</span> = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>instantiateReactComponent</code> 函数总体来说还是很简单的，只是根据 node 的类型 和 node.type 的类型创建一个实例，这边的代码还是可以理解的，不了解实例内部的那些方法的话难度还是可以接受的，难的地方还在后面，那么对该函数做一个流程图如下</p><p><img src="http://static.zybuluo.com/shenweizheng/952qn7bm5dhoaslh8a3v1vc1/image_1dlpdfmtm1os311vit91ndjjm.png" alt="image_1dlpdfmtm1os311vit91ndjjm.png-88.8kB"></p><blockquote><p>本片留坑</p><p>各个实例的内部属性、方法</p><p>坑总会填的，不急不急</p><p>下一篇讲解 ReactUpdates.js 这也是一个重点，博客是按照整个渲染的流程，部分重点文件会单独拉出来一篇进行理解。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;instantiateReactComponent 方法是React中的一个很重要的方法，主要作用是根据给定的node(ReactElement类型)对象，实例化出一个将被挂载的实例。实例化出的实例大体有三种，ReactEmptyComponent、ReactCompositeComponent、ReactHostComponent，其中ReactCompositeComponent是重点，内部包装了很多方法，而ReactHostComponent主要用来实例化文本组件实例。&lt;/p&gt;
&lt;p&gt;概述&lt;br&gt;Given a ReactNode, create an instance that will actually be mounted.&lt;br&gt;给一个ReactNode 指的是 ReactElement 对象，根据该对象创建一个实际要挂载的实例&lt;/p&gt;
&lt;p&gt;大致流程&lt;br&gt;判断 node 的类型以及 node.type 的类型，根据不同的类型创建不同的实例&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="js" scheme="http://shenweini.cn/tags/js/"/>
    
      <category term="react" scheme="http://shenweini.cn/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>React@15.6.2源码解析---从 ReactDOM.render 到页面渲染（1）ReactMount</title>
    <link href="http://shenweini.cn/2019/09/26/React@15.6.2%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90---%E4%BB%8E%20ReactDOM.render%20%E5%88%B0%E9%A1%B5%E9%9D%A2%E6%B8%B2%E6%9F%93%EF%BC%881%EF%BC%89ReactMount/"/>
    <id>http://shenweini.cn/2019/09/26/React@15.6.2源码解析---从 ReactDOM.render 到页面渲染（1）ReactMount/</id>
    <published>2019-09-26T03:08:03.938Z</published>
    <updated>2019-09-26T03:08:03.938Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>之前介绍了React16.8版本的React公用API，本着学习最新版的React的想法，但是败在了Fiber的阵下，还有回过头来写搞明白React15的源码，毕竟从15到16是一次重大的更新。本文中React源码版本为 15.6.2 ，望各位看官找准版本号，不同的版本还是有着细微的区别的</p><p>值得一提的是，在阅读源码时，在Chrome中打断点是一个很好的操作，可以了解到函数的调用栈，变量的值，一步一步的调试还可以了解整个执行的流程，一边调试一边记录着流程一边在加以理解一边感慨这神乎其技的封装。</p><p>博客会同步到github上，这样也算是有了开源的项目。欢迎各位看官指教！</p></blockquote><a id="more"></a><h2 id="准备步骤"><a href="#准备步骤" class="headerlink" title="准备步骤"></a>准备步骤</h2><p>首先需要安装 <a href="mailto:`React@15.6.2" target="_blank" rel="noopener">`React@15.6.2</a>， <a href="mailto:ReactDOM@15.6.2" target="_blank" rel="noopener">ReactDOM@15.6.2</a><code>，其次搭建webpack打包，因为必不可少的需要</code>console.log<code>啥的，另外需要</code>babel<code>的配置，</code>babel6 babel7<code>倒是无所谓，关键是可以解析我们的</code>jsx`语法。</p><p>示例代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDom <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">        <span class="keyword">super</span>(props);</span><br><span class="line">        <span class="keyword">this</span>.state = &#123;</span><br><span class="line">            name: <span class="string">'Hello World'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    componentWillMount() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'component will mount'</span>);</span><br><span class="line">        <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">            name: <span class="string">'Hello CHina'</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    componentDidMount() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'component did mount'</span>);</span><br><span class="line">        <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">            name: <span class="string">'Hello CHange'</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    componentWillReceiveProps(nextProps) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'component will receive props'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    componentWillUpdate(nextProps, nextState) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'component will updates'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    componentDidUpdate(prevProps, prevState)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'component Did Update'</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'render'</span>);</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &#123; <span class="keyword">this</span>.state.name &#125;</span><br><span class="line">            &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        )</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDom.render(</span></span><br><span class="line"><span class="regexp">    &lt;App&gt;</span></span><br><span class="line"><span class="regexp">        &lt;div&gt;Hello World&lt;/</span>div&gt;</span><br><span class="line">    &lt;<span class="regexp">/App&gt;,</span></span><br><span class="line"><span class="regexp">    document.getElementById('root')</span></span><br><span class="line"><span class="regexp">);</span></span><br></pre></td></tr></table></figure><p>本片博客就是基于该代码进行调试的，将这段代码使用<code>babel</code>转码之后的结果为</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主要代码段</span></span><br><span class="line"><span class="keyword">var</span> App =</span><br><span class="line">  <span class="comment">/*#__PURE__*/</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">_React$Component</span>) </span>&#123;</span><br><span class="line">    _inherits(App, _React$Component);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> _this;</span><br><span class="line"></span><br><span class="line">      _classCallCheck(<span class="keyword">this</span>, App);</span><br><span class="line"></span><br><span class="line">      _this = _possibleConstructorReturn(<span class="keyword">this</span>, _getPrototypeOf(App).call(<span class="keyword">this</span>, props));</span><br><span class="line">      _this.state = &#123;</span><br><span class="line">        name: <span class="string">'Hello World'</span></span><br><span class="line">      &#125;;</span><br><span class="line">      <span class="keyword">return</span> _this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _createClass(App, [&#123;</span><br><span class="line">      key: <span class="string">"componentWillMount"</span>,</span><br><span class="line">      value: <span class="function"><span class="keyword">function</span> <span class="title">componentWillMount</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'component will mount'</span>);</span><br><span class="line">        <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">          name: <span class="string">'Hello CHina'</span></span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, &#123;</span><br><span class="line">      key: <span class="string">"componentDidMount"</span>,</span><br><span class="line">      value: <span class="function"><span class="keyword">function</span> <span class="title">componentDidMount</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'component did mount'</span>);</span><br><span class="line">        <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">          name: <span class="string">'Hello CHange'</span></span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, &#123;</span><br><span class="line">      key: <span class="string">"componentWillReceiveProps"</span>,</span><br><span class="line">      value: <span class="function"><span class="keyword">function</span> <span class="title">componentWillReceiveProps</span>(<span class="params">nextProps</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'component will receive props'</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, &#123;</span><br><span class="line">      key: <span class="string">"componentWillUpdate"</span>,</span><br><span class="line">      value: <span class="function"><span class="keyword">function</span> <span class="title">componentWillUpdate</span>(<span class="params">nextProps, nextState</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'component will updates'</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, &#123;</span><br><span class="line">      key: <span class="string">"componentDidUpdate"</span>,</span><br><span class="line">      value: <span class="function"><span class="keyword">function</span> <span class="title">componentDidUpdate</span>(<span class="params">prevProps, prevState</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'component Did Update'</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, &#123;</span><br><span class="line">      key: <span class="string">"render"</span>,</span><br><span class="line">      value: <span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'render'</span>);</span><br><span class="line">        <span class="keyword">return</span> _react[<span class="string">"default"</span>].createElement(<span class="string">"div"</span>, <span class="literal">null</span>, <span class="keyword">this</span>.state.name);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> App;</span><br><span class="line">  &#125;(_react[<span class="string">"default"</span>].Component);</span><br><span class="line"></span><br><span class="line">;</span><br><span class="line"></span><br><span class="line">_reactDom[<span class="string">"default"</span>].render(_react[<span class="string">"default"</span>].createElement(App, <span class="literal">null</span>, _react[<span class="string">"default"</span>].createElement(<span class="string">"div"</span>, <span class="literal">null</span>, <span class="string">"Hello World"</span>)), <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>));</span><br></pre></td></tr></table></figure><p>一个立即执行函数，返回一个名为<code>App</code>的构造函数，内部的<code>componentWillMount</code> <code>render</code>等方法，等会通过<code>Object.defineProperty</code>方法添加到<code>App</code>的原型链中。之后使用<code>React.createElement</code>将<code>App</code>转换为<code>ReactElement</code>对象传入到<code>ReactDOM.render</code>中</p><blockquote><p>看源码需要扎实的Js基础，原型链、闭包、this指向、模块化、Object.defineProperty等常用的方法都是必须提前掌握的。</p></blockquote><h2 id="ReactDOM-render"><a href="#ReactDOM-render" class="headerlink" title="ReactDOM.render"></a>ReactDOM.render</h2><p>在引入<code>ReactDOM.js</code>文件的时候，从上往下仔细看会发现有这么一行代码是在引入的时候被执行了<code>ReactDefaultInjection.inject();</code>，这个<code>ReactDefaultInjection</code>调用了其内部的一个<code>inject</code>方法，主要目的是进行一次全局的依赖注入，本博主一开始光注意着研究<code>ReactDOM.render</code>了，漏了这一句，导致后面有的东西很迷，所以在这提个醒，在引入一个文件时，文件内部有的函数是没有被导出的反而是在引入文件时直接执行的。这个<code>inject</code>具体的代码后面用到时会进行详细的介绍。</p><p>下面就是<code>ReactDOM</code>文件的代码了</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 各种文件的引入 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行依赖注入</span></span><br><span class="line">ReactDefaultInjection.inject();</span><br><span class="line"></span><br><span class="line"><span class="comment">// ReactDOM对象</span></span><br><span class="line">var ReactDOM = &#123;</span><br><span class="line"><span class="symbol">  findDOMNode:</span> findDOMNode,</span><br><span class="line"><span class="symbol">  render:</span> ReactMount.render,</span><br><span class="line"><span class="symbol">  unmountComponentAtNode:</span> ReactMount.unmountComponentAtNode,</span><br><span class="line"><span class="symbol">  version:</span> ReactVersion,</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* eslint-disable camelcase */</span></span><br><span class="line"><span class="symbol">  unstable_batchedUpdates:</span> ReactUpdates.batchedUpdates,</span><br><span class="line"><span class="symbol">  unstable_renderSubtreeIntoContainer:</span> renderSubtreeIntoContainer</span><br><span class="line">  <span class="comment">/* eslint-enable camelcase */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 杂七杂八的东西 */</span></span><br></pre></td></tr></table></figure><p>那么实质上<code>ReactDOM.render</code>方法就是<code>ReactMount.render</code>方法，<code>ReactMount</code>文件可以说是render的入口了，是一个极其重要的文件。当然<code>ReactDOM</code>两万多行代码，重要的文件一大堆。。。。</p><h2 id="ReactMount"><a href="#ReactMount" class="headerlink" title="ReactMount"></a>ReactMount</h2><p>还是一样的，从上往下看仔细看，不要去找关键词<code>ReactMount</code>，一旦找关键词会错过很多细节。一旦错过了那么导致的结局就是卧槽，这个东西什么时候被赋值了，卧槽，这个属性哪里来的尴尬局面。所以再一次强调，打断点的好处。Chrome断点，🧱</p><p>那么你会发现，有这么一个构造函数</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Temporary (?) hack so that we can store all top-level pending updates on</span></span><br><span class="line"><span class="comment"> * composites instead of having to worry about different types of components</span></span><br><span class="line"><span class="comment"> * here.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> topLevelRootCounter = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> TopLevelWrapper = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.rootID = topLevelRootCounter++;</span><br><span class="line">&#125;;</span><br><span class="line">TopLevelWrapper.prototype.isReactComponent = &#123;&#125;;</span><br><span class="line"><span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">  TopLevelWrapper.displayName = <span class="string">'TopLevelWrapper'</span>;</span><br><span class="line">&#125;</span><br><span class="line">TopLevelWrapper.prototype.render = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.props.child;</span><br><span class="line">&#125;;</span><br><span class="line">TopLevelWrapper.isReactTopLevelWrapper = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><p>这个<code>TopLevelWrapper</code>就是整个组件的最顶层，我们调用<code>ReactDOM.render</code>时，传递的参数被这个构造函数给包裹起来。</p><figure class="highlight puppet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// ReactMount.js</span><br><span class="line"></span><br><span class="line"> /**</span><br><span class="line">   *</span><br><span class="line">   * @<span class="keyword">param</span> &#123;ReactElement&#125; <span class="keyword">nextElement</span> <span class="keyword">Component</span> <span class="keyword">element</span> <span class="keyword">to</span> <span class="keyword">render</span>.</span><br><span class="line">   * @<span class="keyword">param</span> &#123;DOMElement&#125; <span class="keyword">container</span> <span class="keyword">DOM</span> <span class="keyword">element</span> <span class="keyword">to</span> <span class="keyword">render</span> <span class="keyword">into</span>.</span><br><span class="line">   * @<span class="keyword">param</span> &#123;?function&#125; <span class="keyword">callback</span> <span class="keyword">function</span> <span class="keyword">triggered</span> <span class="keyword">on</span> <span class="keyword">completion</span></span><br><span class="line">   * @<span class="keyword">return</span> &#123;ReactComponent&#125; <span class="keyword">Component</span> <span class="keyword">instance</span> <span class="keyword">rendered</span> <span class="keyword">in</span> `container`.</span><br><span class="line">   */</span><br><span class="line">render: function (nextElement, container, callback) &#123;</span><br><span class="line">    return ReactMount._renderSubtreeIntoContainer(null, nextElement, container, callback);</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><blockquote><p>参数说明</p><p>nextElement: 这是React.createElement(App, null, React.createElement(“div”, null, “Hello World”)))的结果，babel在解析jsx时，会调用React.createElement将我们写的组件变成一个 ReactElement</p><p>container: ReactDOM.render 的第二个参数，所需要挂载的节点，document.getElementById(‘root’)</p><p>callback: 可选的回调函数，第三个参数</p></blockquote><p>内部就一句话，关键代码还是<code>ReactMount._renderSubtreeIntoContainer</code>函数</p><h3 id="ReactMount-renderSubtreeIntoContainer"><a href="#ReactMount-renderSubtreeIntoContainer" class="headerlink" title="ReactMount._renderSubtreeIntoContainer"></a>ReactMount._renderSubtreeIntoContainer</h3><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ReactMount.js</span></span><br><span class="line"></span><br><span class="line">_renderSubtreeIntoContainer: <span class="function"><span class="keyword">function</span> <span class="params">(parentComponent, nextElement, container, callback)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 校验 callback</span></span><br><span class="line">    ReactUpdateQueue.validateCallback(callback, <span class="string">'ReactDOM.render'</span>);</span><br><span class="line">    !React.isValidElement(nextElement) ? <span class="comment">/**/</span></span><br><span class="line">    nextElement != <span class="literal">null</span> &amp;&amp; nextElement.props !== <span class="literal">undefined</span> ? <span class="comment">/**/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**/</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> nextWrappedElement = React.createElement(TopLevelWrapper, &#123;</span><br><span class="line">      child: nextElement</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">var</span> nextContext;</span><br><span class="line">    <span class="keyword">if</span> (parentComponent) &#123;</span><br><span class="line">      <span class="keyword">var</span> parentInst = ReactInstanceMap.get(parentComponent);</span><br><span class="line">      nextContext = parentInst._processChildContext(parentInst._context);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      nextContext = emptyObject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> prevComponent = getTopLevelWrapperInContainer(container);</span><br><span class="line">    <span class="keyword">if</span> (prevComponent) &#123;</span><br><span class="line">      <span class="keyword">var</span> prevWrappedElement = prevComponent._currentElement;</span><br><span class="line">      <span class="keyword">var</span> prevElement = prevWrappedElement.props.child;</span><br><span class="line">      <span class="keyword">if</span> (shouldUpdateReactComponent(prevElement, nextElement)) &#123;</span><br><span class="line">        <span class="keyword">var</span> publicInst = prevComponent._renderedComponent.getPublicInstance();</span><br><span class="line">        <span class="keyword">var</span> updatedCallback = callback &amp;&amp; <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">          callback.call(publicInst);</span><br><span class="line">        &#125;;</span><br><span class="line">        ReactMount._updateRootComponent(prevComponent, nextWrappedElement, nextContext, container, updatedCallback);</span><br><span class="line">        <span class="keyword">return</span> publicInst;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ReactMount.unmountComponentAtNode(container);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> reactRootElement = getReactRootElementInContainer(container);</span><br><span class="line">    <span class="keyword">var</span> containerHasReactMarkup = reactRootElement &amp;&amp; !!internalGetID(reactRootElement); <span class="comment">// false</span></span><br><span class="line">    <span class="comment">// 如果DOM元素包含一个由React呈现但不是根元素R的直接子元素，则为True。</span></span><br><span class="line">    <span class="keyword">var</span> containerHasNonRootReactChild = hasNonRootReactChild(container); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">      <span class="comment">/**/</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> shouldReuseMarkup = containerHasReactMarkup &amp;&amp; !prevComponent &amp;&amp; !containerHasNonRootReactChild; <span class="comment">// false</span></span><br><span class="line">    <span class="keyword">var</span> component = ReactMount._renderNewRootComponent(nextWrappedElement, container, shouldReuseMarkup, nextContext)._renderedComponent.getPublicInstance();</span><br><span class="line">    <span class="keyword">if</span> (callback) &#123;</span><br><span class="line">      callback.call(component);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> component;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><blockquote><p>参数<br><img src="http://static.zybuluo.com/shenweizheng/fg9uz154qldzeksr8jk0tzgr/image_1dlk722i093bbvvosn8gm1h6pp.png" alt="image_1dlk722i093bbvvosn8gm1h6pp.png-74.5kB"></p></blockquote><p>流程：<br>首先检查<code>callback</code> <code>nextElement</code>是否是合法的，判断一下类型啥的，然后会使用React.createElement创建一个<code>type</code>为<code>TopLevelWrapper</code>的<code>ReactElement</code></p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">var nextWrappedElement</span> = React.createElement(TopLevelWrapper, &#123;</span><br><span class="line">    child: nextElement</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>我们传入的nextElement会变成<code>nextWrapperElement</code>的一个<code>props</code>;</p><p><img src="http://static.zybuluo.com/shenweizheng/5svn7431hrt48zcqh34q2otd/image_1dlk7bg5l1vbf1d1dhbteq8f0d16.png" alt="image_1dlk7bg5l1vbf1d1dhbteq8f0d16.png-50.2kB"></p><p>之后对<code>parentComponent</code>是否存在进行判断并对<code>nextContext</code>赋值，当前为空赋值为一个空对象<code>emptyObject</code></p><p>调用<code>getTopLevelWrapperInContainer(container)</code>方法，这个方法主要是检查容器内部是否已经存在一个有ReactDOM直接渲染的节点，当前是无，我们的容器内部是空的</p><p>再往下执行<code>var reactRootElement = getReactRootElementInContainer(container);</code></p><p><strong>getReactRootElementInContainer</strong></p><figure class="highlight puppet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @<span class="keyword">param</span> &#123;DOMElement|DOMDocument&#125; <span class="keyword">container</span> <span class="keyword">DOM</span> <span class="keyword">element</span> <span class="keyword">that</span> <span class="keyword">may</span> <span class="keyword">contain</span></span><br><span class="line"> * a React component</span><br><span class="line"> * @<span class="keyword">return</span> &#123;?*&#125; <span class="keyword">DOM</span> <span class="keyword">element</span> <span class="keyword">that</span> <span class="keyword">may</span> <span class="keyword">have</span> <span class="keyword">the</span> <span class="keyword">reactRoot</span> <span class="keyword">ID</span>, or null.</span><br><span class="line"> */</span><br><span class="line">function getReactRootElementInContainer(container) &#123;</span><br><span class="line">  if (!container) &#123;</span><br><span class="line">    return null;</span><br><span class="line">  &#125;</span><br><span class="line">  // DOC_NODE_TYPE = 9</span><br><span class="line">  if (container.nodeType === DOC_NODE_TYPE) &#123;</span><br><span class="line">    return container.documentElement;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    return container.firstChild;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对container.nodeType做判断，<code>nodeType</code>是html节点的一个属性，nodeType = 9 的话表明当前container是document节点，不是话返回内部的第一个子节点</p><p>接下来执行<code>var containerHasReactMarkup = reactRootElement &amp;&amp; !!internalGetID(reactRootElement);</code></p><p>这个标记变量<code>containerHasReactMarkup</code> 用来判断当前container是否具有React标记，当前值为 false</p><p>下一个<code>var containerHasNonRootReactChild = hasNonRootReactChild(container);</code>如果DOM元素包含一个由React呈现但不是根元素R的直接子元素，则为True。当前为 false</p><p>下面根据以上的几个变量得出一个标记变量<code>shouldReuseMarkup</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">var</span> <span class="string">shouldReuseMarkup</span> <span class="string">=</span> <span class="string">containerHasReactMarkup</span> <span class="string">&amp;&amp;</span> <span class="type">!prevComponent</span> <span class="string">&amp;&amp;</span> <span class="type">!containerHasNonRootReactChild</span><span class="string">;</span> <span class="string">//</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>下面就是该函数的核心了</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> component = ReactMount._renderNewRootComponent(nextWrappedElement, container, shouldReuseMarkup, nextContext)._renderedComponent.getPublicInstance();</span><br><span class="line">   <span class="keyword">if</span> (callback) &#123;</span><br><span class="line">     callback.call(component);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> component;</span><br></pre></td></tr></table></figure><p>执行<code>ReactMount._renderNewRootComponent()._renderedComponent.getPublicInstance()</code>函数并将返回值返回出来，如果传入了<code>callback</code>的话，在return之前在调用一下callback。</p><p>那么先看<code>ReactMount._renderNewRootComponent()</code>方法</p><h3 id="ReactMount-renderNewRootComponent"><a href="#ReactMount-renderNewRootComponent" class="headerlink" title="ReactMount._renderNewRootComponent"></a>ReactMount._renderNewRootComponent</h3><p>传入的参数为<br><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">nextWrappedElement</span>: nextWrappedElement // 对 TopLevelWrapper调用React.createElement的结果</span><br><span class="line"></span><br><span class="line"><span class="attribute">container</span>: document.getElementById('root')</span><br><span class="line"></span><br><span class="line"><span class="attribute">shouldReuseMarkup</span>: false</span><br><span class="line"></span><br><span class="line"><span class="attribute">nextContext</span>: &#123;&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">_renderNewRootComponent: <span class="function"><span class="keyword">function</span> <span class="params">(nextElement, container, shouldReuseMarkup, context)</span> </span>&#123;</span><br><span class="line">   process.env.NODE_ENV !== <span class="string">'production'</span> <span class="comment">/**/</span></span><br><span class="line"></span><br><span class="line">   !isValidContainer(container) <span class="comment">/**/</span></span><br><span class="line">   ReactBrowserEventEmitter.ensureScrollValueMonitoring();</span><br><span class="line">   <span class="keyword">var</span> componentInstance = instantiateReactComponent(nextElement, <span class="literal">false</span>);</span><br><span class="line">   <span class="comment">// 初始render是同步的，但是在render期间发生的任何更新，在componentWillMount或componentDidMount中，都将根据当前的批处理策略进行批处理。</span></span><br><span class="line">   ReactUpdates.batchedUpdates(batchedMountComponentIntoNode, componentInstance, container, shouldReuseMarkup, context);</span><br><span class="line">   <span class="keyword">var</span> wrapperID = componentInstance._instance.rootID;</span><br><span class="line">   instancesByReactRootID[wrapperID] = componentInstance;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> componentInstance;</span><br><span class="line"> &#125;,</span><br></pre></td></tr></table></figure><p>流程如下：</p><p>对 container 进行验证</p><p>调用<code>ReactBrowserEventEmitter.ensureScrollValueMonitoring()</code> 确保监听浏览器滚动，在React15中渲染时应该是不会管页面中高性能事件的，所以在React16中引入的fiber架构。</p><p>调用<code>instantiateReactComponent</code>方法实例化一个ReactComponent，这个方法也是ReactDOM的一个重点，在下篇会说</p><p>调用<code>ReactUpdates.batchedUpdates();</code>开始执行批量更新，这当中会用到一开始注入的<code>ReactDefaultBatchingStrategy</code></p><p>外部存储一下当前实例<code>instancesByReactRootID[wrapperID] = componentInstance</code>，对象<code>instancesByReactRootID</code>外部闭包的一个Object，key值为实例的rootID,value值为当前实例化出来的实例</p><p>最后return出这个实例。</p><blockquote><p>当前流程图</p></blockquote><p><img src="http://static.zybuluo.com/shenweizheng/8x9ovvg1sxdb2gexbjrvi10m/image_1dllogis11e54igc14j21hjq4ov1j.png" alt="image_1dllogis11e54igc14j21hjq4ov1j.png-58.4kB"></p><blockquote><p>本篇留坑</p><ol><li><p>instantiateReactComponent方法</p></li><li><p>ReactUpdates 文件</p></li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;之前介绍了React16.8版本的React公用API，本着学习最新版的React的想法，但是败在了Fiber的阵下，还有回过头来写搞明白React15的源码，毕竟从15到16是一次重大的更新。本文中React源码版本为 15.6.2 ，望各位看官找准版本号，不同的版本还是有着细微的区别的&lt;/p&gt;
&lt;p&gt;值得一提的是，在阅读源码时，在Chrome中打断点是一个很好的操作，可以了解到函数的调用栈，变量的值，一步一步的调试还可以了解整个执行的流程，一边调试一边记录着流程一边在加以理解一边感慨这神乎其技的封装。&lt;/p&gt;
&lt;p&gt;博客会同步到github上，这样也算是有了开源的项目。欢迎各位看官指教！&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="js" scheme="http://shenweini.cn/tags/js/"/>
    
      <category term="react" scheme="http://shenweini.cn/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>React源码解析----createElement + Component + PureComponent</title>
    <link href="http://shenweini.cn/2019/09/17/React%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90----createElement%20+%20Component%20+%20PureComponent/"/>
    <id>http://shenweini.cn/2019/09/17/React源码解析----createElement + Component + PureComponent/</id>
    <published>2019-09-17T08:49:35.050Z</published>
    <updated>2019-09-18T02:11:17.161Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>上一篇介绍了React的Api，今天介绍createElement和React的Component相关操作。看了很多其他人的博客，对于React16的fiber架构还是无法了解，尽管我知道他很牛逼。发现了解React的源码还是需要从渲染开始进行了解，明白从一个组件到挂载再到响应式的所有操作。</p></blockquote><p>首先先写一个简单的React组件<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="type">React</span> from <span class="symbol">'reac</span>t';</span><br><span class="line"><span class="keyword">import</span> <span class="type">ReactDom</span> from <span class="symbol">'react</span>-dom';</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    constructor(props) &#123;</span><br><span class="line">        <span class="keyword">super</span>(props);</span><br><span class="line">        <span class="keyword">this</span>.state = &#123;</span><br><span class="line">            name: <span class="symbol">'Hello</span> <span class="type">World</span>'</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    componentDidMount() &#123;</span><br><span class="line">        console.log(<span class="symbol">'component</span> did mount');</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &#123; <span class="keyword">this</span>.state.name &#125;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">ReactDom</span>.render(</span><br><span class="line">    &lt;<span class="type">App</span> /&gt;,</span><br><span class="line">    document.getElementById(<span class="symbol">'roo</span>t')</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p><p>使用<code>babel</code>编译这个<code>jsx</code>文件</p><a id="more"></a><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> _react = _interopRequireDefault(<span class="built_in">require</span>(<span class="string">"react"</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> _reactDom = _interopRequireDefault(<span class="built_in">require</span>(<span class="string">"react-dom"</span>));</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_interopRequireDefault</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> obj &amp;&amp; obj.__esModule ? obj : &#123;</span><br><span class="line">        <span class="string">"default"</span>: obj</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_typeof</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">Symbol</span> === <span class="string">"function"</span> &amp;&amp; <span class="keyword">typeof</span> <span class="built_in">Symbol</span>.iterator === <span class="string">"symbol"</span>) &#123;</span><br><span class="line">        _typeof = <span class="function"><span class="keyword">function</span> <span class="title">_typeof</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">typeof</span> obj;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        _typeof = <span class="function"><span class="keyword">function</span> <span class="title">_typeof</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> obj &amp;&amp; <span class="keyword">typeof</span> <span class="built_in">Symbol</span> === <span class="string">"function"</span> &amp;&amp; obj.constructor === <span class="built_in">Symbol</span> &amp;&amp; obj !== <span class="built_in">Symbol</span>.prototype ? <span class="string">"symbol"</span> : <span class="keyword">typeof</span> obj;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _typeof(obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_classCallCheck</span>(<span class="params">instance, Constructor</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!(instance <span class="keyword">instanceof</span> Constructor)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">"Cannot call a class as a function"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_defineProperties</span>(<span class="params">target, props</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; props.length; i++) &#123;</span><br><span class="line">        <span class="keyword">var</span> descriptor = props[i];</span><br><span class="line">        descriptor.enumerable = descriptor.enumerable || <span class="literal">false</span>;</span><br><span class="line">        descriptor.configurable = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"value"</span> <span class="keyword">in</span> descriptor) descriptor.writable = <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">Object</span>.defineProperty(target, descriptor.key, descriptor);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_createClass</span>(<span class="params">Constructor, protoProps, staticProps</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (protoProps) _defineProperties(Constructor.prototype, protoProps);</span><br><span class="line">    <span class="keyword">if</span> (staticProps) _defineProperties(Constructor, staticProps);</span><br><span class="line">    <span class="keyword">return</span> Constructor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_possibleConstructorReturn</span>(<span class="params">self, call</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (call &amp;&amp; (_typeof(call) === <span class="string">"object"</span> || <span class="keyword">typeof</span> call === <span class="string">"function"</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> call;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _assertThisInitialized(self);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_assertThisInitialized</span>(<span class="params">self</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (self === <span class="keyword">void</span> <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">ReferenceError</span>(<span class="string">"this hasn't been initialised - super() hasn't been called"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_getPrototypeOf</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">    _getPrototypeOf = <span class="built_in">Object</span>.setPrototypeOf ? <span class="built_in">Object</span>.getPrototypeOf : <span class="function"><span class="keyword">function</span> <span class="title">_getPrototypeOf</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> o.__proto__ || <span class="built_in">Object</span>.getPrototypeOf(o);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> _getPrototypeOf(o);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_inherits</span>(<span class="params">subClass, superClass</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> superClass !== <span class="string">"function"</span> &amp;&amp; superClass !== <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">"Super expression must either be null or a function"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    subClass.prototype = <span class="built_in">Object</span>.create(superClass &amp;&amp; superClass.prototype, &#123;</span><br><span class="line">        <span class="keyword">constructor</span>: &#123;</span><br><span class="line">            value: subClass,</span><br><span class="line">            writable: <span class="literal">true</span>,</span><br><span class="line">            configurable: <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">if</span> (superClass) _setPrototypeOf(subClass, superClass);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_setPrototypeOf</span>(<span class="params">o, p</span>) </span>&#123;</span><br><span class="line">    _setPrototypeOf = <span class="built_in">Object</span>.setPrototypeOf || <span class="function"><span class="keyword">function</span> <span class="title">_setPrototypeOf</span>(<span class="params">o, p</span>) </span>&#123;</span><br><span class="line">        o.__proto__ = p;</span><br><span class="line">        <span class="keyword">return</span> o;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> _setPrototypeOf(o, p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> App =</span><br><span class="line">    <span class="comment">/*#__PURE__*/</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> (<span class="params">_React$Component</span>) </span>&#123;</span><br><span class="line">        _inherits(App, _React$Component);</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> _this;</span><br><span class="line"></span><br><span class="line">            _classCallCheck(<span class="keyword">this</span>, App);</span><br><span class="line"></span><br><span class="line">            _this = _possibleConstructorReturn(<span class="keyword">this</span>, _getPrototypeOf(App).call(<span class="keyword">this</span>, props));</span><br><span class="line">            _this.state = &#123;</span><br><span class="line">                name: <span class="string">'Hello World'</span></span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">return</span> _this;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        _createClass(App, [&#123;</span><br><span class="line">            key: <span class="string">"componentDidMount"</span>,</span><br><span class="line">            value: <span class="function"><span class="keyword">function</span> <span class="title">componentDidMount</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">'component did mount'</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, &#123;</span><br><span class="line">            key: <span class="string">"render"</span>,</span><br><span class="line">            value: <span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> _react[<span class="string">"default"</span>].createElement(<span class="string">"div"</span>, <span class="literal">null</span>, <span class="keyword">this</span>.state.name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> App;</span><br><span class="line">    &#125;(_react[<span class="string">"default"</span>].Component);</span><br><span class="line"></span><br><span class="line">;</span><br><span class="line"></span><br><span class="line">_reactDom[<span class="string">"default"</span>].render(_react[<span class="string">"default"</span>].createElement(App, <span class="literal">null</span>), <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>));</span><br></pre></td></tr></table></figure><p>主要是 <code>var App</code> 开始的东西，可以看出这是一个立即执行函数，函数的参数是<code>React.Componnet</code>，函数内部写了一个名为<code>App</code>的构造函数，最后返回出这个构造函数。</p><p>其中的<code>_inherits(App, _React$Component);</code>这个函数是<code>babel</code>自行封装的继承。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">_createClass(App, [&#123;</span><br><span class="line">    key: <span class="string">"componentDidMount"</span>,</span><br><span class="line">    value: <span class="function"><span class="keyword">function</span> <span class="title">componentDidMount</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'component did mount'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, &#123;</span><br><span class="line">    key: <span class="string">"render"</span>,</span><br><span class="line">    value: <span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _react[<span class="string">"default"</span>].createElement(<span class="string">"div"</span>, <span class="literal">null</span>, <span class="keyword">this</span>.state.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;]);</span><br></pre></td></tr></table></figure><p>这个函数的作用是将第二个参数那个数组中的东西一个一个添加到构造<code>App</code>构造函数的原型链上。</p><p>最后调用<code>ReactDOM</code>的<code>render</code>方法，可以看出这其中的第一个参数是调用了<code>React.createElement</code>方法，包括在App组件中的render也是调用了这个函数。那么重点来了，看一下这个<code>React.createElement</code>方法</p><h2 id="React-createElement"><a href="#React-createElement" class="headerlink" title="React.createElement"></a>React.createElement</h2><p>大家都知道，React中的一个关键词就是<code>jsx</code>，babel在解析jsx语法时，就会调用<code>React.createElement</code>方法将jsx转换为一个<code>ReactElement</code>对象。在源码<code>/packages/react/src/ReactElement.js</code>文件中。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Create and return a new ReactElement of the given type.</span></span><br><span class="line"><span class="comment"> * See https://reactjs.org/docs/react-api.html#createelement</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> createElement(<span class="keyword">type</span>, <span class="keyword">config</span>, children) &#123;</span><br><span class="line">  <span class="keyword">let</span> propName;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Reserved names are extracted</span></span><br><span class="line">  <span class="keyword">const</span> props = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> key = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">let</span> <span class="keyword">ref</span> = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">let</span> self = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">let</span> source = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将 config 中的配置添加到 props 中</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">config</span> != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (hasValidRef(<span class="keyword">config</span>)) &#123;</span><br><span class="line">      <span class="keyword">ref</span> = <span class="keyword">config</span><span class="variable">.ref</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (hasValidKey(<span class="keyword">config</span>)) &#123;</span><br><span class="line">      key = '' + <span class="keyword">config</span><span class="variable">.key</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    self = <span class="keyword">config</span><span class="variable">.__self</span> === undefined ? <span class="literal">null</span> : <span class="keyword">config</span><span class="variable">.__self</span>;</span><br><span class="line">    source = <span class="keyword">config</span><span class="variable">.__source</span> === undefined ? <span class="literal">null</span> : <span class="keyword">config</span><span class="variable">.__source</span>;</span><br><span class="line">    <span class="comment">// Remaining properties are added to a new props object</span></span><br><span class="line">    <span class="keyword">for</span> (propName in <span class="keyword">config</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (</span><br><span class="line">        hasOwnProperty<span class="variable">.call</span>(<span class="keyword">config</span>, propName) &amp;&amp;</span><br><span class="line">        !RESERVED_PROPS<span class="variable">.hasOwnProperty</span>(propName)</span><br><span class="line">      ) &#123;</span><br><span class="line">        props[propName] = <span class="keyword">config</span>[propName];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 添加子节点</span></span><br><span class="line">  <span class="comment">// Children can be more than one argument, and those are transferred onto</span></span><br><span class="line">  <span class="comment">// the newly allocated props object.</span></span><br><span class="line">  <span class="keyword">const</span> childrenLength = arguments<span class="variable">.length</span> - <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">if</span> (childrenLength === <span class="number">1</span>) &#123;</span><br><span class="line">    props<span class="variable">.children</span> = children;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childrenLength &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> childArray = Array(childrenLength);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; childrenLength; i++) &#123;</span><br><span class="line">      childArray[i] = arguments[i + <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">__</span>DEV__) &#123;</span><br><span class="line">      <span class="keyword">if</span> (Object<span class="variable">.freeze</span>) &#123;</span><br><span class="line">        Object<span class="variable">.freeze</span>(childArray);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    props<span class="variable">.children</span> = childArray;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Resolve default props</span></span><br><span class="line">  <span class="comment">// 添加默认的props</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">type</span> &amp;&amp; <span class="keyword">type</span><span class="variable">.defaultProps</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> defaultProps = <span class="keyword">type</span><span class="variable">.defaultProps</span>;</span><br><span class="line">    <span class="keyword">for</span> (propName in defaultProps) &#123;</span><br><span class="line">      <span class="keyword">if</span> (props[propName] === undefined) &#123;</span><br><span class="line">        props[propName] = defaultProps[propName];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="number">__</span>DEV__) &#123;</span><br><span class="line">    <span class="comment">/**/</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ReactElement(</span><br><span class="line">    <span class="keyword">type</span>,</span><br><span class="line">    key,</span><br><span class="line">    <span class="keyword">ref</span>,</span><br><span class="line">    self,</span><br><span class="line">    source,</span><br><span class="line">    ReactCurrentOwner<span class="variable">.current</span>,</span><br><span class="line">    props,</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">config</span> != <span class="literal">null</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (hasValidRef(<span class="keyword">config</span>)) &#123;</span><br><span class="line">    <span class="keyword">ref</span> = <span class="keyword">config</span><span class="variable">.ref</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (hasValidKey(<span class="keyword">config</span>)) &#123;</span><br><span class="line">    key = '' + <span class="keyword">config</span><span class="variable">.key</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  self = <span class="keyword">config</span><span class="variable">.__self</span> === undefined ? <span class="literal">null</span> : <span class="keyword">config</span><span class="variable">.__self</span>;</span><br><span class="line">  source = <span class="keyword">config</span><span class="variable">.__source</span> === undefined ? <span class="literal">null</span> : <span class="keyword">config</span><span class="variable">.__source</span>;</span><br><span class="line">  <span class="comment">// Remaining properties are added to a new props object</span></span><br><span class="line">  <span class="keyword">for</span> (propName in <span class="keyword">config</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      hasOwnProperty<span class="variable">.call</span>(<span class="keyword">config</span>, propName) &amp;&amp;</span><br><span class="line">      !RESERVED_PROPS<span class="variable">.hasOwnProperty</span>(propName)</span><br><span class="line">    ) &#123;</span><br><span class="line">      props[propName] = <span class="keyword">config</span>[propName];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是将传入的<code>config</code>参数添加到<code>props</code>中.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> childrenLength = <span class="built_in">arguments</span>.length - <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (childrenLength === <span class="number">1</span>) &#123;</span><br><span class="line">  props.children = children;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (childrenLength &gt; <span class="number">1</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> childArray = <span class="built_in">Array</span>(childrenLength);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; childrenLength; i++) &#123;</span><br><span class="line">    childArray[i] = <span class="built_in">arguments</span>[i + <span class="number">2</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Object</span>.freeze) &#123;</span><br><span class="line">      <span class="built_in">Object</span>.freeze(childArray);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  props.children = childArray;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>arguments</code>是一个关键字，存储着函数的参数，是一个类数组对象，可以使用一些基本的数组api但是他本质上不是一个数组而是一个对象。使用<code>arguments.length - 2</code>除去前两个参数剩下的就都是子节点了。这边对数组的长度进行了判断，可以发现只有一个子节点的时候<code>props.children</code>值是一个对象，多个子节点时，值为一个数组，上面的那个例子体现不出这个，换成下面的例子然后在babel一下就可以看出这个参数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加一个div节点</span></span><br><span class="line">ReactDom.render(</span><br><span class="line">    &lt;App&gt;</span><br><span class="line">        &lt;div&gt;Hello World&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>App&gt;,</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line">);</span><br><span class="line"><span class="comment">// 转换成babel之后的结果</span></span><br><span class="line">_reactDom[<span class="string">"default"</span>].render(</span><br><span class="line">    _react[<span class="string">"default"</span>].createElement(</span><br><span class="line">        App,</span><br><span class="line">        <span class="literal">null</span>,</span><br><span class="line">        _react[<span class="string">"default"</span>].createElement(<span class="string">"div"</span>, <span class="literal">null</span>, <span class="string">"Hello World"</span>)</span><br><span class="line">    ),</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>这边可以看出又新加了一个<code>createElement</code>。</p><p>解析完children之后，添加进<code>props</code>对象里，在往下走，</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">type</span> &amp;&amp; <span class="keyword">type</span>.defaultProps) &#123;</span><br><span class="line">  <span class="keyword">const</span> defaultProps = <span class="keyword">type</span>.defaultProps;</span><br><span class="line">  <span class="keyword">for</span> (propName <span class="keyword">in</span> defaultProps) &#123;</span><br><span class="line">    <span class="keyword">if</span> (props[propName] === <span class="literal">undefined</span>) &#123;</span><br><span class="line">      props[propName] = defaultProps[propName];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一块是来解析<code>defaultProps</code></p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> ReactElement(</span><br><span class="line"><span class="built_in">    type,</span></span><br><span class="line"><span class="built_in">    key,</span></span><br><span class="line"><span class="built_in">    ref,</span></span><br><span class="line"><span class="built_in">    self,</span></span><br><span class="line"><span class="built_in">    source,</span></span><br><span class="line">    ReactCurrentOwner.current,</span><br><span class="line"><span class="built_in">    props,</span></span><br><span class="line">  )<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>最终这个<code>createElement</code>方法会返回一个<code>ReactElement</code>对象。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ReactElement = <span class="keyword">function</span>(<span class="keyword">type</span>, key, <span class="keyword">ref</span>, self, source, owner, props) &#123;</span><br><span class="line">  <span class="keyword">const</span> element = &#123;</span><br><span class="line">    <span class="comment">// This tag allows us to uniquely identify this as a React Element</span></span><br><span class="line">    <span class="comment">// 独特的唯一标示 表明这一个react元素</span></span><br><span class="line">    $$typeof: REACT_ELEMENT_TYPE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Built-in properties that belong on the element</span></span><br><span class="line">    <span class="keyword">type</span>: <span class="keyword">type</span>,</span><br><span class="line">    key: key,</span><br><span class="line">    <span class="keyword">ref</span>: <span class="keyword">ref</span>,</span><br><span class="line">    props: props,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Record the component responsible for creating this element.</span></span><br><span class="line">    <span class="comment">// 记录负责创建此节点的组件</span></span><br><span class="line">    <span class="number">_</span>owner: owner,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="number">__</span>DEV__) &#123;</span><br><span class="line">    <span class="comment">/**/</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> element;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>返回一个element对象，需要注意的是这边有一个标示符<code>$$typeof</code>，表明这是一个React.Element对象，源码中在英文注释</p><blockquote><p>  Factory method to create a new React element. This no longer adheres to<br> the class pattern, so do not use new to call it. Also, no instanceof check<br>  will work. Instead test $$typeof field against Symbol.for(‘react.element’) to check<br>  if something is a React Element.</p></blockquote><p>大概意思就是说以后不在坚持使用class来创建了，所以不要new调用它，同样的instancof也是没有效果的，取而代之的是使用一个标识符<code>$$typeof</code>值为一个sybmol对象<code>Symbol.for(&#39;react.element&#39;)</code></p><p>在这个文件的下方还有一个方法用来校验一个对象是不是<code>React.Element</code></p><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * <span class="type">Verifies</span> the <span class="keyword">object</span> <span class="keyword">is</span> a <span class="type">ReactElement</span>.</span><br><span class="line"> * <span class="type">See</span> https://reactjs.org/docs/react-api.html<span class="comment">#isvalidelement</span></span><br><span class="line"> * @param &#123;?<span class="keyword">object</span>&#125; <span class="keyword">object</span></span><br><span class="line"> * @<span class="keyword">return</span> &#123;boolean&#125; <span class="type">True</span> <span class="keyword">if</span> `<span class="keyword">object</span>` <span class="keyword">is</span> a <span class="type">ReactElement</span>.</span><br><span class="line"> * @final</span><br><span class="line"> */</span><br><span class="line"><span class="keyword">export</span> function isValidElement(<span class="keyword">object</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    typeof <span class="keyword">object</span> === '<span class="keyword">object</span>' &amp;&amp;</span><br><span class="line">    <span class="keyword">object</span> !== null &amp;&amp;</span><br><span class="line">    <span class="keyword">object</span>.$$typeof === <span class="type">REACT_ELEMENT_TYPE</span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接比对的<code>$$typeof</code>属性</p><h2 id="Component-PureComponent"><a href="#Component-PureComponent" class="headerlink" title="Component PureComponent"></a>Component PureComponent</h2><p>写一个React组件时，需要继承<code>React.Component</code>，而<code>PureComponent</code>和<code>Component</code>的区别在于，使用<code>PureComponent</code>可以在一定程度上优化<code>React</code>的性能，因为<code>PureComponent</code>内部是对<code>preProps nextProps</code>做了浅对比。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function Component(props, context, updater) &#123;</span><br><span class="line">  <span class="keyword">this</span>.props = props;</span><br><span class="line">  <span class="keyword">this</span>.context = context;</span><br><span class="line">  <span class="comment">// If a component has string refs, we will assign a different object later.</span></span><br><span class="line">  <span class="keyword">this</span>.refs = emptyObject;</span><br><span class="line">  <span class="comment">// We initialize the default updater but the real one gets injected by the</span></span><br><span class="line">  <span class="comment">// renderer.</span></span><br><span class="line">  <span class="keyword">this</span>.updater = updater || ReactNoopUpdateQueue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这边主要是<code>updater</code>有一个更新队列的东西，下次再说，之后在<code>Component</code>的原型上附加一系列的方法。而<code>PureComponent</code>是继承的<code>Component</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">PureComponent</span>(<span class="params">props, context, updater</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.props = props;</span><br><span class="line">  <span class="keyword">this</span>.context = context;</span><br><span class="line">  <span class="comment">// If a component has string refs, we will assign a different object later.</span></span><br><span class="line">  <span class="keyword">this</span>.refs = emptyObject;</span><br><span class="line">  <span class="keyword">this</span>.updater = updater || ReactNoopUpdateQueue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> pureComponentPrototype = (PureComponent.prototype = <span class="keyword">new</span> ComponentDummy());</span><br><span class="line">pureComponentPrototype.constructor = PureComponent;</span><br><span class="line"><span class="comment">// Avoid an extra prototype jump for these methods.</span></span><br><span class="line"><span class="built_in">Object</span>.assign(pureComponentPrototype, Component.prototype);</span><br><span class="line">pureComponentPrototype.isPureReactComponent = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><p>不同的地方在于<code>PureComponent</code>添加了一个属性用来表识该实例是一个<code>PureComponent</code><br><code>pureComponentPrototype.isPureReactComponent = true;</code></p><p>下一篇应该是记录<code>ReactDom.render</code>方法</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;上一篇介绍了React的Api，今天介绍createElement和React的Component相关操作。看了很多其他人的博客，对于React16的fiber架构还是无法了解，尽管我知道他很牛逼。发现了解React的源码还是需要从渲染开始进行了解，明白从一个组件到挂载再到响应式的所有操作。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;首先先写一个简单的React组件&lt;br&gt;&lt;figure class=&quot;highlight scala&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;React&lt;/span&gt; from &lt;span class=&quot;symbol&quot;&gt;&#39;reac&lt;/span&gt;t&#39;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;ReactDom&lt;/span&gt; from &lt;span class=&quot;symbol&quot;&gt;&#39;react&lt;/span&gt;-dom&#39;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;App&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;React&lt;/span&gt;.&lt;span class=&quot;title&quot;&gt;Component&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    constructor(props) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;super&lt;/span&gt;(props);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.state = &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            name: &lt;span class=&quot;symbol&quot;&gt;&#39;Hello&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;World&lt;/span&gt;&#39;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    componentDidMount() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        console.log(&lt;span class=&quot;symbol&quot;&gt;&#39;component&lt;/span&gt; did mount&#39;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    render() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; (&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;lt;div&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;#123; &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.state.name &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;lt;/div&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        )&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;type&quot;&gt;ReactDom&lt;/span&gt;.render(&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;lt;&lt;span class=&quot;type&quot;&gt;App&lt;/span&gt; /&amp;gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    document.getElementById(&lt;span class=&quot;symbol&quot;&gt;&#39;roo&lt;/span&gt;t&#39;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;使用&lt;code&gt;babel&lt;/code&gt;编译这个&lt;code&gt;jsx&lt;/code&gt;文件&lt;/p&gt;
    
    </summary>
    
    
      <category term="源码" scheme="http://shenweini.cn/tags/%E6%BA%90%E7%A0%81/"/>
    
      <category term="React" scheme="http://shenweini.cn/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>React源码解析----API概览 + React.Children 解析</title>
    <link href="http://shenweini.cn/2019/09/15/React%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90----API%E6%A6%82%E8%A7%88%20+%20React.Children%20%E8%A7%A3%E6%9E%90/"/>
    <id>http://shenweini.cn/2019/09/15/React源码解析----API概览 + React.Children 解析/</id>
    <published>2019-09-15T06:19:08.567Z</published>
    <updated>2019-09-15T06:19:08.567Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>最近闲来无事，研究一波React源码，一开始是以Vue源码起步的，结果发现我对Vue实在是不熟悉，看Vue源码还不够格，相比而言，我更喜欢React，可能是因为第一个学的框架学的就是React，所以对React更加的充满热情，也更加的熟练，个人观点，React还是要比Vue牛逼一点好看一点的。</p><p>React本身的源码是很少的，根据打包出来的Commonjs版本看来，React只有两千多行代码，但是ReactDom据说有两万多行，框架开发者实属伟大！致敬！！！</p><p>那么这一篇是React一些通用的API概况和React.Children方法的解析，如有不到位或错误的地方欢迎指教，我的邮箱 <a href="mailto:1103107216@qq.com" target="_blank" rel="noopener">1103107216@qq.com</a> 您也可以下方评论。</p></blockquote><h2 id="React源码获取"><a href="#React源码获取" class="headerlink" title="React源码获取"></a>React源码获取</h2><p>我发现有两种方式，一种呢就是从<code>github</code>上拉取<code>react</code>项目的源码，github地址大家可以自己找，<code>git clone</code>下来之后，在<code>/packages/react</code>下面就是<code>react</code>的源码了，可以看到下面是分成了很多个小文件的，这个我一般用来看的不是用来调试的。</p><p>另一个呢就是建一个项目，安装一下<code>cnpm i react react-dom -S</code>之后在<code>node_modules</code>里面找到<code>react</code>的源码，建一个项目，用<code>webpack</code>打包，装个<code>babel</code>一套，毕竟es6比es5好使多了，开个热更新，之后就直接修改这个<code>node_modules</code>里面的源码进行打印调试了，我个人喜欢<code>console.log</code>不解释，只有在调试一些算法问题时我才会开Debug模式。</p><a id="more"></a><h2 id="通用API"><a href="#通用API" class="headerlink" title="通用API"></a>通用API</h2><p>首先先来一个简单的 React 应用,这边使用es6的class写法，个人建议多练练函数式编程，写函数组件比写class舒服多了，毕竟React16提供了这么多强大的Hook</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="type">React</span> from <span class="symbol">'reac</span>t';</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    constructor(props) &#123;</span><br><span class="line">        <span class="keyword">super</span>(props)</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                <span class="type">Hello</span> <span class="type">World</span></span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>OK, Hello World 致敬，我们可以开始干活了。首先看一下React的源码，在<code>/packages/react/src/React.js</code>这个文件里面，可以看到React的定义，你会发现和Vue的源码很不一样，这也是我更喜欢React的原因，慢慢的亲切感。</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">const React = &#123;</span><br><span class="line"><span class="symbol">  Children:</span> &#123;</span><br><span class="line"><span class="built_in">    map,</span></span><br><span class="line"><span class="built_in">    forEach,</span></span><br><span class="line"><span class="built_in">    count,</span></span><br><span class="line"><span class="built_in">    toArray,</span></span><br><span class="line"><span class="built_in">    only,</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line"><span class="built_in">  createRef,</span></span><br><span class="line"><span class="built_in">  Component,</span></span><br><span class="line"><span class="built_in">  PureComponent,</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">  createContext,</span></span><br><span class="line"><span class="built_in">  forwardRef,</span></span><br><span class="line"><span class="built_in">  lazy,</span></span><br><span class="line"><span class="built_in">  memo,</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">  useCallback,</span></span><br><span class="line"><span class="built_in">  useContext,</span></span><br><span class="line"><span class="built_in">  useEffect,</span></span><br><span class="line"><span class="built_in">  useImperativeHandle,</span></span><br><span class="line"><span class="built_in">  useDebugValue,</span></span><br><span class="line"><span class="built_in">  useLayoutEffect,</span></span><br><span class="line"><span class="built_in">  useMemo,</span></span><br><span class="line"><span class="built_in">  useReducer,</span></span><br><span class="line"><span class="built_in">  useRef,</span></span><br><span class="line"><span class="built_in">  useState,</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">  Fragment:</span> REACT_FRAGMENT_TYPE,</span><br><span class="line"><span class="symbol">  StrictMode:</span> REACT_STRICT_MODE_TYPE,</span><br><span class="line"><span class="symbol">  Suspense:</span> REACT_SUSPENSE_TYPE,</span><br><span class="line"></span><br><span class="line"><span class="symbol">  createElement: __DEV__ ? createElementWithValidation :</span> createElement,</span><br><span class="line"><span class="symbol">  cloneElement: __DEV__ ? cloneElementWithValidation :</span> cloneElement,</span><br><span class="line"><span class="symbol">  createFactory: __DEV__ ? createFactoryWithValidation :</span> createFactory,</span><br><span class="line"><span class="symbol">  isValidElement:</span> isValidElement,</span><br><span class="line"></span><br><span class="line"><span class="symbol">  version:</span> ReactVersion,</span><br><span class="line"></span><br><span class="line"><span class="symbol">  unstable_ConcurrentMode:</span> REACT_CONCURRENT_MODE_TYPE,</span><br><span class="line"><span class="symbol">  unstable_Profiler:</span> REACT_PROFILER_TYPE,</span><br><span class="line">  // 这一行跳过</span><br><span class="line"><span class="symbol">  __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED:</span> ReactSharedInternals,</span><br><span class="line">&#125;<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>这边定义了React里面的所有的通用方法，这边只做一个概览，每一个具体的用处会在后面进行详细的介绍。</p><h3 id="Children"><a href="#Children" class="headerlink" title="Children"></a>Children</h3><p>这个里面封装的是对一个组件的子组件进行遍历等的一些操作，我们一般不会用到，讲真我除了看源码会用他来试一试其他的真没见到有人用它。</p><ul><li><p>forEach,map 类似于数组的遍历对象遍历啥的</p></li><li><p>count 用来计算子组件的数量</p></li><li><p>only 官方解释：验证 children 是否只有一个子节点（一个 React 元素），如果有则返回它，否则此方法会抛出错误。 Tips：不可以使用<code>React.Children.map</code>方法的返回值作为参数，因为map的返回值是一个数组而不是一个React元素</p></li><li><p>toArray 将Children按照数组的形式扁平展开并返回</p></li></ul><p>搞不懂没关系，后面会介绍，有一个印象就好</p><h3 id="createRef"><a href="#createRef" class="headerlink" title="createRef"></a>createRef</h3><p>ref 属性是在开发中经常使用的，说白了就是用来获取真实Dom的，新版的React中使用ref的操作也变了</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.inputRef = <span class="type">React</span>.createRef();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 这是一种</span></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> &lt;input <span class="class"><span class="keyword">type</span></span>=<span class="string">"text"</span> ref=&#123;<span class="keyword">this</span>.inputRef&#125; /&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 这是另外一种</span></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> &lt;input <span class="class"><span class="keyword">type</span></span>=<span class="string">"text"</span> ref=&#123;node =&gt; <span class="keyword">this</span>.inputRef = node&#125;&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Component-PureComponent"><a href="#Component-PureComponent" class="headerlink" title="Component, PureComponent"></a>Component, PureComponent</h3><p>这两个大家应该都很熟悉，创建一个React组件，PureComponent在判断组件是否改更新的时候更加的方便。</p><h3 id="createContext"><a href="#createContext" class="headerlink" title="createContext"></a>createContext</h3><p>创建一个上下文，返回一个<code>Context</code>对象，里面包含了<code>Provider，Consumer</code>属性，一般用来往组件树的更深处传递数据，避免一个组件一个组件的往下传，不方便解藕</p><h3 id="forwardRef"><a href="#forwardRef" class="headerlink" title="forwardRef"></a>forwardRef</h3><p>创建一个React组件,这个组件能够将其接受的 ref 属性转发到其组件树下的另一个组件中.<code>React.forwardRef</code> 接受渲染函数作为参数。React 将使用 props 和 ref 作为参数来调用此函数。此函数应返回 React 节点。</p><h3 id="lazy"><a href="#lazy" class="headerlink" title="lazy"></a>lazy</h3><p>组件懒加载</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const SomeComponent = React.lazy(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'./SomeComponent'</span>));</span><br></pre></td></tr></table></figure><h3 id="memo"><a href="#memo" class="headerlink" title="memo"></a>memo</h3><p>用来创建一个HOC的</p><h3 id="useState…"><a href="#useState…" class="headerlink" title="useState…"></a>useState…</h3><p>接下来这几个就是React16大名鼎鼎的Hook函数，功能强大，函数式组件的福音，亲切感倍足</p><h3 id="Fragment-StrictMode-Suspense-unstable-ConcurrentMode-unstable-Profiler"><a href="#Fragment-StrictMode-Suspense-unstable-ConcurrentMode-unstable-Profiler" class="headerlink" title="Fragment StrictMode Suspense unstable_ConcurrentMode unstable_Profiler"></a>Fragment StrictMode Suspense unstable_ConcurrentMode unstable_Profiler</h3><p>这四个都是React提供的组件，但他们呢其实都只是占位符，都是一个Symbol，在React实际检测到他们的时候会做一些特殊的处理，比如StrictMode和AsyncMode会让他们的子节点对应的Fiber的mode都变成和他们一样的mode</p><h3 id="createElement"><a href="#createElement" class="headerlink" title="createElement"></a>createElement</h3><p>createElement 这是React中最重要的方法了，用来创建<code>ReactElement</code></p><h3 id="cloneElement"><a href="#cloneElement" class="headerlink" title="cloneElement"></a>cloneElement</h3><p>顾名思义，克隆一个<code>ReactElement</code></p><h3 id="createFactory"><a href="#createFactory" class="headerlink" title="createFactory"></a>createFactory</h3><p>创建一个工厂，这个工厂专门用来创建某一类<code>ReactElement</code></p><h3 id="isValidElement"><a href="#isValidElement" class="headerlink" title="isValidElement"></a>isValidElement</h3><p>用来检测是否是一个<code>ReactElement</code></p><h3 id="version"><a href="#version" class="headerlink" title="version"></a>version</h3><p>记录React的当前版本号</p><h2 id="React-Children-详解"><a href="#React-Children-详解" class="headerlink" title="React.Children 详解"></a>React.Children 详解</h2><blockquote><p>React.Children 提供了用于处理 this.props.children 不透明数据结构的实用方法。</p></blockquote><p>这一部分的代码在 <code>packages/react/react/src/ReactChildren.js</code>里面，主要分装了<code>forEach map count only toArray</code>，前两者用于遍历Reach Children。</p><ul><li><p><code>count</code> 用于返回该组件的children数量</p></li><li><p><code>only</code> 用于判断该组件是不是只有一个子节点</p></li><li><p><code>toArray</code> 将React.Children以扁平的形式返回出来，并附加<code>key</code></p></li></ul><p>在<code>React</code>中，一段文本可以被称为一个子节点，一段标签也可以被成为一个节点。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    constructor(props) &#123;</span><br><span class="line">        <span class="keyword">super</span>(props);</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="comment">// Hello World</span></span><br><span class="line">        console.log(<span class="keyword">this</span>.props.children);</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;&lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">ReactDom</span>.render(</span><br><span class="line">    &lt;<span class="type">App</span>&gt;</span><br><span class="line">        <span class="comment">// 一段文本也是一个子节点</span></span><br><span class="line">        <span class="type">Hello</span> <span class="type">World</span></span><br><span class="line">    &lt;/<span class="type">App</span>&gt; ,</span><br><span class="line">    document.getElementById(<span class="symbol">'roo</span>t')</span><br><span class="line">);</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">        <span class="keyword">super</span>(props);</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="comment">// 被标记为一个React.Element</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.props.children);</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDom.render(</span><br><span class="line">    &lt;App&gt;</span><br><span class="line">        <span class="comment">// 一段标签也可以是一个子节点</span></span><br><span class="line">        &lt;div&gt;Hello World&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>App&gt; ,</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>在上面的示例代码中，如果传递的子节点是一段html标签，那么打印出来的结果是这样的：</p><p><img src="http://static.zybuluo.com/shenweizheng/s26qv0gdxzzh7z46ri153dqa/image_1dkp91mf4199d1kds1ul615rklpr9.png" alt="image_1dkp91mf4199d1kds1ul615rklpr9.png-36.3kB"></p><p>我们也可以在<code>App</code>组件中显示我们传递的这个Children</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    constructor(props) &#123;</span><br><span class="line">        <span class="keyword">super</span>(props);</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">        console.log(<span class="keyword">this</span>.props.children);</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;&#123; <span class="keyword">this</span>.props.children &#125;&lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://static.zybuluo.com/shenweizheng/3mo8ztspn32aw1yv80rj3rrr/image_1dkp98tod16gl3u91q614tj1a7jm.png" alt="image_1dkp98tod16gl3u91q614tj1a7jm.png-2.4kB"></p><p>如果传递的是多个节点，那么就会被解析成一个数组</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">App</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>Hello China<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">App</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="http://static.zybuluo.com/shenweizheng/pgtbpsapbp5zibhv8w8v493t/image_1dkp9bfcjqb5ptn1dt02dm8lp13.png" alt="image_1dkp9bfcjqb5ptn1dt02dm8lp13.png-22.8kB"></p><p>那么<code>Reach.Children</code>的方法应该就是在这里进行使用，因为我实际上也没有使用过，做个简单的示例，我们可以打印一下<code>App</code>这个组件的子节点�数，使用<code>count</code>方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">        <span class="keyword">super</span>(props);</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="comment">// 2</span></span><br><span class="line">        <span class="built_in">console</span>.log(React.Children.count(<span class="keyword">this</span>.props.children));</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;&#123; <span class="keyword">this</span>.props.children &#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        )</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDom.render(</span></span><br><span class="line"><span class="regexp">    &lt;App&gt;</span></span><br><span class="line"><span class="regexp">        &lt;div&gt;Hello World&lt;/</span>div&gt;</span><br><span class="line">        &lt;div&gt;Hello China&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>App&gt; ,</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>这边会打印出来一个 2 因为我们传递的是两个节点</p><p>示例看完了我们可以来分析一下源码了，介绍一下<code>map</code>的源码</p><p>找到<code>ReactChildren.js</code>（这是在React源码里，不是在node_modules里），找到最下面模块导出语句</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">export &#123;</span><br><span class="line">  forEachChildren <span class="keyword">as</span> <span class="keyword">forEach</span>,</span><br><span class="line">  mapChildren <span class="keyword">as</span> map,</span><br><span class="line">  countChildren <span class="keyword">as</span> <span class="keyword">count</span>,</span><br><span class="line">  onlyChild <span class="keyword">as</span> only,</span><br><span class="line">  toArray,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看到<code>map</code>是<code>mapChildren</code>的一个别名，下面找到这个函数</p><figure class="highlight puppet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Maps children that are typically specified as `props.children`.</span><br><span class="line"> *</span><br><span class="line"> * See https://reactjs.org/docs/react-api.html<span class="comment">#reactchildrenmap</span></span><br><span class="line"> *</span><br><span class="line"> * The provided mapFunction(child, key, index) will be called for each</span><br><span class="line"> * leaf child.</span><br><span class="line"> *</span><br><span class="line"> * @<span class="keyword">param</span> &#123;?*&#125; <span class="keyword">children</span> <span class="keyword">Children</span> <span class="keyword">tree</span> <span class="keyword">container</span>.</span><br><span class="line"> * @<span class="keyword">param</span> &#123;function(*, int)&#125; <span class="keyword">func</span> <span class="keyword">The</span> <span class="keyword">map</span> <span class="keyword">function</span>.</span><br><span class="line"> * @<span class="keyword">param</span> &#123;*&#125; <span class="keyword">context</span> <span class="keyword">Context</span> <span class="keyword">for</span> <span class="keyword">mapFunction</span>.</span><br><span class="line"> * @<span class="keyword">return</span> &#123;object&#125; <span class="keyword">Object</span> <span class="keyword">containing</span> <span class="keyword">the</span> <span class="keyword">ordered</span> <span class="keyword">map</span> <span class="keyword">of</span> <span class="keyword">results</span>.</span><br><span class="line"> */</span><br><span class="line">function mapChildren(children, func, context) &#123;</span><br><span class="line">  if (children == null) &#123;</span><br><span class="line">    return children;</span><br><span class="line">  &#125;</span><br><span class="line">  const result = [];</span><br><span class="line">  mapIntoWithKeyPrefixInternal(children, result, null, func, context);</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法接受三个参数，第一个参数是我们传递的<code>this.props.children</code>,也是必选参数，第二个参数是一个function，在遍历的过程中，会对每一个节点都使用这个function，这个function接受一个参数，参数就是当前遍历的节点，第三个参数是一个上下文，一般不用传。<br>可以看出重点是<code>mapIntoWithKeyPrefixInternal</code>这个方法。</p><p>使用示例<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    constructor(props) &#123;</span><br><span class="line">        <span class="keyword">super</span>(props);</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="type">React</span>.<span class="type">Children</span>.map(<span class="keyword">this</span>.props.children, (item) =&gt; &#123;</span><br><span class="line">            console.log(item);</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;&#123; <span class="keyword">this</span>.props.children &#125;&lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function mapIntoWithKeyPrefixInternal(children, array, <span class="keyword">prefix</span>, <span class="function"><span class="keyword">func</span>, <span class="title">context</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 被忽视的前缀</span></span><br><span class="line">  <span class="keyword">let</span> escapedPrefix = '';</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">prefix</span> != null) &#123;</span><br><span class="line">    escapedPrefix = escapeUserProvidedKey(<span class="keyword">prefix</span>) + '/';</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 遍历上下文</span></span><br><span class="line">  const traverseContext = getPooledTraverseContext(</span><br><span class="line">    array,</span><br><span class="line">    escapedPrefix,</span><br><span class="line">    <span class="function"><span class="keyword">func</span>,</span></span><br><span class="line"><span class="function">    <span class="title">context</span>,</span></span><br><span class="line"><span class="function">  );</span></span><br><span class="line"><span class="function">  <span class="title">traverseAllChildren</span><span class="params">(children, mapSingleChildIntoContext, traverseContext)</span></span>;</span><br><span class="line">  releaseTraverseContext(traverseContext);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先是获取一下遍历的上下文，这个在后面的方法应该会用到，下面就是开始遍历所有的Children了，重点是<code>traverseAllChildren(children, mapSingleChildIntoContext, traverseContext);</code>，第一个参数好理解就是我们传递的<code>this.props.children</code>，第二个参数是一个方法，第三个参数就是前面获取到的遍历上下文。</p><p>首先看一下这个<code>getPooledTraverseContext</code>方法</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> POOL_SIZE = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> traverseContextPool = [];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getPooledTraverseContext</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  mapResult,</span></span></span><br><span class="line"><span class="function"><span class="params">  keyPrefix,</span></span></span><br><span class="line"><span class="function"><span class="params">  mapFunction,</span></span></span><br><span class="line"><span class="function"><span class="params">  mapContext,</span></span></span><br><span class="line"><span class="function"><span class="params">)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (traverseContextPool.length) &#123;</span><br><span class="line">    <span class="keyword">const</span> traverseContext = traverseContextPool.pop();</span><br><span class="line">    traverseContext.result = mapResult;</span><br><span class="line">    traverseContext.keyPrefix = keyPrefix;</span><br><span class="line">    traverseContext.func = mapFunction;</span><br><span class="line">    traverseContext.context = mapContext;</span><br><span class="line">    traverseContext.count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> traverseContext;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      result: mapResult,</span><br><span class="line">      keyPrefix: keyPrefix,</span><br><span class="line">      func: mapFunction,</span><br><span class="line">      context: mapContext,</span><br><span class="line">      count: <span class="number">0</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用了一个闭包，外层有一个<code>traverseContextPool</code>记录者遍历上下文的一个<code>pool</code>，我脑海中蹦出来的词是连接池，所以暂且就这么理解他，这个连接池的容量为10，如果这个连接池里有东西的话，也就是说这个<code>traverseContextPool.length !== 0</code>的话，那么会弹出最后一个进行赋值然后返回，如果池里没有东西的话就直接返回一个新的对象。</p><p>下面看重点方法<code>traverseAllChildren</code></p><figure class="highlight puppet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Traverses children that are typically specified as `props.children`, but</span><br><span class="line"> * might also be specified through attributes:</span><br><span class="line"> *</span><br><span class="line"> * - `traverseAllChildren(this.props.children, ...)`</span><br><span class="line"> * - `traverseAllChildren(this.props.leftPanelChildren, ...)`</span><br><span class="line"> *</span><br><span class="line"> * The `traverseContext` is an optional argument that is passed through the</span><br><span class="line"> * entire traversal. It can be used to store accumulations or anything else that</span><br><span class="line"> * the callback might find relevant.</span><br><span class="line"> *</span><br><span class="line"> * @<span class="keyword">param</span> &#123;?*&#125; <span class="keyword">children</span> <span class="keyword">Children</span> <span class="keyword">tree</span> <span class="keyword">object</span>.</span><br><span class="line"> * @<span class="keyword">param</span> &#123;!function&#125; <span class="keyword">callback</span> <span class="keyword">To</span> <span class="keyword">invoke</span> <span class="keyword">upon</span> <span class="keyword">traversing</span> <span class="keyword">each</span> <span class="keyword">child</span>.</span><br><span class="line"> * @<span class="keyword">param</span> &#123;?*&#125; <span class="keyword">traverseContext</span> <span class="keyword">Context</span> <span class="keyword">for</span> <span class="keyword">traversal</span>.</span><br><span class="line"> * @<span class="keyword">return</span> &#123;!number&#125; <span class="keyword">The</span> <span class="keyword">number</span> <span class="keyword">of</span> <span class="keyword">children</span> <span class="keyword">in</span> <span class="keyword">this</span> <span class="keyword">subtree</span>.</span><br><span class="line"> */</span><br><span class="line">function traverseAllChildren(children, callback, traverseContext) &#123;</span><br><span class="line">  if (children == null) &#123;</span><br><span class="line">    return 0;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return traverseAllChildrenImpl(children, <span class="string">''</span>, callback, traverseContext);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要看这个方法的实现<code>traverseAllChildrenImpl</code></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;?*&#125; children Children tree container.</span></span><br><span class="line"><span class="comment"> * @param &#123;!string&#125; nameSoFar Name of the key path so far.</span></span><br><span class="line"><span class="comment"> * @param &#123;!function&#125; callback Callback to invoke with each child found.</span></span><br><span class="line"><span class="comment"> * @param &#123;?*&#125; traverseContext Used to pass information throughout the traversal</span></span><br><span class="line"><span class="comment"> * process.</span></span><br><span class="line"><span class="comment"> * @return &#123;!number&#125; The number of children in this subtree.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">traverseAllChildrenImpl</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  children,</span></span></span><br><span class="line"><span class="function"><span class="params">  nameSoFar,</span></span></span><br><span class="line"><span class="function"><span class="params">  callback,</span></span></span><br><span class="line"><span class="function"><span class="params">  traverseContext,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">type</span> = <span class="keyword">typeof</span> children;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">type</span> === <span class="string">'undefined'</span> || <span class="keyword">type</span> === <span class="string">'boolean'</span>) &#123;</span><br><span class="line">    <span class="comment">// All of the above are perceived as null.</span></span><br><span class="line">    children = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> invokeCallback = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (children === <span class="literal">null</span>) &#123;</span><br><span class="line">    invokeCallback = <span class="literal">true</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> (<span class="keyword">type</span>) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'string'</span>:</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'number'</span>:</span><br><span class="line">        invokeCallback = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'object'</span>:</span><br><span class="line">        <span class="keyword">switch</span> (children.$$<span class="keyword">typeof</span>) &#123;</span><br><span class="line">          <span class="keyword">case</span> REACT_ELEMENT_TYPE:</span><br><span class="line">          <span class="keyword">case</span> REACT_PORTAL_TYPE:</span><br><span class="line">            invokeCallback = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (invokeCallback) &#123;</span><br><span class="line">    callback(</span><br><span class="line">      traverseContext,</span><br><span class="line">      children,</span><br><span class="line">      <span class="comment">// If it's the only child, treat the name as if it was wrapped in an array</span></span><br><span class="line">      <span class="comment">// so that it's consistent if the number of children grows.</span></span><br><span class="line">      nameSoFar === <span class="string">''</span> ? SEPARATOR + getComponentKey(children, <span class="number">0</span>) : nameSoFar,</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> child;</span><br><span class="line">  <span class="keyword">let</span> nextName;</span><br><span class="line">  <span class="keyword">let</span> subtreeCount = <span class="number">0</span>; <span class="comment">// Count of children found in the current subtree.</span></span><br><span class="line">  <span class="keyword">const</span> nextNamePrefix =</span><br><span class="line">    nameSoFar === <span class="string">''</span> ? SEPARATOR : nameSoFar + SUBSEPARATOR;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(children)) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; children.length; i++) &#123;</span><br><span class="line">      child = children[i];</span><br><span class="line">      nextName = nextNamePrefix + getComponentKey(child, i);</span><br><span class="line">      subtreeCount += traverseAllChildrenImpl(</span><br><span class="line">        child,</span><br><span class="line">        nextName,</span><br><span class="line">        callback,</span><br><span class="line">        traverseContext,</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> iteratorFn = getIteratorFn(children);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> iteratorFn === <span class="string">'function'</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">        <span class="comment">// Warn about using Maps as children</span></span><br><span class="line">        <span class="keyword">if</span> (iteratorFn === children.entries) &#123;</span><br><span class="line">          warning(</span><br><span class="line">            didWarnAboutMaps,</span><br><span class="line">            <span class="string">'Using Maps as children is unsupported and will likely yield '</span> +</span><br><span class="line">              <span class="string">'unexpected results. Convert it to a sequence/iterable of keyed '</span> +</span><br><span class="line">              <span class="string">'ReactElements instead.'</span>,</span><br><span class="line">          );</span><br><span class="line">          didWarnAboutMaps = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> iterator = iteratorFn.call(children);</span><br><span class="line">      <span class="keyword">let</span> step;</span><br><span class="line">      <span class="keyword">let</span> ii = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span> (!(step = iterator.next()).done) &#123;</span><br><span class="line">        child = step.value;</span><br><span class="line">        nextName = nextNamePrefix + getComponentKey(child, ii++);</span><br><span class="line">        subtreeCount += traverseAllChildrenImpl(</span><br><span class="line">          child,</span><br><span class="line">          nextName,</span><br><span class="line">          callback,</span><br><span class="line">          traverseContext,</span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">type</span> === <span class="string">'object'</span>) &#123;</span><br><span class="line">      <span class="keyword">let</span> addendum = <span class="string">''</span>;</span><br><span class="line">      <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">        addendum =</span><br><span class="line">          <span class="string">' If you meant to render a collection of children, use an array '</span> +</span><br><span class="line">          <span class="string">'instead.'</span> +</span><br><span class="line">          ReactDebugCurrentFrame.getStackAddendum();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">const</span> childrenString = <span class="string">''</span> + children;</span><br><span class="line">      invariant(</span><br><span class="line">        <span class="literal">false</span>,</span><br><span class="line">        <span class="string">'Objects are not valid as a React child (found: %s).%s'</span>,</span><br><span class="line">        childrenString === <span class="string">'[object Object]'</span></span><br><span class="line">          ? <span class="string">'object with keys &#123;'</span> + <span class="built_in">Object</span>.keys(children).join(<span class="string">', '</span>) + <span class="string">'&#125;'</span></span><br><span class="line">          : childrenString,</span><br><span class="line">        addendum,</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> subtreeCount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分步解析<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">let invokeCallback = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (children === <span class="literal">null</span>) &#123;</span><br><span class="line">    invokeCallback = <span class="literal">true</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'string'</span>:</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'number'</span>:</span><br><span class="line">        invokeCallback = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'object'</span>:</span><br><span class="line">        <span class="keyword">switch</span> (children.$$typeof) &#123;</span><br><span class="line">          <span class="keyword">case</span> <span class="string">REACT_ELEMENT_TYPE:</span></span><br><span class="line">          <span class="keyword">case</span> <span class="string">REACT_PORTAL_TYPE:</span></span><br><span class="line">            invokeCallback = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (invokeCallback) &#123;</span><br><span class="line">    callback(</span><br><span class="line">      traverseContext,</span><br><span class="line">      children,</span><br><span class="line">      <span class="comment">// If it's the only child, treat the name as if it was wrapped in an array</span></span><br><span class="line">      <span class="comment">// so that it's consistent if the number of children grows.</span></span><br><span class="line">      nameSoFar === <span class="string">''</span> ? SEPARATOR + getComponentKey(children, 0) : nameSoFar,</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>这一块是用来判断 children 类型的，如果是<code>string</code>比如说传递一个文本，<code>number</code>,<code>object</code>比如说一个dom节点，那么表明 children 只是一个节点，那么就直接执行 <code>callback</code> 返回一个 1</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (Array.isArray(children)) &#123;</span><br><span class="line">    <span class="keyword">for</span> (let <span class="built_in">i</span> = <span class="number">0</span>; <span class="built_in">i</span> &lt; children.<span class="built_in">length</span>; <span class="built_in">i</span>++) &#123;</span><br><span class="line">      child = children[<span class="built_in">i</span>];</span><br><span class="line">      nextName = nextNamePrefix + getComponentKey(child, <span class="built_in">i</span>);</span><br><span class="line">      subtreeCount += traverseAllChildrenImpl(</span><br><span class="line">        child,</span><br><span class="line">        nextName,</span><br><span class="line">        callback,</span><br><span class="line">        traverseContext,</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>如果我们传递的是多个节点，那么会遍历children数组，进行递归遍历，直到返回的是上面显示的几个类型。</p><p>上边提到的<code>callback</code>就是传递的<code>mapSingleChildIntoContext</code>,这边就是利用到之前的<code>traverseContextPool</code>被我称之为连接池的东西.</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">function mapSingleChildIntoContext(bookKeeping, child, childKey) &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123;result, keyPrefix, <span class="function"><span class="keyword">func</span>, <span class="title">context</span>&#125; = <span class="title">bookKeeping</span>;</span></span><br><span class="line"></span><br><span class="line">  let mappedChild = <span class="function"><span class="keyword">func</span>.<span class="title">call</span><span class="params">(context, child, bookKeeping.count++)</span>;</span></span><br><span class="line">  <span class="keyword">if</span> (Array.<span class="built_in">isArray</span>(mappedChild)) &#123;</span><br><span class="line">    mapIntoWithKeyPrefixInternal(mappedChild, result, childKey, c =&gt; c)<span class="comment">;</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mappedChild != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (isValidElement(mappedChild)) &#123;</span><br><span class="line">      mappedChild = cloneAndReplaceKey(</span><br><span class="line">        mappedChild,</span><br><span class="line">        // Keep both the (mapped) <span class="literal">and</span> old keys <span class="keyword">if</span> they differ, just as</span><br><span class="line">        // traverseAllChildren used <span class="keyword">to</span> <span class="keyword">do</span> <span class="keyword">for</span> objects as children</span><br><span class="line">        keyPrefix +</span><br><span class="line">          (mappedChild.key &amp;&amp; (!child || child.key !== mappedChild.key)</span><br><span class="line">            ? escapeUserProvidedKey(mappedChild.key) + <span class="string">'/'</span></span><br><span class="line">            : <span class="string">''</span>) +</span><br><span class="line">          childKey,</span><br><span class="line">      )<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">    result.push(mappedChild)<span class="comment">;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这边的<code>mappedChild</code>就是我们传递的funcion的返回值，function呢就是调用<code>React.Children.map(children,callback)</code>这里的callback了，如果这个返回值返回的是一个数组的话，那么就进行递归调用，这个时候就需要用到之前的连接池了。</p><p>采用这个连接池的目的我也是在其他的地方看到了</p><blockquote><p>因为对Children的处理一般在render里面，所以会比较频繁，所以设置一个pool减少声明和gc的开销</p></blockquote><p>这就是<code>React.Children.map</code>的实现。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;最近闲来无事，研究一波React源码，一开始是以Vue源码起步的，结果发现我对Vue实在是不熟悉，看Vue源码还不够格，相比而言，我更喜欢React，可能是因为第一个学的框架学的就是React，所以对React更加的充满热情，也更加的熟练，个人观点，React还是要比Vue牛逼一点好看一点的。&lt;/p&gt;
&lt;p&gt;React本身的源码是很少的，根据打包出来的Commonjs版本看来，React只有两千多行代码，但是ReactDom据说有两万多行，框架开发者实属伟大！致敬！！！&lt;/p&gt;
&lt;p&gt;那么这一篇是React一些通用的API概况和React.Children方法的解析，如有不到位或错误的地方欢迎指教，我的邮箱 &lt;a href=&quot;mailto:1103107216@qq.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;1103107216@qq.com&lt;/a&gt; 您也可以下方评论。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;React源码获取&quot;&gt;&lt;a href=&quot;#React源码获取&quot; class=&quot;headerlink&quot; title=&quot;React源码获取&quot;&gt;&lt;/a&gt;React源码获取&lt;/h2&gt;&lt;p&gt;我发现有两种方式，一种呢就是从&lt;code&gt;github&lt;/code&gt;上拉取&lt;code&gt;react&lt;/code&gt;项目的源码，github地址大家可以自己找，&lt;code&gt;git clone&lt;/code&gt;下来之后，在&lt;code&gt;/packages/react&lt;/code&gt;下面就是&lt;code&gt;react&lt;/code&gt;的源码了，可以看到下面是分成了很多个小文件的，这个我一般用来看的不是用来调试的。&lt;/p&gt;
&lt;p&gt;另一个呢就是建一个项目，安装一下&lt;code&gt;cnpm i react react-dom -S&lt;/code&gt;之后在&lt;code&gt;node_modules&lt;/code&gt;里面找到&lt;code&gt;react&lt;/code&gt;的源码，建一个项目，用&lt;code&gt;webpack&lt;/code&gt;打包，装个&lt;code&gt;babel&lt;/code&gt;一套，毕竟es6比es5好使多了，开个热更新，之后就直接修改这个&lt;code&gt;node_modules&lt;/code&gt;里面的源码进行打印调试了，我个人喜欢&lt;code&gt;console.log&lt;/code&gt;不解释，只有在调试一些算法问题时我才会开Debug模式。&lt;/p&gt;
    
    </summary>
    
    
      <category term="源码" scheme="http://shenweini.cn/tags/%E6%BA%90%E7%A0%81/"/>
    
      <category term="React" scheme="http://shenweini.cn/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>void (0) ??? undefined ???</title>
    <link href="http://shenweini.cn/2019/09/10/void%20(0)%20???%20undefined%20???/"/>
    <id>http://shenweini.cn/2019/09/10/void (0) ??? undefined ???/</id>
    <published>2019-09-10T06:58:13.686Z</published>
    <updated>2019-09-10T11:36:09.242Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>今天看React的源码，发现了一个很有意思的写法，在<code>ReactChildren.js</code>中看见了这么一行代码<code>var child = void 0</code>,这个是出现在React编译之后的<code>cjs/react.development.js</code>中。在我的认知里，<code>void</code>是用来表示一个函数没有返回值的。尽然还有这种写法，是JS的神奇的magic嘛</p></blockquote><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>首先看几个示例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">void</span> <span class="number">0</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">void</span> <span class="number">100</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">void</span> <span class="literal">true</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">void</span> alert(<span class="string">'test'</span>));</span><br></pre></td></tr></table></figure><p>在看打印的结果</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">undefined</span></span><br><span class="line"><span class="literal">undefined</span></span><br><span class="line"><span class="literal">undefined</span></span><br><span class="line"><span class="literal">undefined</span></span><br></pre></td></tr></table></figure><p>结果都是<code>undefined</code></p><p>那么和<code>undefined</code> 做一个比较</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log((<span class="keyword">void</span> <span class="number">0</span>) === <span class="literal">undefined</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>可以发现 <code>void 0</code> 是可以作为<code>undefined</code> 的一个替代</p><a id="more"></a><h2 id="void-运算符"><a href="#void-运算符" class="headerlink" title="void 运算符"></a>void 运算符</h2><p>查看 MDN 的解释</p><blockquote><p>void 运算符 对给定的表达式进行求值，然后返回 undefined。</p><p>这个运算符能向期望一个表达式的值是undefined的地方插入会产生副作用的表达式。<br>void 运算符通常只用于获取 undefined的原始值，一般使用void(0)（等同于void 0）。在上述情况中，也可以使用全局变量undefined 来代替（假定其仍是默认值）。</p></blockquote><p>直白的讲就是会调用后面的表达式然后返回一个<code>undefined</code></p><p>做个示例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">void</span> (<span class="built_in">console</span>.log(<span class="string">'test console'</span>)));</span><br><span class="line"></span><br><span class="line"><span class="comment">// test console</span></span><br><span class="line"><span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>如果直接写成 <code>void 0</code> 后面的表达式没有任何操作的话，那么就是无副作用的。</p><h2 id="void-和-undefined-的区别"><a href="#void-和-undefined-的区别" class="headerlink" title="void 和 undefined 的区别"></a>void 和 undefined 的区别</h2><p><code>undefined</code>不是保留字，只是全局对象的一个属性，在低版本的ie上是可以改写的,但是我发现在chrome上也可以改写，神奇。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;今天看React的源码，发现了一个很有意思的写法，在&lt;code&gt;ReactChildren.js&lt;/code&gt;中看见了这么一行代码&lt;code&gt;var child = void 0&lt;/code&gt;,这个是出现在React编译之后的&lt;code&gt;cjs/react.development.js&lt;/code&gt;中。在我的认知里，&lt;code&gt;void&lt;/code&gt;是用来表示一个函数没有返回值的。尽然还有这种写法，是JS的神奇的magic嘛&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;示例&quot;&gt;&lt;a href=&quot;#示例&quot; class=&quot;headerlink&quot; title=&quot;示例&quot;&gt;&lt;/a&gt;示例&lt;/h2&gt;&lt;p&gt;首先看几个示例&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; alert(&lt;span class=&quot;string&quot;&gt;&#39;test&#39;&lt;/span&gt;));&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在看打印的结果&lt;/p&gt;
&lt;figure class=&quot;highlight actionscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;literal&quot;&gt;undefined&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;literal&quot;&gt;undefined&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;literal&quot;&gt;undefined&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;literal&quot;&gt;undefined&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;结果都是&lt;code&gt;undefined&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;那么和&lt;code&gt;undefined&lt;/code&gt; 做一个比较&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log((&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;) === &lt;span class=&quot;literal&quot;&gt;undefined&lt;/span&gt;); &lt;span class=&quot;comment&quot;&gt;// true&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;可以发现 &lt;code&gt;void 0&lt;/code&gt; 是可以作为&lt;code&gt;undefined&lt;/code&gt; 的一个替代&lt;/p&gt;
    
    </summary>
    
    
      <category term="js" scheme="http://shenweini.cn/tags/js/"/>
    
      <category term="magic" scheme="http://shenweini.cn/tags/magic/"/>
    
  </entry>
  
  <entry>
    <title>Nginx 反向代理 + 缓存 + 静态资源服务器 + 负载均衡</title>
    <link href="http://shenweini.cn/2019/08/23/Nginx%20%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%20+%20%E7%BC%93%E5%AD%98%20+%20%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E6%9C%8D%E5%8A%A1%E5%99%A8%20+%20%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
    <id>http://shenweini.cn/2019/08/23/Nginx 反向代理 + 缓存 + 静态资源服务器 + 负载均衡/</id>
    <published>2019-08-23T13:32:40.481Z</published>
    <updated>2019-08-23T13:32:40.482Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>nginx经常挂在嘴边的就是反向代理，不过他还可以干很多事，我所了解的只是反向代理、静态文件缓存、静态资源服务器，对于负载均衡只是略有涉及。</p></blockquote><blockquote><p>Nginx (“engine x”) 是一个高性能的 HTTP 和 反向代理 服务器 ，也是一个 IMAP/POP3/SMTP 代理 服务器 。 Nginx 是由 Igor Sysoev 为俄罗斯访问量第二的 Rambler.ru 站点开发的，第一个公开版本0.1.0发布于2004年10月4日。其将源代码以类BSD许可证的形式发布，因它的稳定性、丰富的功能集、示例配置文件和低系统资源的消耗而闻名</p></blockquote><blockquote><p>引用一下菜鸟教程的简介：Nginx功能丰富，可作为HTTP服务器，也可作为反向代理服务器，邮件服务器。支持FastCGI、SSL、Virtual Host、URL Rewrite、Gzip等功能。并且支持很多第三方的模块扩展。Nginx的稳定性、功能集、示例配置文件和低系统资源的消耗让他后来居上，在全球活跃的网站中有12.18%的使用比率，大约为2220万个网站。</p></blockquote><blockquote><p>特点<br>(1)：代理服务器，快速高效反向代理，提升网站性能。<br>(2)：负载均衡器，内部支持Rails和PHP,也可支持HTTP代理服务器，对外进行服务。同时支持简单容错和利用算法进行负载均衡。<br>(3)：性能方面，Nginx专门为性能设计，实现注重效率。采用Poll模型，可以支持更多的并发连接，并在大并发时占用很低内存。<br>(4)：稳定性方面，采用分阶段资源分配技术，使CPU资源占用率低。<br>(5)：高可用性方面，支持热备，启动迅速。</p></blockquote><a id="more"></a><h2 id="nginx安装"><a href="#nginx安装" class="headerlink" title="nginx安装"></a>nginx安装</h2><p>mac 下安装</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">brew </span><span class="keyword">install </span>nginx</span><br></pre></td></tr></table></figure><p>安装目录为 <code>/usr/local/Cellar/nginx/1.17.2/</code><br>配置文件目录为 <code>/usr/local/etc/nginx/nginx.conf</code><br>服务器默认路径 <code>/usr/local/var/www</code></p><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><p>mac 下的启动命令</p><ul><li><p>启动 <code>nginx</code></p></li><li><p>快速停止关闭 <code>nignx -s stop</code></p></li><li><p>优雅的关闭 <code>nginx -s quit</code></p></li><li><p>承载配置文件 <code>nginx -s reload</code></p></li><li><p>查看nginx进程 <code>ps -ef | grep nginx</code></p></li><li><p>查看配置文件是否正确 <code>nginx -t</code></p></li><li><p>优雅的杀死nginx进程 <code>kill -quit 进程号</code></p></li><li><p>快速的杀死nginx进程 <code>kill -term 进程号</code></p></li></ul><h2 id="nginx配置"><a href="#nginx配置" class="headerlink" title="nginx配置"></a>nginx配置</h2><p>nginx 文件的默认配置文件位置 <code>/usr/local/etc/nginx/nginx.conf</code></p><p>打开 <code>/usr/local/etc/nginx/</code> 目录可以看到，里面有很多的配置文件，启动有一个<code>nginx.conf</code> 和 <code>nginx.conf.default</code>两个配置文件,刚开始安装的时候，两个文件的内容是一样的，所以我们可以肆意的修改<code>nginx.conf</code>搞崩的话就直接把<code>nginx.conf.default</code>中的内容复制过来就行了又是一个新的nginx。</p><h3 id="配置文件架构"><a href="#配置文件架构" class="headerlink" title="配置文件架构"></a>配置文件架构</h3><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// nginx全局块</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// events块</span></span><br><span class="line">events &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// http 块</span></span><br><span class="line">http &#123;</span><br><span class="line">    <span class="comment">// http全局块</span></span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// server块</span></span><br><span class="line">    server &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// http全局块</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="配置文件加注释说明"><a href="#配置文件加注释说明" class="headerlink" title="配置文件加注释说明"></a>配置文件加注释说明</h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># 配置nginx的用户组 默认为nobody</span></span><br><span class="line"><span class="meta">#user  nobody;</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># 配置nginx的主线程数量 nginx是一个主线程下面多个子线程</span></span><br><span class="line">worker_processes  <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta"># 配置nginx的错误日志 格式为 log路径 log级别</span></span><br><span class="line"><span class="meta"># error_log 的日志级别为： debug info notice warn <span class="meta-keyword">error</span> crit alert emerg 紧急由低到高</span></span><br><span class="line"><span class="meta"># error_log的默认日志级别为<span class="meta-keyword">error</span>，那么就只有紧急程度大于等于<span class="meta-keyword">error</span>的才会记录在日志</span></span><br><span class="line"><span class="meta"># error_log 的作用域为 main http mail stream server location</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#error_log  logs/<span class="meta-keyword">error</span>.log;</span></span><br><span class="line"><span class="meta">#error_log  logs/<span class="meta-keyword">error</span>.log  notice;</span></span><br><span class="line"><span class="meta">#error_log  logs/<span class="meta-keyword">error</span>.log  info;</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># 指定nginx进程运行文件存放地址</span></span><br><span class="line"><span class="meta">#pid        logs/nginx.pid;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    <span class="meta"># poll是多路复用IO中的一种方式,但是仅用于linux2.6以上内核,可以大大提高nginx的性能</span></span><br><span class="line">    <span class="meta"># use poll</span></span><br><span class="line">    </span><br><span class="line">    <span class="meta"># 设置网络的连接序列化 防止惊群现象发生 默认为 on</span></span><br><span class="line">    <span class="meta"># accept_mutex on;</span></span><br><span class="line">    </span><br><span class="line">    <span class="meta"># 设置一个进程是否同时接受多个网络连接 默认为 off</span></span><br><span class="line">    <span class="meta"># multi_accept off</span></span><br><span class="line">    </span><br><span class="line">    <span class="meta"># 最大连接数 默认为 512</span></span><br><span class="line">    worker_connections  <span class="number">1024</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    <span class="meta"># 文件扩展名和文件类型映射表</span></span><br><span class="line">    include       mime.types;</span><br><span class="line">    </span><br><span class="line">    <span class="meta"># 默认文件类型</span></span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line">    </span><br><span class="line">    <span class="meta"># 日志格式 文章后面会介绍</span></span><br><span class="line">    <span class="meta">#log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '</span></span><br><span class="line">    <span class="meta">#                  '$status $body_bytes_sent "$http_referer" '</span></span><br><span class="line">    <span class="meta">#                  '"$http_user_agent" "$http_x_forwarded_for"';</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 允许通过日志配置</span></span><br><span class="line">    <span class="meta">#access_log  logs/access.log  main;</span></span><br><span class="line">    </span><br><span class="line">    <span class="meta"># sendfile 指定使用 sendfile 系统调用来传输文件。优点在于在两个文件描述符之间传递数据（完全在内核中操作），从而避免了数据在内核缓冲区和用户缓冲区之间的拷贝，效率高，称之为零拷贝，这个东西有点讲究，自行百度</span></span><br><span class="line">    <span class="meta"># sendfile 作用域 location server http</span></span><br><span class="line">    sendfile        <span class="keyword">on</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">#tcp_nopush     on;</span></span><br><span class="line">    </span><br><span class="line">    <span class="meta"># 链接超时时间 默认 75s 作用域 http server location</span></span><br><span class="line">    <span class="meta">#keepalive_timeout  0;</span></span><br><span class="line">    keepalive_timeout  <span class="number">65</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="meta"># 开始gzip压缩</span></span><br><span class="line">    <span class="meta">#gzip  on;</span></span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        <span class="meta"># 端口号</span></span><br><span class="line">        listen       <span class="number">8080</span>;</span><br><span class="line">        <span class="meta"># 域名或ip</span></span><br><span class="line">        server_name  localhost;</span><br><span class="line"></span><br><span class="line">        <span class="meta">#charset koi8-r;</span></span><br><span class="line"></span><br><span class="line">        <span class="meta">#access_log  logs/host.access.log  main;</span></span><br><span class="line">        </span><br><span class="line">        <span class="meta"># 对请求的路由进行过滤 正则匹配</span></span><br><span class="line">        location / &#123;</span><br><span class="line">            root   html;</span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    include servers<span class="comment">/*;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="nginx-日志"><a href="#nginx-日志" class="headerlink" title="nginx 日志"></a>nginx 日志</h2><p>nginx的日志大致分为 <code>access_log</code> 和 <code>error_log</code>。error_log 记录的是nginx的错误日志。（以下对日志的理解不是很全面，还只是基础的）</p><h3 id="error-log"><a href="#error-log" class="headerlink" title="error_log"></a>error_log</h3><ul><li>记录nginx错误日志</li><li>作用域为 <code>main http mail stream server location</code></li><li>日志级别 <code>debug info notice warn error crit alert emerg</code></li><li>日志级别默认为 error 当级别高于或等于指定级别时才会记录</li></ul><h3 id="access-log"><a href="#access-log" class="headerlink" title="access_log"></a>access_log</h3><ul><li>记录请求通过的日志</li><li>作用域为 <code>http server location limit_except</code></li><li>日志格式默认为 <code>combined</code></li><li>日志格式是可以自定义的</li></ul><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义一个为 main 的日志格式</span></span><br><span class="line"><span class="attribute">log_format</span>  main  <span class="string">'<span class="variable">$remote_addr</span> - <span class="variable">$remote_user</span> [<span class="variable">$time_local</span>] "<span class="variable">$request</span>" '</span></span><br><span class="line">                      <span class="string">'<span class="variable">$status</span> <span class="variable">$body_bytes_sent</span> "<span class="variable">$http_referer</span>" '</span></span><br><span class="line">                      <span class="string">'"<span class="variable">$http_user_agent</span>" "<span class="variable">$http_x_forwarded_for</span>"'</span>;</span><br><span class="line">                      </span><br><span class="line"><span class="attribute">access_log</span>  logs/access.log  main;</span><br></pre></td></tr></table></figure><p>上方的 <code>log_format</code> 后面类似 <code>$remote_addr</code> 是nginx的内置变量，取值如下<br><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"><span class="meta-keyword">$remote</span>_addr, $http_x_forwarded_for（反向） 记录客户端IP地址</span></span><br><span class="line"><span class="meta"><span class="meta-keyword">$remote</span>_user 记录客户端用户名称</span></span><br><span class="line"><span class="meta"><span class="meta-keyword">$request</span> 记录请求的URL和HTTP协议</span></span><br><span class="line"><span class="meta"><span class="meta-keyword">$status</span> 记录请求状态</span></span><br><span class="line"><span class="meta"><span class="meta-keyword">$body</span>_bytes_sent 发送给客户端的字节数，不包括响应头的大小； 该变量与Apache模块mod_log_config里的“%B”参数兼容。</span></span><br><span class="line"><span class="meta"><span class="meta-keyword">$bytes</span>_sent 发送给客户端的总字节数。</span></span><br><span class="line"><span class="meta"><span class="meta-keyword">$connection</span> 连接的序列号。</span></span><br><span class="line"><span class="meta"><span class="meta-keyword">$connection</span>_requests 当前通过一个连接获得的请求数量。</span></span><br><span class="line"><span class="meta"><span class="meta-keyword">$msec</span> 日志写入时间。单位为秒，精度是毫秒。</span></span><br><span class="line"><span class="meta"><span class="meta-keyword">$pipe</span> 如果请求是通过HTTP流水线(pipelined)发送，pipe值为“p”，否则为“.”。</span></span><br><span class="line"><span class="meta"><span class="meta-keyword">$http</span>_referer 记录从哪个页面链接访问过来的</span></span><br><span class="line"><span class="meta"><span class="meta-keyword">$http</span>_user_agent 记录客户端浏览器相关信息</span></span><br><span class="line"><span class="meta"><span class="meta-keyword">$request</span>_length 请求的长度（包括请求行，请求头和请求正文）。</span></span><br><span class="line"><span class="meta"><span class="meta-keyword">$request</span>_time 请求处理时间，单位为秒，精度毫秒； 从读入客户端的第一个字节开始，直到把最后一个字符发送给客户端后进行日志写入为止。</span></span><br><span class="line"><span class="meta"><span class="meta-keyword">$time</span>_iso8601 ISO8601标准格式下的本地时间。</span></span><br><span class="line"><span class="meta"><span class="meta-keyword">$time</span>_local 通用日志格式下的本地时间。</span></span><br></pre></td></tr></table></figure></p><h2 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h2><h3 id="正向代理-反向代理"><a href="#正向代理-反向代理" class="headerlink" title="正向代理 反向代理"></a>正向代理 反向代理</h3><ul><li>正向代理大概的意思就是，客户端发送一个请求，这个请求包含服务器地址，那么代理服务器收到了请求后会将请求发送到客户端指定的服务器，并将响应内容传递给客户端，在这个过程中，客户端是知道请求的服务器地址的，但是服务器是不知道哪个客户端请求的。VPN做的就是这个事。</li><li>反向代理大概的意思就是，客户端发送一个请求给代理服务器，由代理服务器来决定这个请求该交给哪个服务器，这就是实现了服务器负载均衡，可以将请求转发到比较空闲的服务器来响应，这个时候，代理服务器就是相对于客户端的服务器，因为此时客户端也不知道请求交给了哪个服务器。</li></ul><p>我所理解的正向代理和反向代理就是这个意思，如有错误欢迎下方评论。</p><h3 id="proxy-pass"><a href="#proxy-pass" class="headerlink" title="proxy_pass"></a>proxy_pass</h3><p>那么nginx使用的就是<code>proxy_pass</code>属性来进行反向代理的处理，使用也是很简单。下面以nodejs开启一个建立在 localhost:4000 的服务</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"></span><br><span class="line">http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>)</span>&#123;</span><br><span class="line">    res.writeHead(<span class="number">200</span>, &#123;<span class="string">'Content-Type'</span>: <span class="string">'text/plain'</span>&#125;);</span><br><span class="line">    res.end(<span class="string">'server 4000'</span>);</span><br><span class="line">&#125;).listen(<span class="number">4000</span>);</span><br></pre></td></tr></table></figure><p>请求 <code>localhost:4000</code> 可以打开我们的页面</p><p><img src="http://static.zybuluo.com/shenweizheng/pdz5sg6oeac5ui35uf7oft28/image_1disp1dvl1fii1dhj1dlk1qrnbuj9.png" alt="image_1disp1dvl1fii1dhj1dlk1qrnbuj9.png-13.8kB"></p><p>那么我们需要做的是将 <code>localhost:5000</code>的所有请求都代理到4000这个server里，这样就会出现我们访问5000和访问4000一样的效果。具体配置如下</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">        <span class="comment"># 监听 localhost:5000</span></span><br><span class="line">        <span class="attribute">listen</span>     <span class="number">5000</span>;</span><br><span class="line">        <span class="attribute">server_name</span> localhost;</span><br><span class="line">        <span class="comment"># / 表示匹配所有的请求，所有的请求都会经过这个过滤器</span></span><br><span class="line">        <span class="attribute">location</span> / &#123;</span><br><span class="line">            <span class="comment"># 设定请求转发的地址</span></span><br><span class="line">        <span class="attribute">proxy_pass</span> http://localhost:4000;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这边需要注意的是 <code>proxy_pass</code> 的写法，必须是<code>http://</code>或者<code>https://</code>开头的，http头是不能省的。</p><p>请求5000端口效果如下：</p><p><img src="http://static.zybuluo.com/shenweizheng/ej0dbxfapbx9f29dhvknejxq/image_1dispgpetav110mb1tqkf718ufm.png" alt="image_1dispgpetav110mb1tqkf718ufm.png-15.9kB"></p><h3 id="本地代理至百度"><a href="#本地代理至百度" class="headerlink" title="本地代理至百度"></a>本地代理至百度</h3><p>上方的例子过于简单，那么这一个和上面的有点类似，这次是将4000的端口号代理到<code>www.baidu.com</code>。修改一下<code>proxy_pass</code></p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">        <span class="comment"># 监听 localhost:5000</span></span><br><span class="line">        <span class="attribute">listen</span>     <span class="number">5000</span>;</span><br><span class="line">        <span class="attribute">server_name</span> localhost;</span><br><span class="line">        <span class="comment"># / 表示匹配所有的请求，所有的请求都会经过这个过滤器</span></span><br><span class="line">        <span class="attribute">location</span> / &#123;</span><br><span class="line">            <span class="comment"># 设定请求转发的地址</span></span><br><span class="line">        <span class="attribute">proxy_pass</span> https://www.baidu.com;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就可以了，至于这边写的是<code>http</code> 还是 <code>https</code>，这个倒是不影响，因为百度内部会自动将<code>http</code>转成<code>https</code>毕竟安全嘛。</p><h3 id="百度代理至本地"><a href="#百度代理至本地" class="headerlink" title="百度代理至本地"></a>百度代理至本地</h3><p>那么按照刚刚的思路就是监听 <code>www.baidu.com</code> 然后设置一下 <code>proxy_pass</code> 为 <code>localhost:4000</code></p><p>配置如下</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span>     <span class="number">80</span>;</span><br><span class="line">        <span class="attribute">server_name</span> www.baidu.com;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">location</span> / &#123;</span><br><span class="line">        <span class="attribute">proxy_pass</span> http://localhost:4000;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>试一下，是不是没有用，没有用就对了。要是这么轻松的搞定<code>nginx</code>还玩个蛋。那么这个里面又有点操作了，先看正确的配置，修改本地的hosts文件，mac下的文件位置为 <code>/etc/hosts</code>但是需要 sudo 来进行修改，毕竟这个文件比较重要嘛</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim <span class="regexp">/etc/</span>hosts</span><br></pre></td></tr></table></figure><p>添加一句</p><p><img src="http://static.zybuluo.com/shenweizheng/guwjrur3gs80l7quyukxa71j/image_1div5kqsk1jpe7gg10jg18k01g.png" alt="image_1div5kqsk1jpe7gg10jg18k01g.png-4.1kB"></p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span>     <span class="number">80</span>;</span><br><span class="line">        <span class="attribute">server_name</span> baidu.com;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">location</span> / &#123;</span><br><span class="line">        <span class="attribute">proxy_pass</span> http://127.0.0.1:4000;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般在本地开发的时候我们都会修改本地的<code>hosts</code>文件，但是会遇到一个问题就是有的时候是有用的有的时候又没用了，我这边的解决办法是，每次修改完<code>hosts</code>文件就清楚浏览器的浏览数据，尤其是缓存这一块的东西。</p><p><img src="http://static.zybuluo.com/shenweizheng/fj2rw8j3zvjzt43tmmukwrf0/image_1div63u0e1s6j18fgtr11vhq101h1t.png" alt="image_1div63u0e1s6j18fgtr11vhq101h1t.png-105.2kB"></p><p>如果遇到nginx配置完全正确<code>hosts</code>文件也配置了，但是还是没有用，不妨清一下缓存，至少在我这是每次都是清完缓存才有用的。</p><h2 id="nginx跨域"><a href="#nginx跨域" class="headerlink" title="nginx跨域"></a>nginx跨域</h2><p>跨域的解决办法就是在<code>header</code>里面加上允许跨域的源等信息</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;  </span><br><span class="line">    add_header <span class="keyword">Access</span>-Control-Allow-Origin *;</span><br><span class="line">    add_header <span class="keyword">Access</span>-Control-Allow-Methods <span class="symbol">'GET</span>, POST, OPTIONS';</span><br><span class="line">    add_header <span class="keyword">Access</span>-Control-Allow-Headers <span class="symbol">'DNT</span>,X-Mx-ReqToken,Keep-Alive,User-Agent,X-Requested-<span class="keyword">With</span>,<span class="keyword">If</span>-Modified-Since,Cache-Control,Content-<span class="keyword">Type</span>,Authorization';</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ($request_method = <span class="symbol">'OPTIONS</span>') &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">204</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是在实际项目里。<code>origin</code>还是不要设置为<code>*</code>比较好，因为前端使用axios的话在获取session这一块会出现问题。</p><h2 id="nginx缓存"><a href="#nginx缓存" class="headerlink" title="nginx缓存"></a>nginx缓存</h2><blockquote><p>这边有一个需要注意的地方，nginx作为静态资源服务器的时候是不做缓存的，只有当nginx进行反向代理的时候才具备缓存这个功能。我一开始写了半天发现鸟用都没有，最后才发现只有做代理的时候才具备缓存。</p></blockquote><p>各大浏览器本身已经具有缓存了，比如说谷歌，我们可以写一个html，然后在html引入一张图片，我们可以看看浏览器是怎么对图片这些静态资源进行缓存的。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"./static/test.jpg"</span> <span class="attr">alt</span>=<span class="string">""</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这个html代码我使用<code>http-server</code>部署在了<code>http-server -a 127.0.0.1 -p 4000</code>可以看出是在<code>127.0.0.1 4000</code>端口。</p><p>这是首次加载的时候的状况</p><p><img src="http://static.zybuluo.com/shenweizheng/9q4w4k01dez4fpr3s5nfp96p/image_1div6rf381gma14094n10vib32q.png" alt="image_1div6rf381gma14094n10vib32q.png-31.3kB"></p><p>刷新一下</p><p><img src="http://static.zybuluo.com/shenweizheng/5rep6dzl2or6zjqe66yxy4xy/image_1div6slsb1niq1atp1oonksd1ubt37.png" alt="image_1div6slsb1niq1atp1oonksd1ubt37.png-28.4kB"></p><p>那么区别还是很大的</p><ul><li><code>html</code>文件的状态码从200到304，304状态码表明该文件是从缓存中读取</li><li><code>jpg</code>文件可以发现在<code>size</code>这一列，多了一个<code>memory cache</code>，这表明这个图片是从浏览器缓存中读取的</li><li>各个文件的加载事件明显减少，尤其是图片</li></ul><p>可能有的人会发现第一次加载的时候，显示的是<code>from desk cache</code>，那么chrome浏览器的缓存分为两种，一种是磁盘缓存一种是内存缓存，</p><p>官方文档：</p><blockquote><p>Chrome employs two caches — an on-disk cache and a very fast in-memory cache. The lifetime of an in-memory cache is attached to the lifetime of a render process, which roughly corresponds to a tab. Requests that are answered from the in-memory cache are invisible to the web request API. If a request handler changes its behavior (for example, the behavior according to which requests are blocked), a simple page refresh might not respect this changed behavior. To make sure the behavior change goes through, call handlerBehaviorChanged() to flush the in-memory cache. But don’t do it often; flushing the cache is a very expensive operation. You don’t need to call handlerBehaviorChanged() after registering or unregistering an event listener.</p></blockquote><p>大概意思就是：chrome有两种缓存，一种是<code>desk cache</code>一种是<code>memory cache</code>，然后<code>memory cache</code>的效率高于前者。</p><p>那么打开chrome devtools点开图片可以发现</p><p><img src="http://static.zybuluo.com/shenweizheng/q9u7y601st5mogf7kuh24cfv/image_1div7hhk3no5hfq1jft2j41t43k.png" alt="image_1div7hhk3no5hfq1jft2j41t43k.png-39.4kB"></p><p>在<code>cache-control</code>后面有一个<code>max-age</code>，那么具体的有关缓存的技术这边就不说了我回头整理一下</p><p>那么针对不同类型的文件进行缓存还是很简单的，需要注意的在于<code>location</code>的正则匹配</p><p>那么第一种最简单的缓存，就是直接设置<code>expires 缓存时间</code></p><h3 id="设置expires"><a href="#设置expires" class="headerlink" title="设置expires"></a>设置<code>expires</code></h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span> <span class="regexp">~ .*\.(jpg|png)$</span> &#123;</span><br><span class="line"><span class="attribute">proxy_pass</span> http://127.0.0.1:4000;</span><br><span class="line">    <span class="attribute">expires</span> <span class="number">3m</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://static.zybuluo.com/shenweizheng/rfve3ikhd0makef97uluzfdm/image_1div8c7nk1jv05ds1tvo1a7n1bm841.png" alt="image_1div8c7nk1jv05ds1tvo1a7n1bm841.png-44.2kB"></p><p><code>expires</code>是以秒为单位的，那么我们设置为<code>3m</code> 也就是180秒，发现确实是可以的。</p><h3 id="proxy-cache-path-的使用"><a href="#proxy-cache-path-的使用" class="headerlink" title="proxy_cache_path 的使用"></a>proxy_cache_path 的使用</h3><p>那么我们也可以指定我们的nginx缓存目录，通过proxy_cache_path 属性</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">proxy_cache_path</span> /tmp/cache/test levels=<span class="number">1</span>:<span class="number">2</span> keys_zone=my_cache:<span class="number">10m</span> max_size=<span class="number">10g</span> inactive=<span class="number">60m</span> use_temp_path=<span class="literal">off</span>;</span><br><span class="line"><span class="attribute">location</span> <span class="regexp">~ .*\.(jpg|png)$</span> &#123;</span><br><span class="line"> <span class="attribute">proxy_pass</span> http://127.0.0.1:4000;</span><br><span class="line"> <span class="attribute">proxy_cache</span> my_cache;</span><br><span class="line"> <span class="attribute">proxy_cache_valid</span> <span class="number">200</span> <span class="number">304</span> <span class="number">1y</span>;</span><br><span class="line"> <span class="attribute">proxy_cache_valid</span> any <span class="number">1m</span>;</span><br><span class="line"> <span class="attribute">expires</span> <span class="number">1y</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>proxy_cache_path 执行缓存文件的目录，如果没有的话需要提前创建，不然nginx会报错</li><li>levels 采用2级目录来存储</li><li>key_zone 在共享内存中设置一块存储区域来存放缓存的key和metadata（类似使用次数），这样nginx可以快速判断一个request是否命中或者未命中缓存，1m可以存储8000个key，10m可以存储80000个key</li><li>max_size 最大cache空间，如果不指定，会使用掉所有disk space，当达到配额后，会删除最少使用的cache文件</li><li>inactive 未被访问文件在缓存中保留时间，在指定时间内未被访问的文件会被删除</li><li>use_temp_path 如果为off，则nginx会将缓存文件直接写入指定的cache文件中，而不是使用temp_path存储，official建议为off，避免文件在不同文件系统中不必要的拷贝；</li><li>proxy_cache 启用proxy cache，对应着配置的key_zone;</li><li>proxy_cache_valid 根据不同的状态码设置不同的缓存时间</li></ul><p>可以查看一下<code>nginx</code>进程，会发现这个时候是有缓存的进程在开着的。</p><p><img src="http://static.zybuluo.com/shenweizheng/stieixi5zmk6iemyo0h7gjzt/image_1div91gppe5h1n0gh751eqv13u54e.png" alt="image_1div91gppe5h1n0gh751eqv13u54e.png-75.1kB"></p><p>这边可以看到，我们的图片的缓存时间已经被设置为1年</p><p><img src="http://static.zybuluo.com/shenweizheng/k8jfc8inqt864uvifo3qe98e/image_1div9h7o75lk4vgdqv1iidk5v4r.png" alt="image_1div9h7o75lk4vgdqv1iidk5v4r.png-45.4kB"></p><h3 id="location匹配优先级"><a href="#location匹配优先级" class="headerlink" title="location匹配优先级"></a>location匹配优先级</h3><p>在缓存中需要注意的一点就是location的匹配规则和优先级</p><ul><li>= 开头表示精确匹配</li><li>^~ 开头表示uri以某个常规字符串开头，不是正则匹配;</li><li>~ 开头表示区分大小写的正则匹配;</li><li>~* 开头表示不区分大小写的正则匹配;</li><li>/ 通用匹配, 如果没有其它匹配,任何请求都会匹配到;</li></ul><h2 id="upstream负载均衡"><a href="#upstream负载均衡" class="headerlink" title="upstream负载均衡"></a>upstream负载均衡</h2><p>负载均衡是nginx的另一大特点，可以配置多个服务器，将请求分发到最合适的那台服务器，避免某一台服务器请求太多而崩溃。使用<code>upstream</code>属性来配置</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">upstream</span> favtomcat &#123;</span><br><span class="line">       <span class="attribute">server</span> <span class="number">192.168.1.100:4000</span>;</span><br><span class="line">       <span class="attribute">server</span> <span class="number">192.168.1.111:5000</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="attribute">location</span> / &#123;</span><br><span class="line">            <span class="attribute">root</span>   html;</span><br><span class="line">            <span class="attribute">index</span>  index.html index.htm;</span><br><span class="line">            <span class="comment"># 对应上方的 favtomcat</span></span><br><span class="line">            <span class="attribute">proxy_pass</span> http://favtomcat;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是最基础的负载均衡配置，采用的是<code>轮询</code>的策略进行负载，每个请求按时间顺序逐一分配到不同的后端服务器，适用于图片服务器集群和纯静态页面服务器集群。<br>优点： 方式简便、成本低廉<br>缺点： 可靠性低和负载分配不均衡</p><p>那么<code>upstream</code>还有其他的负载策略</p><h3 id="weight权重"><a href="#weight权重" class="headerlink" title="weight权重"></a>weight权重</h3><p>可以给每一台服务器设置一个权重，这样权重高的干的活也就会多一点</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">upstream favtomcat &#123;</span><br><span class="line">      <span class="built_in"> server </span>192.168.1.100:4000 <span class="attribute">weight</span>=5;</span><br><span class="line">      <span class="built_in"> server </span>192.168.1.111:5000 <span class="attribute">weight</span>=10;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ip-hash"><a href="#ip-hash" class="headerlink" title="ip_hash"></a>ip_hash</h3><p>这种方式是基于客户端的ip地址，采用hash算法计算下一个请求要选择哪一个服务器，这样固定的ip会访问同一个服务器，可以解决session问题</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">upstream favtomcat &#123;</span><br><span class="line">       ip_hash;</span><br><span class="line">      <span class="built_in"> server </span>192.168.1.100:4000;</span><br><span class="line">      <span class="built_in"> server </span>192.168.1.111:5000;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="least-conn最少链接"><a href="#least-conn最少链接" class="headerlink" title="least_conn最少链接"></a>least_conn最少链接</h3><p>会将下一个请求分发到当前链接数最少的一台服务器<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">upstream favtomcat &#123;</span><br><span class="line">       least_conn;</span><br><span class="line">      <span class="built_in"> server </span>192.168.1.100:4000;</span><br><span class="line">      <span class="built_in"> server </span>192.168.1.111:5000;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="fair"><a href="#fair" class="headerlink" title="fair"></a>fair</h3><p>按后端服务器的响应时间来分配请求，响应时间短的优先分配。<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">upstream favtomcat &#123;</span><br><span class="line">       fair;</span><br><span class="line">      <span class="built_in"> server </span>192.168.1.100:4000;</span><br><span class="line">      <span class="built_in"> server </span>192.168.1.111:5000;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="url-hash"><a href="#url-hash" class="headerlink" title="url_hash"></a>url_hash</h3><p>按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">upstream backserver &#123; </span><br><span class="line">   <span class="built_in"> server </span>squid1:3128; </span><br><span class="line">   <span class="built_in"> server </span>squid2:3128; </span><br><span class="line">    hash <span class="variable">$request_uri</span>; </span><br><span class="line">    hash_method crc32; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>参考<br><a href="https://juejin.im/post/59f94f626fb9a045023af34c；" target="_blank" rel="noopener">https://juejin.im/post/59f94f626fb9a045023af34c；</a><br><a href="https://www.jianshu.com/p/625c2b15dad5" target="_blank" rel="noopener">Nginx Proxy Cache原理和最佳实践</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;nginx经常挂在嘴边的就是反向代理，不过他还可以干很多事，我所了解的只是反向代理、静态文件缓存、静态资源服务器，对于负载均衡只是略有涉及。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Nginx (“engine x”) 是一个高性能的 HTTP 和 反向代理 服务器 ，也是一个 IMAP/POP3/SMTP 代理 服务器 。 Nginx 是由 Igor Sysoev 为俄罗斯访问量第二的 Rambler.ru 站点开发的，第一个公开版本0.1.0发布于2004年10月4日。其将源代码以类BSD许可证的形式发布，因它的稳定性、丰富的功能集、示例配置文件和低系统资源的消耗而闻名&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;引用一下菜鸟教程的简介：Nginx功能丰富，可作为HTTP服务器，也可作为反向代理服务器，邮件服务器。支持FastCGI、SSL、Virtual Host、URL Rewrite、Gzip等功能。并且支持很多第三方的模块扩展。Nginx的稳定性、功能集、示例配置文件和低系统资源的消耗让他后来居上，在全球活跃的网站中有12.18%的使用比率，大约为2220万个网站。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;特点&lt;br&gt;(1)：代理服务器，快速高效反向代理，提升网站性能。&lt;br&gt;(2)：负载均衡器，内部支持Rails和PHP,也可支持HTTP代理服务器，对外进行服务。同时支持简单容错和利用算法进行负载均衡。&lt;br&gt;(3)：性能方面，Nginx专门为性能设计，实现注重效率。采用Poll模型，可以支持更多的并发连接，并在大并发时占用很低内存。&lt;br&gt;(4)：稳定性方面，采用分阶段资源分配技术，使CPU资源占用率低。&lt;br&gt;(5)：高可用性方面，支持热备，启动迅速。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="nginx" scheme="http://shenweini.cn/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>node.js Express框架中使用websoecket 包含 ts 和 非 ts 环境</title>
    <link href="http://shenweini.cn/2019/08/19/node.js%20Express%E6%A1%86%E6%9E%B6%E4%B8%AD%E4%BD%BF%E7%94%A8websoecket%20%E5%8C%85%E5%90%AB%20ts%20%E5%92%8C%20%E9%9D%9E%20ts%20%E7%8E%AF%E5%A2%83/"/>
    <id>http://shenweini.cn/2019/08/19/node.js Express框架中使用websoecket 包含 ts 和 非 ts 环境/</id>
    <published>2019-08-19T13:32:00.741Z</published>
    <updated>2019-08-19T13:32:00.741Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>websocket是啥我就简单的说一下，这个大家知道的应该挺多的。那么首先它是一个协议，类似于我们的HTTP协议，但是不同的是HTTP协议是客户端向服务器端请求，然后服务器端响应并且只能响应一次，但是无法做到服务器端主动向浏览器端推送数据。那么websocket主要就是解决服务器端无法向客户端主动推送数据的。当我们需要保持一种长链接时，我们就需要用到websocket<br>使用场景如下：浏览器发起请求，这个请求会经历大量的计算，并且返回给浏览器当前计算到了哪一步，这个时候浏览器就可以展示一个弹窗告诉用户当前已经到了哪一步，适当的更可以展示一个进度条，避免用户因为请求时间太长看久了loading也会腻不是。<br>它的主要特点就是，服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话<br>特点包括：<br>（1）建立在 TCP 协议之上，服务器端的实现比较容易。<br>（2）与 HTTP 协议有着良好的兼容性。默认端口也是80和443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。<br>（3）数据格式比较轻量，性能开销小，通信高效。<br>（4）可以发送文本，也可以发送二进制数据。<br>（5）没有同源限制，客户端可以与任意服务器通信。<br>（6）协议标识符是ws（如果加密，则为wss），服务器网址就是 URL。</p></blockquote><a id="more"></a><h2 id="服务器端"><a href="#服务器端" class="headerlink" title="服务器端"></a>服务器端</h2><p>这边是用node.js 的express框架进行操作,使用<code>express-ws</code>插件</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm <span class="selector-tag">i</span> -S express-ws</span><br></pre></td></tr></table></figure><h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><p>使用express-ws插件对app进行操作，对于不是ts环境下的通过</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> express <span class="keyword">from</span> <span class="string">'express'</span>;</span><br><span class="line"><span class="keyword">import</span> expressWs <span class="keyword">from</span> <span class="string">'express-ws'</span>;</span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line">app = expressWs(app);</span><br></pre></td></tr></table></figure><p>对于 ts 环境下的操作<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> express <span class="keyword">from</span> <span class="string">'express'</span>;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> expressWs <span class="keyword">from</span> <span class="string">'express-ws'</span>;</span><br><span class="line"><span class="keyword">const</span> appBase = express();</span><br><span class="line"><span class="comment">// 引入 websocket</span></span><br><span class="line"><span class="keyword">let</span> wsInstance = expressWs(appBase);</span><br><span class="line"><span class="keyword">let</span> &#123; app &#125; = wsInstance;</span><br></pre></td></tr></table></figure></p><p>获取到实例之后，可以通过app.ws进行操作了</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">//</span> 设置websocket</span><br><span class="line">app.ws(<span class="string">'/autoSchedule'</span>, <span class="function"><span class="params">(ws, req)</span> =&gt;</span> &#123;</span><br><span class="line">    ws.send(<span class="string">'已连接'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>之前看到有说可以通过router进行使用ws，因为router相当于一个mini 的app实例，但是我在ts环境下试了很多次都没有成功,比如说一下代码<br><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> expres <span class="keyword">from</span> <span class="string">'express'</span>;</span><br><span class="line"><span class="keyword">import</span> expressWs <span class="keyword">from</span> <span class="string">'express-ws'</span>;</span><br><span class="line">const router = expressWs(express().Router());</span><br><span class="line">router.ws(<span class="string">'/autoSchedule'</span>, <span class="function"><span class="params">(ws, req)</span> =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>这种方式也是需要app做<code>expressWS(app)</code>操作的。但是在ts下我没有试成功过，一直包的是router没有ws方法，或者是<code>expressWs(express().Router())</code>操作时说router不是一个app实例。总之很神奇。那么我采用的方法是，将我的业务代码封装成一个大的函数然后通过模块导出，在app.ts文件下引用使用，这个操作的关键在于需要将<code>app.ws(&#39;/autoSchedule&#39;,(ws: any, req: any))</code>回调函数中的ws传递给该函数，已达到模块划分的目的.</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// app.ts</span></span><br><span class="line"><span class="comment">// 引入封装好的函数模块</span></span><br><span class="line"><span class="keyword">import</span> scheduleWs <span class="keyword">from</span> <span class="string">'./src/util/autoSchedule'</span>;</span><br><span class="line"><span class="comment">// 设置websocket</span></span><br><span class="line">app.ws(<span class="string">'/autoSchedule'</span>, <span class="function">(<span class="params">ws: <span class="built_in">any</span>, req: <span class="built_in">any</span></span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 将 ws 传递给函数</span></span><br><span class="line">    scheduleWs(ws);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">util/autoSchedule.ts</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> (ws: any) =&gt; &#123;</span><br><span class="line">    ws.send(<span class="string">'开始调用'</span>);</span><br><span class="line">    <span class="comment">// 业务代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a>特别说明</h2><p>websocket在执行<code>send</code>方法，发送信息的时候，<code>send</code>函数的参数只支持字符串、二进制数据。所以我一般会将所需要的数据转成 JSON字符串，然后在前端在解析，例如</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 服务器端</span></span><br><span class="line"><span class="selector-tag">ws</span><span class="selector-class">.send</span>(JSON.stringify(&#123;</span><br><span class="line">    <span class="attribute">code</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attribute">msg</span>: <span class="string">'开始调度'</span></span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 客户端</span></span><br><span class="line">ws.onmessage = <span class="function">(<span class="params">e: <span class="built_in">any</span></span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> res: <span class="built_in">any</span> = <span class="built_in">JSON</span>.parse(e.data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行完全部任务时，记得关闭socket连接<br><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ws.close()<span class="comment">;</span></span><br></pre></td></tr></table></figure></p><h2 id="客户端的API"><a href="#客户端的API" class="headerlink" title="客户端的API"></a>客户端的API</h2><h3 id="websocket实例化"><a href="#websocket实例化" class="headerlink" title="websocket实例化"></a>websocket实例化</h3><p>websocket协议的接口地址是以 ws 开头</p><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ws = <span class="keyword">new</span> WebSocket(<span class="string">'ws://localhost:3000/autoSchedule'</span>);</span><br></pre></td></tr></table></figure><h3 id="websocket-的状态"><a href="#websocket-的状态" class="headerlink" title="websocket 的状态"></a>websocket 的状态</h3><ul><li>CONNECTING：值为0，表示正在连接</li><li>OPEN：值为1，表示连接成功，可以通信了</li><li>CLOSING：值为2，表示连接正在关闭</li><li>CLOSED：值为3，表示连接已经关闭，或者打开连接失败</li></ul><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (ws.readyState) &#123;</span><br><span class="line">  <span class="keyword">case</span> WebSocket.<span class="string">CONNECTING:</span></span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> WebSocket.<span class="string">OPEN:</span></span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> WebSocket.<span class="string">CLOSING:</span></span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> WebSocket.<span class="string">CLOSED:</span></span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"><span class="symbol">  default:</span></span><br><span class="line">    <span class="comment">// this never happens</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="websocket-open"><a href="#websocket-open" class="headerlink" title="websocket.open"></a>websocket.open</h3><p>监听连接开启</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ws.onopen = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'已连接'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="websocket-close"><a href="#websocket-close" class="headerlink" title="websocket.close"></a>websocket.close</h3><p>监听连接关闭<br><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ws.onclose = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'已关闭'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="websocket-onerror"><a href="#websocket-onerror" class="headerlink" title="websocket.onerror"></a>websocket.onerror</h3><p>监听连接发生错误</p><figure class="highlight moonscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ws.onerror = <span class="function"><span class="params">(<span class="built_in">error</span>: any)</span> =&gt;</span> &#123;</span><br><span class="line">    console.log(<span class="built_in">error</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="websocket-onmessage"><a href="#websocket-onmessage" class="headerlink" title="websocket.onmessage"></a>websocket.onmessage</h3><p>监听服务器端发来的消息</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ws.onmessage = <span class="function"><span class="params">(e)</span> =&gt;</span> &#123;</span><br><span class="line">    let res = e.data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="websocket-sned"><a href="#websocket-sned" class="headerlink" title="websocket.sned"></a>websocket.sned</h3><p>向服务器端发送消息</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ws.<span class="built_in">send</span>(<span class="string">'hello world'</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;websocket是啥我就简单的说一下，这个大家知道的应该挺多的。那么首先它是一个协议，类似于我们的HTTP协议，但是不同的是HTTP协议是客户端向服务器端请求，然后服务器端响应并且只能响应一次，但是无法做到服务器端主动向浏览器端推送数据。那么websocket主要就是解决服务器端无法向客户端主动推送数据的。当我们需要保持一种长链接时，我们就需要用到websocket&lt;br&gt;使用场景如下：浏览器发起请求，这个请求会经历大量的计算，并且返回给浏览器当前计算到了哪一步，这个时候浏览器就可以展示一个弹窗告诉用户当前已经到了哪一步，适当的更可以展示一个进度条，避免用户因为请求时间太长看久了loading也会腻不是。&lt;br&gt;它的主要特点就是，服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话&lt;br&gt;特点包括：&lt;br&gt;（1）建立在 TCP 协议之上，服务器端的实现比较容易。&lt;br&gt;（2）与 HTTP 协议有着良好的兼容性。默认端口也是80和443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。&lt;br&gt;（3）数据格式比较轻量，性能开销小，通信高效。&lt;br&gt;（4）可以发送文本，也可以发送二进制数据。&lt;br&gt;（5）没有同源限制，客户端可以与任意服务器通信。&lt;br&gt;（6）协议标识符是ws（如果加密，则为wss），服务器网址就是 URL。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="node.js" scheme="http://shenweini.cn/tags/node-js/"/>
    
      <category term="express" scheme="http://shenweini.cn/tags/express/"/>
    
  </entry>
  
  <entry>
    <title>Axios二次封装</title>
    <link href="http://shenweini.cn/2019/08/19/Axios%E4%BA%8C%E6%AC%A1%E5%B0%81%E8%A3%85/"/>
    <id>http://shenweini.cn/2019/08/19/Axios二次封装/</id>
    <published>2019-08-19T12:44:00.172Z</published>
    <updated>2019-08-19T12:44:00.173Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>axios是一个基于Promise的http库，可以用在浏览器和node.js中。同时也是对原生浏览器请求XMLHttpRequest的封装，支持Promise的APi请求，避免了回掉地狱问题，可以对请求进行拦截，在发出请求前对请求参数进行修改，接受服务器响应时，也可以根据返回的code进行统一的处理，且客户端支持防御XSRF。可以开箱即用，但是在实际项目时，需要对axios进行二次封装</p></blockquote><a id="more"></a><h2 id="实例-Or-defaults"><a href="#实例-Or-defaults" class="headerlink" title="实例 Or defaults"></a>实例 Or defaults</h2><p>对 axios 进行二次封装由两种方式，一种是创建一个axios实例，另外一种是直接修改axios的defaults</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import axios from 'axios';</span><br><span class="line">var<span class="built_in"> instance </span>= axios.create(&#123;</span><br><span class="line">  baseURL: 'https://some-domain.com/api/',</span><br><span class="line">  timeout: 1000,</span><br><span class="line">  headers: &#123;'X-Custom-Header': 'foobar'&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">'axios'</span>;</span><br><span class="line">axios.defaults.baseURL = SERVICE;</span><br></pre></td></tr></table></figure><p>当然在使用第一种创建一个实例时，也可以设置这个实例的defaults，就像这样<br><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import axios from 'axios';</span><br><span class="line">var<span class="built_in"> instance </span>= axios.create(&#123;</span><br><span class="line">  baseURL: 'https://some-domain.com/api/',</span><br><span class="line">  timeout: 1000,</span><br><span class="line">  headers: &#123;'X-Custom-Header': 'foobar'&#125;</span><br><span class="line">&#125;);</span><br><span class="line">instance.defaults.baseUR<span class="class">L = SERVICE;</span></span><br></pre></td></tr></table></figure></p><h2 id="设置baseURL"><a href="#设置baseURL" class="headerlink" title="设置baseURL"></a>设置baseURL</h2><p>在前后端分离项目，往往需要定义一个全局变量来声明后台的接口地址，一般我会选择通过 webpack 的 definePlugin 插件来给页面设置全局变量，并且根据不同的环境传递不同的值。比如说后台的接口部署在了 <a href="http://localhost:3000" target="_blank" rel="noopener">http://localhost:3000</a><br>那么首先使用 webpack 定义一个叫 SERVICE 的全局变量</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">new</span> <span class="selector-tag">webpack</span><span class="selector-class">.DefinePlugin</span>(&#123;</span><br><span class="line">    <span class="attribute">SERVICE</span>: <span class="string">"'http://localhost:3000'"</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>然后就可以在页面中使用这个全局变量，当然如果是在ts项目下的话，直接使用SERVICE会抱一个未定义的错，那么只需要在使用SERVICE的文件中申明一下即可，未使用ts 的可以跳过这句声明。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">'axios'</span>;</span><br><span class="line"><span class="comment">// ts 下使用 需要先声明</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">const</span> SERVICE: <span class="built_in">string</span>;</span><br><span class="line">axios.defaults.baseURL = SERVICE;</span><br></pre></td></tr></table></figure><h2 id="设置Content-type"><a href="#设置Content-type" class="headerlink" title="设置Content-type"></a>设置Content-type</h2><p>在 post 请求和 put 请求中，需要在请求头里设置一下content-type 为 application/x-www-form-urlencoded</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">axios.defaults.headers.post[<span class="symbol">'Content</span>-<span class="keyword">Type</span>'] = <span class="symbol">'application</span>/x-www-form-urlencoded';</span><br><span class="line">axios.defaults.headers.put[<span class="symbol">'Content</span>-<span class="keyword">Type</span>'] = <span class="symbol">'application</span>/x-www-form-urlencoded';</span><br></pre></td></tr></table></figure><h2 id="设置withCredentials"><a href="#设置withCredentials" class="headerlink" title="设置withCredentials"></a>设置withCredentials</h2><p>axios发起请求时，默认是不会携带cookie的，这就导致了在前后端分离项目中，做一个登录的页面，登录完之后跳转主页面，但是主页面中请求的接口未检测到用户已登录那么就会跳回登录页面，大概时这样的场景。那么缘由就是因为axios在发起请求时是不会携带cookie的，通过设置withCredentials为true 来解决</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">axios.defaults.<span class="attr">withCredentials</span> = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><h2 id="请求拦截-request处理"><a href="#请求拦截-request处理" class="headerlink" title="请求拦截 request处理"></a>请求拦截 request处理</h2><p>可以通过对请求的拦截，修改参数，对参数进行序列化处理，防止XSRF攻击。序列化使用 <code>qs</code>来实现，<code>qs</code>的优点是可以对深层次的json array 等复杂类型进行序列化。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">axios.interceptors.request.use((config: <span class="built_in">any</span>): <span class="function"><span class="params">any</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 给请求添加请求时间</span></span><br><span class="line">    <span class="keyword">if</span> (config.url.indexOf(<span class="string">'?'</span>) !== <span class="number">-1</span>) &#123;</span><br><span class="line">        config.url += <span class="string">`&amp;t=<span class="subst">$&#123;new Date().getTime()&#125;</span>`</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        config.url += <span class="string">`?t=<span class="subst">$&#123;new Date().getTime()&#125;</span>`</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// `transformRequest` 允许在向服务器发送前，修改请求数据</span></span><br><span class="line">    <span class="comment">// 只能用在 'PUT', 'POST' 和 'PATCH' 这几个请求方法</span></span><br><span class="line">    <span class="comment">// 后面数组中的函数必须返回一个字符串，或 ArrayBuffer，或 Stream</span></span><br><span class="line">    config.transformRequest = [<span class="function">(<span class="params">data: <span class="built_in">any</span>, headers: <span class="built_in">any</span></span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> qs.stringify(data, &#123;</span><br><span class="line">            allowDots: <span class="literal">true</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;];</span><br><span class="line">    <span class="comment">// `paramsSerializer` 是一个负责 `params` 序列化的函数</span></span><br><span class="line">    config.paramsSerializer = <span class="function">(<span class="params">params: <span class="built_in">any</span></span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> qs.stringify(params, &#123;</span><br><span class="line">            arrayFormat: <span class="string">'repeat'</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> config;</span><br><span class="line">&#125;, <span class="function">(<span class="params">error: <span class="built_in">any</span></span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="对response进行处理"><a href="#对response进行处理" class="headerlink" title="对response进行处理"></a>对response进行处理</h2><p>有这么一个场景，当接口返回的code为2时，表明用户未登录，这时需要前端对请求的response返回的code进行判断，那么一个请求一个请求的判断肯定是会很麻烦的，哪个请求忘了加判断就完蛋了，所以axios提供了对响应进行拦截的操作。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">axios.interceptors.response.use((response: <span class="built_in">any</span>): <span class="function"><span class="params">any</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; data &#125; = response;</span><br><span class="line">    <span class="keyword">if</span>(data.code === <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="built_in">window</span>.location.href = <span class="string">`/login?from=<span class="subst">$&#123;window.location.pathname&#125;</span>`</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">&#125;, <span class="function">(<span class="params">error: <span class="built_in">any</span></span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">Promise</span>.reject(error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="axios常规操作"><a href="#axios常规操作" class="headerlink" title="axios常规操作"></a>axios常规操作</h2><h3 id="GET请求"><a href="#GET请求" class="headerlink" title="GET请求"></a>GET请求</h3><p>get请求,对于需要参数的get请求，请一定要将参数放在 params 里，不然你会吃亏的。使用场景如下，获取一个邮件的id，mailId是一个非常长的一串各种字符组成的，恰巧这里面包含了一些 . 或者 \ 或者 : 啥的，具体的我也不知道，最后导致的原因是这个邮箱的mailID穿不到后台，因为这个参数直接放在路由后面是有问题的，所以请直接讲参数放在params里，因为上面已经对params里的参数进行了处理。<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">axios</span><span class="selector-class">.get</span>(<span class="string">'/api/info'</span>,&#123;</span><br><span class="line">    <span class="attribute">params</span>: &#123;</span><br><span class="line">        <span class="attribute">id</span>: <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)<span class="selector-class">.then</span>(res =&gt; &#123;</span><br><span class="line"></span><br><span class="line">&#125;)<span class="selector-class">.catch</span>(err =&gt; &#123;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h3 id="POST请求"><a href="#POST请求" class="headerlink" title="POST请求"></a>POST请求</h3><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">axios</span><span class="selector-class">.post</span>(<span class="string">'/api/info'</span>,&#123;</span><br><span class="line">    <span class="attribute">username</span>: <span class="string">'haha'</span>,</span><br><span class="line">    <span class="attribute">password</span>: <span class="string">'123456'</span></span><br><span class="line">&#125;)<span class="selector-class">.then</span>(res =&gt; &#123;</span><br><span class="line"></span><br><span class="line">&#125;)<span class="selector-class">.catch</span>(err =&gt; &#123;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>delete 请求类似于get请求 put请求类似于post请求</p></blockquote><h3 id="链式调用"><a href="#链式调用" class="headerlink" title="链式调用"></a>链式调用</h3><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">axios</span><span class="selector-class">.get</span>(<span class="string">'/api/info'</span>,&#123;</span><br><span class="line">    <span class="attribute">params</span>: &#123;</span><br><span class="line">        <span class="attribute">id</span>: <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)<span class="selector-class">.then</span>(res =&gt; &#123;</span><br><span class="line">    <span class="selector-tag">return</span> <span class="selector-tag">axios</span><span class="selector-class">.post</span>(<span class="string">'/api/info'</span>,&#123;</span><br><span class="line">        <span class="attribute">username</span>: <span class="string">'haha'</span>,</span><br><span class="line">        <span class="attribute">password</span>: <span class="string">'123456'</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;)<span class="selector-class">.then</span>(res =&gt; &#123;</span><br><span class="line"></span><br><span class="line">&#125;)<span class="selector-class">.catch</span>(err =&gt; &#123;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="axios-all"><a href="#axios-all" class="headerlink" title="axios.all"></a>axios.all</h3><p>与 <code>Promise.all</code> 类似，用于多个请求并罚处理，等待请求全部完成时执行回调，并且回调参数为一个数组，数组里的顺序与请求的顺序是一致的，也就是说他是按顺序将返回值存进去的</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">axios</span><span class="selector-class">.all</span>([</span><br><span class="line">    axios.get(<span class="string">'/api/info'</span>,&#123;</span><br><span class="line">        <span class="attribute">params</span>: &#123;</span><br><span class="line">            <span class="attribute">id</span>: <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;),</span><br><span class="line">    axios.post(<span class="string">'/api/info'</span>,&#123;</span><br><span class="line">        <span class="attribute">username</span>: <span class="string">'haha'</span>,</span><br><span class="line">        <span class="attribute">password</span>: <span class="string">'123456'</span></span><br><span class="line">    &#125;);</span><br><span class="line">])<span class="selector-class">.then</span>(resArray =&gt; &#123;</span><br><span class="line">    <span class="comment">// resArray[0] 为axios.get('/api/info') 的res</span></span><br><span class="line">    <span class="comment">// resArray[1] 为axios.post('/api/info') 的res</span></span><br><span class="line">&#125;)<span class="selector-class">.catch</span>(err =&gt; &#123;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="完整代码-模块化开发"><a href="#完整代码-模块化开发" class="headerlink" title="完整代码-模块化开发"></a>完整代码-模块化开发</h2><p>封装完了之后将axios导出，其他的页面直接引用该axios就行。完整代码如下</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// request.js</span></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">'axios'</span>;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> qs <span class="keyword">from</span> <span class="string">'qs'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">const</span> SERVICE: <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line">axios.defaults.baseURL = SERVICE;</span><br><span class="line">axios.defaults.withCredentials = <span class="literal">true</span>;</span><br><span class="line">axios.defaults.headers.post[<span class="string">'Content-Type'</span>] = <span class="string">'application/x-www-form-urlencoded'</span>;</span><br><span class="line">axios.defaults.headers.put[<span class="string">'Content-Type'</span>] = <span class="string">'application/x-www-form-urlencoded'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// qs 序列化 防止XSRF攻击 可以对深层次的json array进行序列化</span></span><br><span class="line">axios.interceptors.request.use((config: <span class="built_in">any</span>): <span class="function"><span class="params">any</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (config.url.indexOf(<span class="string">'?'</span>) !== <span class="number">-1</span>) &#123;</span><br><span class="line">        config.url += <span class="string">`&amp;t=<span class="subst">$&#123;new Date().getTime()&#125;</span>`</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        config.url += <span class="string">`?t=<span class="subst">$&#123;new Date().getTime()&#125;</span>`</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// `transformRequest` 允许在向服务器发送前，修改请求数据</span></span><br><span class="line">    <span class="comment">// 只能用在 'PUT', 'POST' 和 'PATCH' 这几个请求方法</span></span><br><span class="line">    <span class="comment">// 后面数组中的函数必须返回一个字符串，或 ArrayBuffer，或 Stream</span></span><br><span class="line">    config.transformRequest = [<span class="function">(<span class="params">data: <span class="built_in">any</span>, headers: <span class="built_in">any</span></span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> qs.stringify(data, &#123;</span><br><span class="line">            allowDots: <span class="literal">true</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;];</span><br><span class="line">    <span class="comment">// `paramsSerializer` 是一个负责 `params` 序列化的函数</span></span><br><span class="line">    config.paramsSerializer = <span class="function">(<span class="params">params: <span class="built_in">any</span></span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> qs.stringify(params, &#123;</span><br><span class="line">            arrayFormat: <span class="string">'repeat'</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> config;</span><br><span class="line">&#125;, <span class="function">(<span class="params">error: <span class="built_in">any</span></span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">axios.interceptors.response.use((response: <span class="built_in">any</span>): <span class="function"><span class="params">any</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; data &#125; = response;</span><br><span class="line">    <span class="keyword">if</span>(data.code === <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="built_in">window</span>.location.href = <span class="string">`/login?from=<span class="subst">$&#123;window.location.pathname&#125;</span>`</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">&#125;, <span class="function">(<span class="params">error: <span class="built_in">any</span></span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">Promise</span>.reject(error);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> axios;</span><br></pre></td></tr></table></figure><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// action.js</span></span><br><span class="line"><span class="keyword">import</span> axios from <span class="string">'./request'</span>;</span><br><span class="line">axios.<span class="keyword">get</span>(<span class="string">''</span>)</span><br><span class="line">    .then(res = &gt; &#123;</span><br><span class="line">        <span class="comment">// 业务代码</span></span><br><span class="line">    &#125;)</span><br><span class="line">    .<span class="keyword">catch</span>(err =&gt; &#123;</span><br><span class="line">        <span class="comment">// 业务代码</span></span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;axios是一个基于Promise的http库，可以用在浏览器和node.js中。同时也是对原生浏览器请求XMLHttpRequest的封装，支持Promise的APi请求，避免了回掉地狱问题，可以对请求进行拦截，在发出请求前对请求参数进行修改，接受服务器响应时，也可以根据返回的code进行统一的处理，且客户端支持防御XSRF。可以开箱即用，但是在实际项目时，需要对axios进行二次封装&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="js" scheme="http://shenweini.cn/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式学习</title>
    <link href="http://shenweini.cn/2019/08/14/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AD%A6%E4%B9%A0/"/>
    <id>http://shenweini.cn/2019/08/14/正则表达式学习/</id>
    <published>2019-08-14T02:26:39.186Z</published>
    <updated>2019-08-14T02:26:39.186Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>正则表达式博大精深，作为一名开发人员不能不会正则，效率好使用方便，写起来还干净利落简直就是神器。使用场景也很多，webpack中的loader配置，devServer中的historyFallBack中的路由匹配，表单验证等等使用正则及其方便。</p></blockquote><h2 id="创建一个正则"><a href="#创建一个正则" class="headerlink" title="创建一个正则"></a>创建一个正则</h2><p>创建一个正则有两种方式和我们创建正常的变量一样。</p><ul><li>字面量 <code>var test = /a+/</code> 使用两个<code>/</code>包裹</li><li>创建<code>RegExp</code>对象， <code>var test = new RegExp(&quot;a+&quot;);</code></li></ul><h2 id="手机号匹配"><a href="#手机号匹配" class="headerlink" title="手机号匹配"></a>手机号匹配</h2><ul><li>以 1 开始</li><li>第二个数字为 3 4 5 7 8 中的一个</li><li>接 9 个数字</li></ul><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ^ 表示匹配正则开始 $ 表示匹配正则结束</span></span><br><span class="line"><span class="comment">// () 表示子正则表达式 | 表示或</span></span><br><span class="line"><span class="comment">// \d 表示一个0-9的数字等价于[0-9] &#123;n&#125; 表示前面一个字符出现 n 次</span></span><br><span class="line">var phoneTest = /^<span class="number">1</span>(<span class="number">3</span>|<span class="number">4</span>|<span class="number">5</span>|<span class="number">7</span>|<span class="number">8</span>)\d&#123;<span class="number">9</span>&#125;$/;</span><br></pre></td></tr></table></figure><p>那么 <code>/^1(3|4|5|7|8)\d{9}$/</code> 就是最终的正则验证表达式。</p><h2 id="邮箱验证"><a href="#邮箱验证" class="headerlink" title="邮箱验证"></a>邮箱验证</h2><ul><li>以大写字母、小写字母、数字、下划线、-、. 开始并重复1到n次</li><li>中间以 @ 连接</li><li>后接 大写字母、小写字母、数字、下划线、-、. 重复1 到n 次</li><li>以 . 接2到4位的大小写字母</li></ul><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// - 和 . 都是特殊字符 使用时需要进行转义</span><br><span class="line">var emailTest = /^[a-zA-Z0-9_<span class="tag">\<span class="name">-</span></span><span class="tag">\<span class="name">.</span></span>]+@[a-zA-Z0-9_<span class="tag">\<span class="name">-</span></span><span class="tag">\<span class="name">.</span></span>]+<span class="tag">\<span class="name">.</span><span class="string">[a-zA-Z]</span><span class="string">&#123;2,4&#125;</span></span>/</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;正则表达式博大精深，作为一名开发人员不能不会正则，效率好使用方便，写起来还干净利落简直就是神器。使用场景也很多，webpack中的loader配置，devServer中的historyFallBack中的路由匹配，表单验证等等使用正则及其方便。&lt;/
      
    
    </summary>
    
    
      <category term="正则" scheme="http://shenweini.cn/tags/%E6%AD%A3%E5%88%99/"/>
    
  </entry>
  
  <entry>
    <title>解决行内元素之间的间隙</title>
    <link href="http://shenweini.cn/2019/08/13/%E8%A7%A3%E5%86%B3%E8%A1%8C%E5%86%85%E5%85%83%E7%B4%A0%E4%B9%8B%E9%97%B4%E7%9A%84%E9%97%B4%E9%9A%99/"/>
    <id>http://shenweini.cn/2019/08/13/解决行内元素之间的间隙/</id>
    <published>2019-08-13T06:13:04.149Z</published>
    <updated>2019-08-13T06:13:04.149Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>今天写demo，用行内元素的时候，发现了一个小问题，行内元素之间尽然会有一个小空隙，但是我没有加左右的margin真的是神奇。突然明白为什么每次面试问我行内元素和块级元素的区别时，面试官脸上的失望是从哪里来的。</p></blockquote><p>上代码：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">.main&#123;</span><br><span class="line"><span class="symbol">    margin:</span> <span class="number">100</span>px;</span><br><span class="line">&#125;</span><br><span class="line">span&#123;</span><br><span class="line"><span class="symbol">    background:</span> blue;</span><br><span class="line"><span class="symbol">    color:</span> white;</span><br><span class="line">&#125;    </span><br><span class="line"><span class="params">&lt;div class="main"&gt;</span></span><br><span class="line">    <span class="params">&lt;span&gt;</span>第一个<span class="params">&lt;/span&gt;</span></span><br><span class="line">    <span class="params">&lt;span&gt;</span>第一个<span class="params">&lt;/span&gt;</span></span><br><span class="line">    <span class="params">&lt;span&gt;</span>第一个<span class="params">&lt;/span&gt;</span></span><br><span class="line"><span class="params">&lt;/div&gt;</span></span><br></pre></td></tr></table></figure><p><img src="http://static.zybuluo.com/shenweizheng/64t51of6himpombw4l501jf8/image_1di4oeu1skdd1jhe125are5bhv9.png" alt="image_1di4oeu1skdd1jhe125are5bhv9.png-4.8kB"></p><p>这三个span之间的空格岂不是很玄妙。<br>换种写法</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"main"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>第一个<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>第一个<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>第一个<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="http://static.zybuluo.com/shenweizheng/i6hpzoa17umdwyw88oq8ix9p/image_1di4ojmqnggm13e58a2vatl8sm.png" alt="image_1di4ojmqnggm13e58a2vatl8sm.png-4.8kB"></p><p>间隙消失了，那么可以看出之所以产生间隙是因为行内元素后面换了行所以产生了间隙。<br>那么解决办法也有很多。</p><h2 id="负边距"><a href="#负边距" class="headerlink" title="负边距"></a>负边距</h2><p>行内元素在水平方向上的 margin 是存在的，在垂直方向上不存在，所以加一个负的margin就可以了。</p><h2 id="使用font-size-0"><a href="#使用font-size-0" class="headerlink" title="使用font-size = 0"></a>使用font-size = 0</h2><p>神奇的属性</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">.main&#123;</span><br><span class="line"><span class="symbol">    margin:</span> <span class="number">100</span>px;</span><br><span class="line">    font-size: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">span&#123;</span><br><span class="line"><span class="symbol">    background:</span> blue;</span><br><span class="line"><span class="symbol">    color:</span> white;</span><br><span class="line">    font-size: <span class="number">16</span>px;</span><br><span class="line">&#125;</span><br><span class="line"><span class="params">&lt;div class="main"&gt;</span></span><br><span class="line">    <span class="params">&lt;span&gt;</span>第一个<span class="params">&lt;/span&gt;</span></span><br><span class="line">    <span class="params">&lt;span&gt;</span>第一个<span class="params">&lt;/span&gt;</span></span><br><span class="line">    <span class="params">&lt;span&gt;</span>第一个<span class="params">&lt;/span&gt;</span></span><br><span class="line"><span class="params">&lt;/div&gt;</span></span><br></pre></td></tr></table></figure><p>当然其他还有很多去除间隙的方法，我还是更喜欢 font-size 这一种</p><p><img src="http://static.zybuluo.com/shenweizheng/6o55pyf87hmqn5mro8a6an4f/image_1di4orf6p7pj1du01gs21mn1s1b13.png" alt="image_1di4orf6p7pj1du01gs21mn1s1b13.png-4.4kB"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;今天写demo，用行内元素的时候，发现了一个小问题，行内元素之间尽然会有一个小空隙，但是我没有加左右的margin真的是神奇。突然明白为什么每次面试问我行内元素和块级元素的区别时，面试官脸上的失望是从哪里来的。&lt;/p&gt;
&lt;/blockquote&gt;

      
    
    </summary>
    
    
      <category term="css" scheme="http://shenweini.cn/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>css 实现三角形、梯形、平行四边形、爱心等形状</title>
    <link href="http://shenweini.cn/2019/08/13/css%20%E5%AE%9E%E7%8E%B0%E4%B8%89%E8%A7%92%E5%BD%A2%E3%80%81%E6%A2%AF%E5%BD%A2%E3%80%81%E5%B9%B3%E8%A1%8C%E5%9B%9B%E8%BE%B9%E5%BD%A2%E3%80%81%E7%88%B1%E5%BF%83%E7%AD%89%E5%BD%A2%E7%8A%B6/"/>
    <id>http://shenweini.cn/2019/08/13/css 实现三角形、梯形、平行四边形、爱心等形状/</id>
    <published>2019-08-13T05:35:03.351Z</published>
    <updated>2019-08-13T05:35:03.351Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>css 是一门很高深的学问，是前端页面是否好看的支柱。之前一直小看了css的力量，最近看其他博主的书才明白自己的css是多么的菜，以为会点布局就是css了有点贻笑大方了。这篇博客利用css 实现各种形状的编写。</p><p>完整代码 <a href="https://github.com/shenweizheng110/study/blob/master/demo/cssShape.html" target="_blank" rel="noopener">https://github.com/shenweizheng110/study/blob/master/demo/cssShape.html</a></p></blockquote><p>css 要想实现三角形、梯形灯形状，主要利用 border 的相关特性。那么首先看一下border属性，我们给一个div设置很宽的border。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">width</span>: <span class="number">40px</span>;</span><br><span class="line"><span class="attribute">height</span>: <span class="number">40px</span>;</span><br><span class="line"><span class="attribute">border-top</span>: <span class="number">50px</span> solid red;</span><br><span class="line"><span class="attribute">border-left</span>: <span class="number">50px</span> solid black;</span><br><span class="line"><span class="attribute">border-right</span>: <span class="number">50px</span> solid yellow;</span><br><span class="line"><span class="attribute">border-bottom</span>: <span class="number">50px</span> solid blue;</span><br></pre></td></tr></table></figure><p>效果为：</p><p><img src="http://static.zybuluo.com/shenweizheng/enpxiprs301m0huftiqh3klq/image_1dhe36eagier2e71cekou71g6r9.png" alt="image_1dhe36eagier2e71cekou71g6r9.png-3kB"></p><a id="more"></a><p>为了看起来清楚一点，我用了四种不同的颜色进行区分。那么我们设置 width 和 hight 都为 0 ，也就是content所占据的面积为0 那么在标准盒模型下，整个div所展示的面积就会由我们的border的宽度所占据，毕竟我们这里没有margin 和 padding。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">width</span>: <span class="number">40px</span>;</span><br><span class="line"><span class="attribute">height</span>: <span class="number">40px</span>;</span><br><span class="line"><span class="attribute">border-top</span>: <span class="number">50px</span> solid red;</span><br><span class="line"><span class="attribute">border-left</span>: <span class="number">50px</span> solid black;</span><br><span class="line"><span class="attribute">border-right</span>: <span class="number">50px</span> solid yellow;</span><br><span class="line"><span class="attribute">border-bottom</span>: <span class="number">50px</span> solid blue;</span><br></pre></td></tr></table></figure><p><img src="http://static.zybuluo.com/shenweizheng/58qgfr5l43fnx7j0soxqgkie/image_1dhe3fpe91mi59qlo4j1evr1i6pm.png" alt="image_1dhe3fpe91mi59qlo4j1evr1i6pm.png-2.5kB"></p><p>如果我们只需要下面蓝色的那个三角形，只需要不设置 上边框，然后左右两个边框的颜色为透明的就可以。当然也可以设置除了蓝色的其余边边框的颜色为透明的也可以。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line"><span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line"><span class="attribute">border</span>: <span class="number">50px</span> solid transparent;</span><br><span class="line"><span class="attribute">border-bottom-color</span>: blue;</span><br></pre></td></tr></table></figure><p><img src="http://static.zybuluo.com/shenweizheng/u5p4mfsvekyb8ixaw0vf2go9/image_1dhe3upqv16sfov16l7tcdep113.png" alt="image_1dhe3upqv16sfov16l7tcdep113.png-1.8kB"></p><p>接下来我们看一下改变三角形的变长，大家都知道改变边框的宽度用的是 border-width 属性。我们可以逐渐的加大 border-bottom 试试<br>border-bottom 为 100 px 时：</p><p><img src="http://static.zybuluo.com/shenweizheng/e1dshqq513uz2q5kckdu6rqb/image_1dhe49cdo1ke3157mvr917gp1pua1g.png" alt="image_1dhe49cdo1ke3157mvr917gp1pua1g.png-2.7kB"></p><p>可以看的出来时三角形的高变大了，而不是三角形的底变大了。之前我也在懵逼为什么会是这样的，结果我发现对 border-width 的了解出现了偏差。事实上，border-width 是这样的：</p><p><img src="http://static.zybuluo.com/shenweizheng/3zdfwy9ga8s4vd9eajazndul/image_1dhe5d7ea36mceuqqq1ij4r401t.png" alt="image_1dhe5d7ea36mceuqqq1ij4r401t.png-33.4kB"></p><p>图中的这条白线才是 border-width。<br>那么同样的，蓝色三角形的边长是 border-left-width 加上 border-right-width 的和，高度为 border-bottom-width。</p><h2 id="直角三角形"><a href="#直角三角形" class="headerlink" title="直角三角形"></a>直角三角形</h2><p>上面说了三角形的边和高的构成，那么直角三角形就是将border-left 或者 border-right其中一个置为0；</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line"><span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line"><span class="attribute">border-left</span>: <span class="number">50px</span> solid transparent;</span><br><span class="line"><span class="attribute">border-bottom</span>: <span class="number">50px</span> solid blue;</span><br></pre></td></tr></table></figure><p><img src="http://static.zybuluo.com/shenweizheng/jabxz4dhmdd7p0kwf2vwed6r/image_1dhe5n3ab15sbemfjog1brsp882a.png" alt="image_1dhe5n3ab15sbemfjog1brsp882a.png-0.9kB"></p><h2 id="等边三角形"><a href="#等边三角形" class="headerlink" title="等边三角形"></a>等边三角形</h2><p>等边三角形的定义是三角形的三边长相等，高为边的 $\sqrt 3$, 那么高是由border-bottom-width控制的，而变长是由 border-left-width 与 border-right-width 的和。那么如果我们的 border-left-width 和 border-right-width 都为 50px 的话，高就是 $50\sqrt 3$, 粗略的为 86px</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line"><span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line"><span class="attribute">border-left</span>: <span class="number">50px</span> solid transparent;</span><br><span class="line"><span class="attribute">border-right</span>: <span class="number">50px</span> solid transparent;</span><br><span class="line"><span class="attribute">border-bottom</span>: <span class="number">86px</span> solid blue;</span><br></pre></td></tr></table></figure><p><img src="http://static.zybuluo.com/shenweizheng/b0z16sii7eg33047adswnmtg/image_1dhe67t11uj4kt01k3bbb9sjl2n.png" alt="image_1dhe67t11uj4kt01k3bbb9sjl2n.png-2.8kB"></p><h2 id="梯形"><a href="#梯形" class="headerlink" title="梯形"></a>梯形</h2><h3 id="直角梯形"><a href="#直角梯形" class="headerlink" title="直角梯形"></a>直角梯形</h3><p>只需要将上边框取消，左右选取一个将其颜色置为透明<br><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line"><span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line"><span class="attribute">border-left</span>: <span class="number">50px</span> solid transparent;</span><br><span class="line"><span class="attribute">border-right</span>: <span class="number">50px</span> solid yellow;</span><br><span class="line"><span class="attribute">border-bottom</span>: <span class="number">50px</span> solid blue;</span><br></pre></td></tr></table></figure></p><p><img src="http://static.zybuluo.com/shenweizheng/70cxwgul0fxu8lc2u68qvzeo/image_1di4cei5b12bm1e28ipfmn41g8k9.png" alt="image_1di4cei5b12bm1e28ipfmn41g8k9.png-2.1kB"></p><h3 id="普通梯形"><a href="#普通梯形" class="headerlink" title="普通梯形"></a>普通梯形</h3><p>普通梯形的上边框需要使用width属性指定，要给他一定的宽度<br><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">width</span>: <span class="number">25px</span>;</span><br><span class="line"><span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line"><span class="attribute">border-left</span>: <span class="number">50px</span> solid transparent;</span><br><span class="line"><span class="attribute">border-right</span>: <span class="number">50px</span> solid transparent;</span><br><span class="line"><span class="attribute">border-bottom</span>: <span class="number">50px</span> solid blue;</span><br></pre></td></tr></table></figure></p><p><img src="http://static.zybuluo.com/shenweizheng/1c7o51i00fibxmfhp75km2wx/image_1di4chtfv1ls718n7p4d1rr68vam.png" alt="image_1di4chtfv1ls718n7p4d1rr68vam.png-1.7kB"></p><h2 id="菱形"><a href="#菱形" class="headerlink" title="菱形"></a>菱形</h2><p>这个就简单了，只要将正方形旋转 45 度。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line"><span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line"><span class="attribute">border-top</span>: <span class="number">50px</span> solid red;</span><br><span class="line"><span class="attribute">border-left</span>: <span class="number">50px</span> solid black;</span><br><span class="line"><span class="attribute">border-right</span>: <span class="number">50px</span> solid yellow;</span><br><span class="line"><span class="attribute">border-bottom</span>: <span class="number">50px</span> solid blue;</span><br><span class="line"><span class="attribute">transform</span>: rotate(<span class="number">45deg</span>);</span><br></pre></td></tr></table></figure><p><img src="http://static.zybuluo.com/shenweizheng/j4x5db0fuvszpubr6wlzxob5/image_1di4dvmqhsnt1hmfr8216cd1r8013.png" alt="image_1di4dvmqhsnt1hmfr8216cd1r8013.png-3.8kB"></p><h2 id="平行四边形"><a href="#平行四边形" class="headerlink" title="平行四边形"></a>平行四边形</h2><p>借助 transform 中的 skew 属性来实现，由于直接在div中使用，会导致内部的字体也会相应的倾斜，一种解决方案是对里面的文本加一个反向的倾斜，另一种解决方案是利用为元素进行倾斜，这样内部的文本就不会继承倾斜了。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.rhomboid</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.rhomboid</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">''</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">z-index</span>: -<span class="number">1</span>;</span><br><span class="line">    <span class="attribute">background</span>: blue;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">skew</span>(45deg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://static.zybuluo.com/shenweizheng/pdzf4qkdzy5ykog9tb7brsj7/image_1di4fae5a1t7316a01oqc1opu7cq1g.png" alt="image_1di4fae5a1t7316a01oqc1opu7cq1g.png-3.3kB"></p><h2 id="爱心"><a href="#爱心" class="headerlink" title="爱心"></a>爱心</h2><p>爱心可以通过的其他元素进行遮掩拼接实现。首先画一个正方形</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.love</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">background</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://static.zybuluo.com/shenweizheng/ist4ccrw14wllj02xdvb6c3r/image_1di4mgturg9ud8j4gt1h8f4er1t.png" alt="image_1di4mgturg9ud8j4gt1h8f4er1t.png-1.1kB"></p><p>通过为元素画两个圆覆盖在正方形上</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.love</span><span class="selector-pseudo">::before</span>&#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">''</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">left</span>: -<span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">background</span>: yellow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.love</span><span class="selector-pseudo">::after</span>&#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">''</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: -<span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">background</span>: yellow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://static.zybuluo.com/shenweizheng/kwj2g5my4vw7ii5iw7js5x2a/image_1di4mkpv0lp8se91sink8t2p22a.png" alt="image_1di4mkpv0lp8se91sink8t2p22a.png-4.1kB"></p><p><img src="http://static.zybuluo.com/shenweizheng/pb3wtmyl4dqrimn16f5upnhc/image_1di4mlfpfkip1k76v917cmfl2n.png" alt="image_1di4mlfpfkip1k76v917cmfl2n.png-5.4kB"></p><p>旋转 45 度 颜色改成一致的</p><p><img src="http://static.zybuluo.com/shenweizheng/jv5frcyxvv5ku00twgxd158h/image_1di4mmm0r1l5l1prvr8m8p43rr34.png" alt="image_1di4mmm0r1l5l1prvr8m8p43rr34.png-5.9kB"></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;css 是一门很高深的学问，是前端页面是否好看的支柱。之前一直小看了css的力量，最近看其他博主的书才明白自己的css是多么的菜，以为会点布局就是css了有点贻笑大方了。这篇博客利用css 实现各种形状的编写。&lt;/p&gt;
&lt;p&gt;完整代码 &lt;a href=&quot;https://github.com/shenweizheng110/study/blob/master/demo/cssShape.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/shenweizheng110/study/blob/master/demo/cssShape.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;css 要想实现三角形、梯形灯形状，主要利用 border 的相关特性。那么首先看一下border属性，我们给一个div设置很宽的border。&lt;/p&gt;
&lt;figure class=&quot;highlight scss&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attribute&quot;&gt;width&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;40px&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attribute&quot;&gt;height&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;40px&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attribute&quot;&gt;border-top&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;50px&lt;/span&gt; solid red;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attribute&quot;&gt;border-left&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;50px&lt;/span&gt; solid black;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attribute&quot;&gt;border-right&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;50px&lt;/span&gt; solid yellow;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attribute&quot;&gt;border-bottom&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;50px&lt;/span&gt; solid blue;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;效果为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://static.zybuluo.com/shenweizheng/enpxiprs301m0huftiqh3klq/image_1dhe36eagier2e71cekou71g6r9.png&quot; alt=&quot;image_1dhe36eagier2e71cekou71g6r9.png-3kB&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="css" scheme="http://shenweini.cn/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>BFC的触发条件、布局规则、使用场景</title>
    <link href="http://shenweini.cn/2019/07/31/BFC%E7%9A%84%E8%A7%A6%E5%8F%91%E6%9D%A1%E4%BB%B6%E3%80%81%E5%B8%83%E5%B1%80%E8%A7%84%E5%88%99%E3%80%81%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/"/>
    <id>http://shenweini.cn/2019/07/31/BFC的触发条件、布局规则、使用场景/</id>
    <published>2019-07-31T01:36:51.240Z</published>
    <updated>2019-08-03T14:21:28.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>BFC指的是块级格式化上下文，简单的来说，BFC就是创建一个盒子，盒子内部的元素布局不影响盒子外部的元素。html根元素就是一个BFC</p></blockquote><h2 id="BFC-的触发条件"><a href="#BFC-的触发条件" class="headerlink" title="BFC 的触发条件"></a>BFC 的触发条件</h2><ul><li>html根元素 <code>&lt;html&gt;</code></li><li>float 不为 none</li><li>绝对定位元素 也就是 position 为 absolute 和 fixed</li><li>行内快元素 display 为 inline-block</li><li>display 为 table-cell inline-block flex inline-flex grid inline-grid table-caption(表格标题)</li><li>overflow 不为 visible</li></ul><a id="more"></a><h2 id="BFC-的规则"><a href="#BFC-的规则" class="headerlink" title="BFC 的规则"></a>BFC 的规则</h2><ol><li>内部的Box会在垂直方向，一个接一个地放置。Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠。</li><li>每个元素的margin box的左边， 与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。</li><li>BFC的区域不会与float box重叠。</li><li>FC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。</li><li>计算BFC的高度时，浮动元素也参与计算。</li></ol><h2 id="BFC解决的问题"><a href="#BFC解决的问题" class="headerlink" title="BFC解决的问题"></a>BFC解决的问题</h2><h3 id="垂直方向-margin-重叠"><a href="#垂直方向-margin-重叠" class="headerlink" title="垂直方向 margin 重叠"></a>垂直方向 margin 重叠</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.out&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">background</span>: black;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="selector-tag">div</span> class=<span class="string">'out'</span>&gt;&lt;/div&gt;</span><br><span class="line">&lt;<span class="selector-tag">div</span> class=<span class="string">'out'</span>&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>理论上讲，这两个 div 上下间隙有 40px 因为两个div 的margin都是 20px 加起来就是40px，但是看一下效果图。</p><p><img src="http://static.zybuluo.com/shenweizheng/ht4jg65uch1aetpqj3qss3bx/image_1dh2ouhd51bsjc015lseft7nnm.png" alt="image_1dh2ouhd51bsjc015lseft7nnm.png-2.1kB"></p><p>这个实际上，只有 20px 的间隙，原因是一个容器内部的所有box会从上往下进行堆叠，并且垂直相邻的距离(即margin)是由各自的margin决定的，在垂直方向上会发生 margin 重叠。解决方案是将两个 div 分属于不同的BFC。</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">div</span> <span class="built_in">class</span>='out'&gt;&lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">&lt;<span class="keyword">div</span> style=<span class="string">"overflow: hidden"</span>&gt;</span><br><span class="line">    &lt;<span class="keyword">div</span> <span class="built_in">class</span>='out'&gt;&lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">&lt;/<span class="keyword">div</span>&gt;</span><br></pre></td></tr></table></figure><p>在其中一个out外面包裹一层div，设置 overflow: hidden 使其变成一个BFC，这样两个out就不会发生margin重叠了。</p><p><img src="http://static.zybuluo.com/shenweizheng/q6ic9t4n3v75zghzybkz2jv0/image_1dh2p3qqkk1g1c2dasi6tb1cbn13.png" alt="image_1dh2p3qqkk1g1c2dasi6tb1cbn13.png-2.8kB"></p><p>在看另一外一种margin重叠</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">.out&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">background</span>: black;</span><br><span class="line">    <span class="attribute">margin-top</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.inner&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">background</span>: red;</span><br><span class="line">    <span class="attribute">margin-top</span>: <span class="number">30px</span>;</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="selector-tag">div</span> class=<span class="string">'out'</span>&gt;</span><br><span class="line">    &lt;<span class="selector-tag">div</span> class=<span class="string">"inner"</span>&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p><img src="http://static.zybuluo.com/shenweizheng/1t50d2gchk4f9pm9o8l1yv1p/image_1dh2p80er1035cd61n5611r9q1v1g.png" alt="image_1dh2p80er1035cd61n5611r9q1v1g.png-6.1kB"></p><p>可以看出，整个元素距离顶部的距离是由子元素 inner 的margin-top决定的，因为 inner 的marginTop是大于外部的out的，并且他们都属于 html 跟元素下的BFC，所以margin在垂直方向上会发生重叠，取最大值。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.out</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">background</span>: black;</span><br><span class="line">    <span class="attribute">margin-top</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">overflow</span>: hidden;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>给 out 设置 overflow: hidden 让他变成一个 BFC</p><p><img src="http://static.zybuluo.com/shenweizheng/2ss8m8qjet3nrlpkik471lfx/image_1dh2ped1p1r5s10ehbnf1a388071t.png" alt="image_1dh2ped1p1r5s10ehbnf1a388071t.png-1.5kB"></p><h3 id="文本不环绕浮动元素"><a href="#文本不环绕浮动元素" class="headerlink" title="文本不环绕浮动元素"></a>文本不环绕浮动元素</h3><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">.<span class="built_in">float</span>&#123;</span><br><span class="line">    <span class="built_in">float</span>: left;</span><br><span class="line">    <span class="built_in">width</span>: <span class="number">100</span>px;</span><br><span class="line">    <span class="built_in">height</span>: <span class="number">100</span>px;</span><br><span class="line">    <span class="built_in">background</span>: <span class="built_in">red</span>;</span><br><span class="line">    <span class="built_in">color</span>: white;</span><br><span class="line">&#125;</span><br><span class="line">p&#123;</span><br><span class="line">    <span class="built_in">width</span>: <span class="number">200</span>px;</span><br><span class="line">    <span class="built_in">height</span>: <span class="number">200</span>px;</span><br><span class="line">    <span class="built_in">background</span>: <span class="built_in">blue</span>;</span><br><span class="line">    <span class="built_in">color</span>: white;</span><br><span class="line">&#125;</span><br><span class="line">&lt;div class=<span class="string">"float"</span>&gt;I am a floated <span class="built_in">box</span>!&lt;/div&gt;</span><br><span class="line">&lt;p&gt;I am content inside the container.&lt;/p&gt;</span><br></pre></td></tr></table></figure><p><img src="http://static.zybuluo.com/shenweizheng/6p2jtzzqff03j50aornozxos/image_1dh2pth9oj4p9412k11kro1tn02a.png" alt="image_1dh2pth9oj4p9412k11kro1tn02a.png-13.2kB"></p><p>现在我们的蓝色区域的文本是围绕着浮动元素进行排列的，如果要实现两栏布局的话有一种办法是让蓝色区域的marginLeft设置为红色区域的宽 + 你想要的边距</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">background</span>: blue;</span><br><span class="line">    <span class="attribute">color</span>: white;</span><br><span class="line">    <span class="attribute">overflow</span>: hidden;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将 p 变成BFC</p><h3 id="解决包裹浮动元素没有高度的问题"><a href="#解决包裹浮动元素没有高度的问题" class="headerlink" title="解决包裹浮动元素没有高度的问题"></a>解决包裹浮动元素没有高度的问题</h3><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.inner&#123;</span><br><span class="line"><span class="symbol">    float:</span> left;</span><br><span class="line"><span class="symbol">    width:</span> <span class="number">100</span>px;</span><br><span class="line"><span class="symbol">    height:</span> <span class="number">100</span>px;</span><br><span class="line"><span class="symbol">    background:</span> red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="params">&lt;div&gt;</span></span><br><span class="line">    <span class="params">&lt;div class='inner'&gt;</span><span class="params">&lt;/div&gt;</span></span><br><span class="line"><span class="params">&lt;/div&gt;</span></span><br></pre></td></tr></table></figure><p><img src="http://static.zybuluo.com/shenweizheng/9fug72v07c84wmoc0xgmbfz0/image_1dh2qc0vdmsu698slaa112dn3k.png" alt="image_1dh2qc0vdmsu698slaa112dn3k.png-4.7kB"></p><p>一般来说，div 不设置宽高的话，他的宽高会由子元素的宽高给撑起来，但是这边 包裹了一个浮动元素，发现父级元素的高度为 0</p><p><img src="http://static.zybuluo.com/shenweizheng/7pxxvy6tkz4ov0ku7jtqd55p/image_1dh2qhk4l1guf1koqjbokt41ne74e.png" alt="image_1dh2qhk4l1guf1koqjbokt41ne74e.png-11.8kB"></p><p><img src="http://static.zybuluo.com/shenweizheng/jpwg0iwwcwuqncwygfiycsuz/image_1dh2qgtdi1nvsf2b19uo11ej19q541.png" alt="image_1dh2qgtdi1nvsf2b19uo11ej19q541.png-5kB"></p><p>同样的设置为BFC</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;BFC指的是块级格式化上下文，简单的来说，BFC就是创建一个盒子，盒子内部的元素布局不影响盒子外部的元素。html根元素就是一个BFC&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;BFC-的触发条件&quot;&gt;&lt;a href=&quot;#BFC-的触发条件&quot; class=&quot;headerlink&quot; title=&quot;BFC 的触发条件&quot;&gt;&lt;/a&gt;BFC 的触发条件&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;html根元素 &lt;code&gt;&amp;lt;html&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;float 不为 none&lt;/li&gt;
&lt;li&gt;绝对定位元素 也就是 position 为 absolute 和 fixed&lt;/li&gt;
&lt;li&gt;行内快元素 display 为 inline-block&lt;/li&gt;
&lt;li&gt;display 为 table-cell inline-block flex inline-flex grid inline-grid table-caption(表格标题)&lt;/li&gt;
&lt;li&gt;overflow 不为 visible&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="css" scheme="http://shenweini.cn/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>原型链 与 继承的理解</title>
    <link href="http://shenweini.cn/2019/07/26/%E5%8E%9F%E5%9E%8B%E9%93%BE%20%E4%B8%8E%20%E7%BB%A7%E6%89%BF%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <id>http://shenweini.cn/2019/07/26/原型链 与 继承的理解/</id>
    <published>2019-07-26T12:47:05.904Z</published>
    <updated>2019-08-03T14:22:16.982Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原型链是前端面试几乎必问的东西，原型链实现了js中的继承。在看完阮一峰老师的博客后，理解了原型链的作用。</p></blockquote><h2 id="new-的由来"><a href="#new-的由来" class="headerlink" title="new 的由来"></a>new 的由来</h2><p>关于new的由来大家可以借阅阮一峰老师的博客<a href="http://www.ruanyifeng.com/blog/2011/06/designing_ideas_of_inheritance_mechanism_in_javascript.html" target="_blank" rel="noopener">Javascript继承机制的设计思想</a></p><a id="more"></a><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>在es5之前还没有类的时候，js都是 new 一个构造函数来生成一个构造函数的对象，这边的构造函数相当于java中的class，在es6之后，为了方便js也诞生了 class 关键字。<br>构造函数和普通的function最直观的区别是 构造函数的函数名是大写的，它张这个样子<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dog</span><span class="params">(name)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.type = <span class="string">'dog'</span>;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这边是定义了一个 Dog 的构造函数，那么我们可以使用 new 来创建一只狗</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> dog = <span class="keyword">new</span> Dog(<span class="string">'哈士奇'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(dog.name); <span class="comment">// 哈士奇</span></span><br></pre></td></tr></table></figure><p>至于构造函数中的this指向问题，这边就不说了，在我的上一篇博客详细的介绍了<a href="https://blog.csdn.net/qq_38606793/article/details/97309053" target="_blank" rel="noopener">js中的this指向问题</a>。</p><p>下面我们了解一下 new 一个对象的中间发生了什么</p><h2 id="new-的过程"><a href="#new-的过程" class="headerlink" title="new 的过程"></a>new 的过程</h2><p>节选自js高级程序设计（第三版），创建一个实例，一共分为四个步骤</p><p>（1）创建一个新对象；</p><p>（2）将构造函数的作用域赋给新对象（因此this就指向了这个新对象）；</p><p>（3）执行构造函数中的代码（为这个新对象添加属性）；</p><p>（4）返回新对象。</p><h2 id="new-的缺点"><a href="#new-的缺点" class="headerlink" title="new 的缺点"></a>new 的缺点</h2><p>前面提到了 new 运算符可以实例化一个对象，但是 new 也有一个缺点，就是new出来的两个对象之间没有任何的联系，做不到数据共享，这个缺点有违 new 创建的初衷。下面看一段示例<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dog</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.type = <span class="string">'dog'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> dogA = <span class="keyword">new</span> Dog(<span class="string">'哈士奇'</span>);</span><br><span class="line"><span class="keyword">let</span> dogB = <span class="keyword">new</span> Dog(<span class="string">'大金毛'</span>);</span><br><span class="line"></span><br><span class="line">dogA.type = <span class="string">'大型犬'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(dogB.type); <span class="comment">// 'dog'</span></span><br></pre></td></tr></table></figure></p><p>通过 Dog 构造函数实例化出了两个对象，修改其中一个对象的属性，并不会改变另一个对象的属性，这并不是 new 设计的初衷， dogA 和 dogB 两个对象之间无法做到数据共享，就好像没有任何关系一样。</p><h2 id="prototype-的引入"><a href="#prototype-的引入" class="headerlink" title="prototype 的引入"></a>prototype 的引入</h2><p>为了解决上面所述的问题，new 的创始人引入了 prototype 属性，</p><blockquote><p>这个属性包含一个对象（以下简称”prototype对象”），所有实例对象需要共享的属性和方法，都放在这个对象里面；那些不需要共享的属性和方法，就放在构造函数里面。</p><p>实例对象一旦创建，将自动引用prototype对象的属性和方法。也就是说，实例对象的属性和方法，分成两种，一种是本地的，另一种是引用的。</p></blockquote><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function Dog(name)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">&#125;</span><br><span class="line">Dog.prototype.<span class="keyword">type</span> = <span class="string">'dog'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> dogA = <span class="literal">new</span> Dog(<span class="string">'哈士奇'</span>);</span><br><span class="line"><span class="keyword">let</span> dogB = <span class="literal">new</span> Dog(<span class="string">'大金毛'</span>);</span><br><span class="line"></span><br><span class="line">console.<span class="keyword">log</span>(dogA.<span class="keyword">type</span>); <span class="comment">// dog</span></span><br><span class="line">Dog.prototype.<span class="keyword">type</span> = <span class="string">'大型犬'</span>;</span><br><span class="line">console.<span class="keyword">log</span>(dogA.<span class="keyword">type</span>, dogB.<span class="keyword">type</span>); <span class="comment">//大型犬 大型犬</span></span><br></pre></td></tr></table></figure><p>type属性是 Dog实例化出的对象所共享的属性，只要修改了 prototype中的type属性，每一个对象的 type 值都会被改变。</p><h2 id="构造函数实现继承"><a href="#构造函数实现继承" class="headerlink" title="构造函数实现继承"></a>构造函数实现继承</h2><p>构造函数实现继承有很多中实现方式，首先看第一种</p><h3 id="call-apply-绑定"><a href="#call-apply-绑定" class="headerlink" title="call apply 绑定"></a>call apply 绑定</h3><p>这种是直接将父构造函数绑定在子构造函数中<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.type = <span class="string">'dog'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dog</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    Animal.call(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> dogA = <span class="keyword">new</span> Dog(<span class="string">'哈士奇'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(dogA.type); <span class="comment">// dog</span></span><br></pre></td></tr></table></figure></p><h3 id="使用prototype进行继承"><a href="#使用prototype进行继承" class="headerlink" title="使用prototype进行继承"></a>使用prototype进行继承</h3><p>由于 prototype 属性可以存在对象共享的属性，那么我们可以按照封装的思想，将公共的部分抽离出来，变成一个公共的构造函数，也就是这些对象的父类也是基类，我觉得叫基类更加的合适，因为它存储着每一个对象的公共部分。实现方式只需要将子构造函数的 prototype 属性赋值为父构造函数<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.type = <span class="string">'dog'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dog</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Dog.prototype = <span class="keyword">new</span> Animal();</span><br><span class="line">Dog.prototype.constructor = Dog;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> dogA = <span class="keyword">new</span> Dog(<span class="string">'哈士奇'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(dogA.type); <span class="comment">// dog</span></span><br></pre></td></tr></table></figure></p><ul><li>第 9 行：将Dog 的原型属性赋值为Animal的实例</li><li>第 10 行：修改 prototype 属性的costructor对象为Dog，这是因为每一个 prototype 对象都包含了它的构造函数对象，在上一行将 Dog 的原型直接赋值为 Animal的构造函数，所以此时Dog的原型对象中的 constructor其实是指向Animal的构造函数的，所以我们这边要修改回来，不然引起原型链的絮乱。</li></ul><h3 id="直接继承prototype"><a href="#直接继承prototype" class="headerlink" title="直接继承prototype"></a>直接继承prototype</h3><blockquote><p>第三种方法是对第二种方法的改进。由于Animal对象中，不变的属性都可以直接写入Animal.prototype。所以，我们也可以让Cat()跳过 Animal()，直接继承Animal.prototype。</p></blockquote><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span><span class="params">()</span><span class="comment">&#123; &#125;</span>;</span></span><br><span class="line">Animal.prototype.<span class="keyword">type</span> = <span class="string">'dog'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dog</span><span class="params">(<span class="keyword">name</span>)</span><span class="comment">&#123;</span></span></span><br><span class="line"><span class="function"><span class="comment">    this.name = name;</span></span></span><br><span class="line"><span class="function"><span class="comment">&#125;</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">Dog</span>.<span class="title">prototype</span> = <span class="title">Animal</span>.<span class="title">prototype</span>;</span></span><br><span class="line">Dog.prototype.<span class="keyword">constructor</span> = Dog;</span><br><span class="line"></span><br><span class="line">let dogA = new Dog(<span class="string">'哈士奇'</span>);</span><br><span class="line">console.log(dogA.<span class="keyword">type</span>); <span class="comment">// dog</span></span><br></pre></td></tr></table></figure><p>这种方法相比于第二种方法，优点是效率高，因为他跳过了执行创建一个 Animal 实例，省内存。但是也有缺点，缺点是直接将 Animal 的prototype 属性赋值给了 Dog 的 prototype 这是一个浅拷贝，因为prototype 是一个 object，所以对于任何Dog 的 prototype的修改都会响应在 Animal.prototype；</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log<span class="params">(Animal.prototype.<span class="attr">constructor</span> === Dog)</span>; <span class="string">//</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>我们在第 9 行修改了Dog.prototype中的 constructor属性，这边打印发现 Animal 的 prototype中的 constructor 也指向了 Dog</p><h3 id="利用空对象作为中介"><a href="#利用空对象作为中介" class="headerlink" title="利用空对象作为中介"></a>利用空对象作为中介</h3><p>为了解决上面一种方式引起的问题，可以采用空对象作为媒介。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params"></span>)</span>&#123; &#125;;</span><br><span class="line">Animal.prototype.type = <span class="string">'dog'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dog</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Temp = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; &#125;;</span><br><span class="line">Temp.prototype = Animal.prototype;</span><br><span class="line">Dog.prototype = <span class="keyword">new</span> Temp();</span><br><span class="line">Dog.prototype.constructor = Dog;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> dogA = <span class="keyword">new</span> Dog(<span class="string">'哈士奇'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(dogA.type); <span class="comment">// dog</span></span><br><span class="line"><span class="built_in">console</span>.log(Animal.prototype.constructor === Dog); <span class="comment">// false</span></span><br></pre></td></tr></table></figure></p><p>利用空对象作为媒介，空对象几乎不占内存，也不会影响 Animal 的 prototype</p><h3 id="拷贝继承"><a href="#拷贝继承" class="headerlink" title="拷贝继承"></a>拷贝继承</h3><p>顾名思义，就是将父对象的所有属性和方法，拷贝进子对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params"></span>)</span>&#123; &#125;;</span><br><span class="line">Animal.prototype.type = <span class="string">'dog'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dog</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">extendOfCopy</span>(<span class="params">Child, Parent</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> c = Child.prototype;</span><br><span class="line">    <span class="keyword">let</span> p = Parent.prototype;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">in</span> p)&#123;</span><br><span class="line">        c[i] = p[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">extendOfCopy(Dog, Animal);</span><br><span class="line"><span class="keyword">let</span> dogA = <span class="keyword">new</span> Dog(<span class="string">'哈士奇'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(dogA.type); <span class="comment">// dog</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;原型链是前端面试几乎必问的东西，原型链实现了js中的继承。在看完阮一峰老师的博客后，理解了原型链的作用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;new-的由来&quot;&gt;&lt;a href=&quot;#new-的由来&quot; class=&quot;headerlink&quot; title=&quot;new 的由来&quot;&gt;&lt;/a&gt;new 的由来&lt;/h2&gt;&lt;p&gt;关于new的由来大家可以借阅阮一峰老师的博客&lt;a href=&quot;http://www.ruanyifeng.com/blog/2011/06/designing_ideas_of_inheritance_mechanism_in_javascript.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Javascript继承机制的设计思想&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="js" scheme="http://shenweini.cn/tags/js/"/>
    
  </entry>
  
</feed>
