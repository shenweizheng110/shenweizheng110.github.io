<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>唯你の博客</title>
  
  <subtitle>生活需要美好</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://shenweini.cn/"/>
  <updated>2019-09-17T08:49:35.050Z</updated>
  <id>http://shenweini.cn/</id>
  
  <author>
    <name>ShenWeiZheng</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>React源码解析----createElement + Component + PureComponent</title>
    <link href="http://shenweini.cn/2019/09/17/React%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90----createElement%20+%20Component%20+%20PureComponent/"/>
    <id>http://shenweini.cn/2019/09/17/React源码解析----createElement + Component + PureComponent/</id>
    <published>2019-09-17T08:49:35.050Z</published>
    <updated>2019-09-17T08:49:35.050Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>上一篇介绍了React的Api，今天介绍createElement和React的Component相关操作。看了很多其他人的博客，对于React16的fiber架构还是无法了解，尽管我知道他很牛逼。发现了解React的源码还是需要从渲染开始进行了解，明白从一个组件到挂载再到响应式的所有操作。</p></blockquote><p>首先先写一个简单的React组件<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="type">React</span> from <span class="symbol">'reac</span>t';</span><br><span class="line"><span class="keyword">import</span> <span class="type">ReactDom</span> from <span class="symbol">'react</span>-dom';</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    constructor(props) &#123;</span><br><span class="line">        <span class="keyword">super</span>(props);</span><br><span class="line">        <span class="keyword">this</span>.state = &#123;</span><br><span class="line">            name: <span class="symbol">'Hello</span> <span class="type">World</span>'</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    componentDidMount() &#123;</span><br><span class="line">        console.log(<span class="symbol">'component</span> did mount');</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &#123; <span class="keyword">this</span>.state.name &#125;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">ReactDom</span>.render(</span><br><span class="line">    &lt;<span class="type">App</span> /&gt;,</span><br><span class="line">    document.getElementById(<span class="symbol">'roo</span>t')</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p><p>使用<code>babel</code>编译这个<code>jsx</code>文件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> _react = _interopRequireDefault(<span class="built_in">require</span>(<span class="string">"react"</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> _reactDom = _interopRequireDefault(<span class="built_in">require</span>(<span class="string">"react-dom"</span>));</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_interopRequireDefault</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> obj &amp;&amp; obj.__esModule ? obj : &#123;</span><br><span class="line">        <span class="string">"default"</span>: obj</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_typeof</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">Symbol</span> === <span class="string">"function"</span> &amp;&amp; <span class="keyword">typeof</span> <span class="built_in">Symbol</span>.iterator === <span class="string">"symbol"</span>) &#123;</span><br><span class="line">        _typeof = <span class="function"><span class="keyword">function</span> <span class="title">_typeof</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">typeof</span> obj;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        _typeof = <span class="function"><span class="keyword">function</span> <span class="title">_typeof</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> obj &amp;&amp; <span class="keyword">typeof</span> <span class="built_in">Symbol</span> === <span class="string">"function"</span> &amp;&amp; obj.constructor === <span class="built_in">Symbol</span> &amp;&amp; obj !== <span class="built_in">Symbol</span>.prototype ? <span class="string">"symbol"</span> : <span class="keyword">typeof</span> obj;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _typeof(obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_classCallCheck</span>(<span class="params">instance, Constructor</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!(instance <span class="keyword">instanceof</span> Constructor)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">"Cannot call a class as a function"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_defineProperties</span>(<span class="params">target, props</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; props.length; i++) &#123;</span><br><span class="line">        <span class="keyword">var</span> descriptor = props[i];</span><br><span class="line">        descriptor.enumerable = descriptor.enumerable || <span class="literal">false</span>;</span><br><span class="line">        descriptor.configurable = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"value"</span> <span class="keyword">in</span> descriptor) descriptor.writable = <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">Object</span>.defineProperty(target, descriptor.key, descriptor);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_createClass</span>(<span class="params">Constructor, protoProps, staticProps</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (protoProps) _defineProperties(Constructor.prototype, protoProps);</span><br><span class="line">    <span class="keyword">if</span> (staticProps) _defineProperties(Constructor, staticProps);</span><br><span class="line">    <span class="keyword">return</span> Constructor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_possibleConstructorReturn</span>(<span class="params">self, call</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (call &amp;&amp; (_typeof(call) === <span class="string">"object"</span> || <span class="keyword">typeof</span> call === <span class="string">"function"</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> call;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _assertThisInitialized(self);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_assertThisInitialized</span>(<span class="params">self</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (self === <span class="keyword">void</span> <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">ReferenceError</span>(<span class="string">"this hasn't been initialised - super() hasn't been called"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_getPrototypeOf</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">    _getPrototypeOf = <span class="built_in">Object</span>.setPrototypeOf ? <span class="built_in">Object</span>.getPrototypeOf : <span class="function"><span class="keyword">function</span> <span class="title">_getPrototypeOf</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> o.__proto__ || <span class="built_in">Object</span>.getPrototypeOf(o);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> _getPrototypeOf(o);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_inherits</span>(<span class="params">subClass, superClass</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> superClass !== <span class="string">"function"</span> &amp;&amp; superClass !== <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">"Super expression must either be null or a function"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    subClass.prototype = <span class="built_in">Object</span>.create(superClass &amp;&amp; superClass.prototype, &#123;</span><br><span class="line">        <span class="keyword">constructor</span>: &#123;</span><br><span class="line">            value: subClass,</span><br><span class="line">            writable: <span class="literal">true</span>,</span><br><span class="line">            configurable: <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">if</span> (superClass) _setPrototypeOf(subClass, superClass);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_setPrototypeOf</span>(<span class="params">o, p</span>) </span>&#123;</span><br><span class="line">    _setPrototypeOf = <span class="built_in">Object</span>.setPrototypeOf || <span class="function"><span class="keyword">function</span> <span class="title">_setPrototypeOf</span>(<span class="params">o, p</span>) </span>&#123;</span><br><span class="line">        o.__proto__ = p;</span><br><span class="line">        <span class="keyword">return</span> o;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> _setPrototypeOf(o, p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> App =</span><br><span class="line">    <span class="comment">/*#__PURE__*/</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> (<span class="params">_React$Component</span>) </span>&#123;</span><br><span class="line">        _inherits(App, _React$Component);</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> _this;</span><br><span class="line"></span><br><span class="line">            _classCallCheck(<span class="keyword">this</span>, App);</span><br><span class="line"></span><br><span class="line">            _this = _possibleConstructorReturn(<span class="keyword">this</span>, _getPrototypeOf(App).call(<span class="keyword">this</span>, props));</span><br><span class="line">            _this.state = &#123;</span><br><span class="line">                name: <span class="string">'Hello World'</span></span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">return</span> _this;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        _createClass(App, [&#123;</span><br><span class="line">            key: <span class="string">"componentDidMount"</span>,</span><br><span class="line">            value: <span class="function"><span class="keyword">function</span> <span class="title">componentDidMount</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">'component did mount'</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, &#123;</span><br><span class="line">            key: <span class="string">"render"</span>,</span><br><span class="line">            value: <span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> _react[<span class="string">"default"</span>].createElement(<span class="string">"div"</span>, <span class="literal">null</span>, <span class="keyword">this</span>.state.name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> App;</span><br><span class="line">    &#125;(_react[<span class="string">"default"</span>].Component);</span><br><span class="line"></span><br><span class="line">;</span><br><span class="line"></span><br><span class="line">_reactDom[<span class="string">"default"</span>].render(_react[<span class="string">"default"</span>].createElement(App, <span class="literal">null</span>), <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>));</span><br></pre></td></tr></table></figure><p>主要是 <code>var App</code> 开始的东西，可以看出这是一个立即执行函数，函数的参数是<code>React.Componnet</code>，函数内部写了一个名为<code>App</code>的构造函数，最后返回出这个构造函数。</p><p>其中的<code>_inherits(App, _React$Component);</code>这个函数是<code>babel</code>自行封装的继承。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">_createClass(App, [&#123;</span><br><span class="line">    key: <span class="string">"componentDidMount"</span>,</span><br><span class="line">    value: <span class="function"><span class="keyword">function</span> <span class="title">componentDidMount</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'component did mount'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, &#123;</span><br><span class="line">    key: <span class="string">"render"</span>,</span><br><span class="line">    value: <span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _react[<span class="string">"default"</span>].createElement(<span class="string">"div"</span>, <span class="literal">null</span>, <span class="keyword">this</span>.state.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;]);</span><br></pre></td></tr></table></figure><p>这个函数的作用是将第二个参数那个数组中的东西一个一个添加到构造<code>App</code>构造函数的原型链上。</p><p>最后调用<code>ReactDOM</code>的<code>render</code>方法，可以看出这其中的第一个参数是调用了<code>React.createElement</code>方法，包括在App组件中的render也是调用了这个函数。那么重点来了，看一下这个<code>React.createElement</code>方法</p><h2 id="React-createElement"><a href="#React-createElement" class="headerlink" title="React.createElement"></a>React.createElement</h2><p>大家都知道，React中的一个关键词就是<code>jsx</code>，babel在解析jsx语法时，就会调用<code>React.createElement</code>方法将jsx转换为一个<code>ReactElement</code>对象。在源码<code>/packages/react/src/ReactElement.js</code>文件中。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Create and return a new ReactElement of the given type.</span></span><br><span class="line"><span class="comment"> * See https://reactjs.org/docs/react-api.html#createelement</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> createElement(<span class="keyword">type</span>, <span class="keyword">config</span>, children) &#123;</span><br><span class="line">  <span class="keyword">let</span> propName;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Reserved names are extracted</span></span><br><span class="line">  <span class="keyword">const</span> props = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> key = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">let</span> <span class="keyword">ref</span> = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">let</span> self = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">let</span> source = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将 config 中的配置添加到 props 中</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">config</span> != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (hasValidRef(<span class="keyword">config</span>)) &#123;</span><br><span class="line">      <span class="keyword">ref</span> = <span class="keyword">config</span><span class="variable">.ref</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (hasValidKey(<span class="keyword">config</span>)) &#123;</span><br><span class="line">      key = '' + <span class="keyword">config</span><span class="variable">.key</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    self = <span class="keyword">config</span><span class="variable">.__self</span> === undefined ? <span class="literal">null</span> : <span class="keyword">config</span><span class="variable">.__self</span>;</span><br><span class="line">    source = <span class="keyword">config</span><span class="variable">.__source</span> === undefined ? <span class="literal">null</span> : <span class="keyword">config</span><span class="variable">.__source</span>;</span><br><span class="line">    <span class="comment">// Remaining properties are added to a new props object</span></span><br><span class="line">    <span class="keyword">for</span> (propName in <span class="keyword">config</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (</span><br><span class="line">        hasOwnProperty<span class="variable">.call</span>(<span class="keyword">config</span>, propName) &amp;&amp;</span><br><span class="line">        !RESERVED_PROPS<span class="variable">.hasOwnProperty</span>(propName)</span><br><span class="line">      ) &#123;</span><br><span class="line">        props[propName] = <span class="keyword">config</span>[propName];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 添加子节点</span></span><br><span class="line">  <span class="comment">// Children can be more than one argument, and those are transferred onto</span></span><br><span class="line">  <span class="comment">// the newly allocated props object.</span></span><br><span class="line">  <span class="keyword">const</span> childrenLength = arguments<span class="variable">.length</span> - <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">if</span> (childrenLength === <span class="number">1</span>) &#123;</span><br><span class="line">    props<span class="variable">.children</span> = children;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childrenLength &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> childArray = Array(childrenLength);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; childrenLength; i++) &#123;</span><br><span class="line">      childArray[i] = arguments[i + <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">__</span>DEV__) &#123;</span><br><span class="line">      <span class="keyword">if</span> (Object<span class="variable">.freeze</span>) &#123;</span><br><span class="line">        Object<span class="variable">.freeze</span>(childArray);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    props<span class="variable">.children</span> = childArray;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Resolve default props</span></span><br><span class="line">  <span class="comment">// 添加默认的props</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">type</span> &amp;&amp; <span class="keyword">type</span><span class="variable">.defaultProps</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> defaultProps = <span class="keyword">type</span><span class="variable">.defaultProps</span>;</span><br><span class="line">    <span class="keyword">for</span> (propName in defaultProps) &#123;</span><br><span class="line">      <span class="keyword">if</span> (props[propName] === undefined) &#123;</span><br><span class="line">        props[propName] = defaultProps[propName];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="number">__</span>DEV__) &#123;</span><br><span class="line">    <span class="comment">/**/</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ReactElement(</span><br><span class="line">    <span class="keyword">type</span>,</span><br><span class="line">    key,</span><br><span class="line">    <span class="keyword">ref</span>,</span><br><span class="line">    self,</span><br><span class="line">    source,</span><br><span class="line">    ReactCurrentOwner<span class="variable">.current</span>,</span><br><span class="line">    props,</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">config</span> != <span class="literal">null</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (hasValidRef(<span class="keyword">config</span>)) &#123;</span><br><span class="line">    <span class="keyword">ref</span> = <span class="keyword">config</span><span class="variable">.ref</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (hasValidKey(<span class="keyword">config</span>)) &#123;</span><br><span class="line">    key = '' + <span class="keyword">config</span><span class="variable">.key</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  self = <span class="keyword">config</span><span class="variable">.__self</span> === undefined ? <span class="literal">null</span> : <span class="keyword">config</span><span class="variable">.__self</span>;</span><br><span class="line">  source = <span class="keyword">config</span><span class="variable">.__source</span> === undefined ? <span class="literal">null</span> : <span class="keyword">config</span><span class="variable">.__source</span>;</span><br><span class="line">  <span class="comment">// Remaining properties are added to a new props object</span></span><br><span class="line">  <span class="keyword">for</span> (propName in <span class="keyword">config</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      hasOwnProperty<span class="variable">.call</span>(<span class="keyword">config</span>, propName) &amp;&amp;</span><br><span class="line">      !RESERVED_PROPS<span class="variable">.hasOwnProperty</span>(propName)</span><br><span class="line">    ) &#123;</span><br><span class="line">      props[propName] = <span class="keyword">config</span>[propName];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是将传入的<code>config</code>参数添加到<code>props</code>中.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> childrenLength = <span class="built_in">arguments</span>.length - <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (childrenLength === <span class="number">1</span>) &#123;</span><br><span class="line">  props.children = children;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (childrenLength &gt; <span class="number">1</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> childArray = <span class="built_in">Array</span>(childrenLength);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; childrenLength; i++) &#123;</span><br><span class="line">    childArray[i] = <span class="built_in">arguments</span>[i + <span class="number">2</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Object</span>.freeze) &#123;</span><br><span class="line">      <span class="built_in">Object</span>.freeze(childArray);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  props.children = childArray;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>arguments</code>是一个关键字，存储着函数的参数，是一个类数组对象，可以使用一些基本的数组api但是他本质上不是一个数组而是一个对象。使用<code>arguments.length - 2</code>除去前两个参数剩下的就都是子节点了。这边对数组的长度进行了判断，可以发现只有一个子节点的时候<code>props.children</code>值是一个对象，多个子节点时，值为一个数组，上面的那个例子体现不出这个，换成下面的例子然后在babel一下就可以看出这个参数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加一个div节点</span></span><br><span class="line">ReactDom.render(</span><br><span class="line">    &lt;App&gt;</span><br><span class="line">        &lt;div&gt;Hello World&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>App&gt;,</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line">);</span><br><span class="line"><span class="comment">// 转换成babel之后的结果</span></span><br><span class="line">_reactDom[<span class="string">"default"</span>].render(</span><br><span class="line">    _react[<span class="string">"default"</span>].createElement(</span><br><span class="line">        App,</span><br><span class="line">        <span class="literal">null</span>,</span><br><span class="line">        _react[<span class="string">"default"</span>].createElement(<span class="string">"div"</span>, <span class="literal">null</span>, <span class="string">"Hello World"</span>)</span><br><span class="line">    ),</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>这边可以看出又新加了一个<code>createElement</code>。</p><p>解析完children之后，添加进<code>props</code>对象里，在往下走，</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">type</span> &amp;&amp; <span class="keyword">type</span>.defaultProps) &#123;</span><br><span class="line">  <span class="keyword">const</span> defaultProps = <span class="keyword">type</span>.defaultProps;</span><br><span class="line">  <span class="keyword">for</span> (propName <span class="keyword">in</span> defaultProps) &#123;</span><br><span class="line">    <span class="keyword">if</span> (props[propName] === <span class="literal">undefined</span>) &#123;</span><br><span class="line">      props[propName] = defaultProps[propName];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一块是来解析<code>defaultProps</code></p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> ReactElement(</span><br><span class="line"><span class="built_in">    type,</span></span><br><span class="line"><span class="built_in">    key,</span></span><br><span class="line"><span class="built_in">    ref,</span></span><br><span class="line"><span class="built_in">    self,</span></span><br><span class="line"><span class="built_in">    source,</span></span><br><span class="line">    ReactCurrentOwner.current,</span><br><span class="line"><span class="built_in">    props,</span></span><br><span class="line">  )<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>最终这个<code>createElement</code>方法会返回一个<code>ReactElement</code>对象。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ReactElement = <span class="keyword">function</span>(<span class="keyword">type</span>, key, <span class="keyword">ref</span>, self, source, owner, props) &#123;</span><br><span class="line">  <span class="keyword">const</span> element = &#123;</span><br><span class="line">    <span class="comment">// This tag allows us to uniquely identify this as a React Element</span></span><br><span class="line">    <span class="comment">// 独特的唯一标示 表明这一个react元素</span></span><br><span class="line">    $$typeof: REACT_ELEMENT_TYPE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Built-in properties that belong on the element</span></span><br><span class="line">    <span class="keyword">type</span>: <span class="keyword">type</span>,</span><br><span class="line">    key: key,</span><br><span class="line">    <span class="keyword">ref</span>: <span class="keyword">ref</span>,</span><br><span class="line">    props: props,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Record the component responsible for creating this element.</span></span><br><span class="line">    <span class="comment">// 记录负责创建此节点的组件</span></span><br><span class="line">    <span class="number">_</span>owner: owner,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="number">__</span>DEV__) &#123;</span><br><span class="line">    <span class="comment">/**/</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> element;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>返回一个element对象，需要注意的是这边有一个标示符<code>$$typeof</code>，表明这是一个React.Element对象，源码中在英文注释</p><blockquote><p>  Factory method to create a new React element. This no longer adheres to<br> the class pattern, so do not use new to call it. Also, no instanceof check<br>  will work. Instead test $$typeof field against Symbol.for(‘react.element’) to check<br>  if something is a React Element.</p></blockquote><p>大概意思就是说以后不在坚持使用class来创建了，所以不要new调用它，同样的instancof也是没有效果的，取而代之的是使用一个标识符<code>$$typeof</code>值为一个sybmol对象<code>Symbol.for(&#39;react.element&#39;)</code></p><p>在这个文件的下方还有一个方法用来校验一个对象是不是<code>React.Element</code></p><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * <span class="type">Verifies</span> the <span class="keyword">object</span> <span class="keyword">is</span> a <span class="type">ReactElement</span>.</span><br><span class="line"> * <span class="type">See</span> https://reactjs.org/docs/react-api.html<span class="comment">#isvalidelement</span></span><br><span class="line"> * @param &#123;?<span class="keyword">object</span>&#125; <span class="keyword">object</span></span><br><span class="line"> * @<span class="keyword">return</span> &#123;boolean&#125; <span class="type">True</span> <span class="keyword">if</span> `<span class="keyword">object</span>` <span class="keyword">is</span> a <span class="type">ReactElement</span>.</span><br><span class="line"> * @final</span><br><span class="line"> */</span><br><span class="line"><span class="keyword">export</span> function isValidElement(<span class="keyword">object</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    typeof <span class="keyword">object</span> === '<span class="keyword">object</span>' &amp;&amp;</span><br><span class="line">    <span class="keyword">object</span> !== null &amp;&amp;</span><br><span class="line">    <span class="keyword">object</span>.$$typeof === <span class="type">REACT_ELEMENT_TYPE</span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接比对的<code>$$typeof</code>属性</p><h2 id="Component-PureComponent"><a href="#Component-PureComponent" class="headerlink" title="Component PureComponent"></a>Component PureComponent</h2><p>写一个React组件时，需要继承<code>React.Component</code>，而<code>PureComponent</code>和<code>Component</code>的区别在于，使用<code>PureComponent</code>可以在一定程度上优化<code>React</code>的性能，因为<code>PureComponent</code>内部是对<code>preProps nextProps</code>做了浅对比。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function Component(props, context, updater) &#123;</span><br><span class="line">  <span class="keyword">this</span>.props = props;</span><br><span class="line">  <span class="keyword">this</span>.context = context;</span><br><span class="line">  <span class="comment">// If a component has string refs, we will assign a different object later.</span></span><br><span class="line">  <span class="keyword">this</span>.refs = emptyObject;</span><br><span class="line">  <span class="comment">// We initialize the default updater but the real one gets injected by the</span></span><br><span class="line">  <span class="comment">// renderer.</span></span><br><span class="line">  <span class="keyword">this</span>.updater = updater || ReactNoopUpdateQueue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这边主要是<code>updater</code>有一个更新队列的东西，下次再说，之后在<code>Component</code>的原型上附加一系列的方法。而<code>PureComponent</code>是继承的<code>Component</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">PureComponent</span>(<span class="params">props, context, updater</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.props = props;</span><br><span class="line">  <span class="keyword">this</span>.context = context;</span><br><span class="line">  <span class="comment">// If a component has string refs, we will assign a different object later.</span></span><br><span class="line">  <span class="keyword">this</span>.refs = emptyObject;</span><br><span class="line">  <span class="keyword">this</span>.updater = updater || ReactNoopUpdateQueue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> pureComponentPrototype = (PureComponent.prototype = <span class="keyword">new</span> ComponentDummy());</span><br><span class="line">pureComponentPrototype.constructor = PureComponent;</span><br><span class="line"><span class="comment">// Avoid an extra prototype jump for these methods.</span></span><br><span class="line"><span class="built_in">Object</span>.assign(pureComponentPrototype, Component.prototype);</span><br><span class="line">pureComponentPrototype.isPureReactComponent = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><p>不同的地方在于<code>PureComponent</code>添加了一个属性用来表识该实例是一个<code>PureComponent</code><br><code>pureComponentPrototype.isPureReactComponent = true;</code></p><p>下一篇应该是记录<code>ReactDom.render</code>方法</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;上一篇介绍了React的Api，今天介绍createElement和React的Component相关操作。看了很多其他人的博客，对于React16的fiber架构还是无法了解，尽管我知道他很牛逼。发现了解React的源码还是需要从渲染开始进行了解
      
    
    </summary>
    
    
      <category term="源码" scheme="http://shenweini.cn/tags/%E6%BA%90%E7%A0%81/"/>
    
      <category term="React" scheme="http://shenweini.cn/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>React源码解析----API概览 + React.Children 解析</title>
    <link href="http://shenweini.cn/2019/09/15/React%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90----API%E6%A6%82%E8%A7%88%20+%20React.Children%20%E8%A7%A3%E6%9E%90/"/>
    <id>http://shenweini.cn/2019/09/15/React源码解析----API概览 + React.Children 解析/</id>
    <published>2019-09-15T06:19:08.567Z</published>
    <updated>2019-09-15T06:19:08.567Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>最近闲来无事，研究一波React源码，一开始是以Vue源码起步的，结果发现我对Vue实在是不熟悉，看Vue源码还不够格，相比而言，我更喜欢React，可能是因为第一个学的框架学的就是React，所以对React更加的充满热情，也更加的熟练，个人观点，React还是要比Vue牛逼一点好看一点的。</p><p>React本身的源码是很少的，根据打包出来的Commonjs版本看来，React只有两千多行代码，但是ReactDom据说有两万多行，框架开发者实属伟大！致敬！！！</p><p>那么这一篇是React一些通用的API概况和React.Children方法的解析，如有不到位或错误的地方欢迎指教，我的邮箱 <a href="mailto:1103107216@qq.com" target="_blank" rel="noopener">1103107216@qq.com</a> 您也可以下方评论。</p></blockquote><h2 id="React源码获取"><a href="#React源码获取" class="headerlink" title="React源码获取"></a>React源码获取</h2><p>我发现有两种方式，一种呢就是从<code>github</code>上拉取<code>react</code>项目的源码，github地址大家可以自己找，<code>git clone</code>下来之后，在<code>/packages/react</code>下面就是<code>react</code>的源码了，可以看到下面是分成了很多个小文件的，这个我一般用来看的不是用来调试的。</p><p>另一个呢就是建一个项目，安装一下<code>cnpm i react react-dom -S</code>之后在<code>node_modules</code>里面找到<code>react</code>的源码，建一个项目，用<code>webpack</code>打包，装个<code>babel</code>一套，毕竟es6比es5好使多了，开个热更新，之后就直接修改这个<code>node_modules</code>里面的源码进行打印调试了，我个人喜欢<code>console.log</code>不解释，只有在调试一些算法问题时我才会开Debug模式。</p><a id="more"></a><h2 id="通用API"><a href="#通用API" class="headerlink" title="通用API"></a>通用API</h2><p>首先先来一个简单的 React 应用,这边使用es6的class写法，个人建议多练练函数式编程，写函数组件比写class舒服多了，毕竟React16提供了这么多强大的Hook</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="type">React</span> from <span class="symbol">'reac</span>t';</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    constructor(props) &#123;</span><br><span class="line">        <span class="keyword">super</span>(props)</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                <span class="type">Hello</span> <span class="type">World</span></span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>OK, Hello World 致敬，我们可以开始干活了。首先看一下React的源码，在<code>/packages/react/src/React.js</code>这个文件里面，可以看到React的定义，你会发现和Vue的源码很不一样，这也是我更喜欢React的原因，慢慢的亲切感。</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">const React = &#123;</span><br><span class="line"><span class="symbol">  Children:</span> &#123;</span><br><span class="line"><span class="built_in">    map,</span></span><br><span class="line"><span class="built_in">    forEach,</span></span><br><span class="line"><span class="built_in">    count,</span></span><br><span class="line"><span class="built_in">    toArray,</span></span><br><span class="line"><span class="built_in">    only,</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line"><span class="built_in">  createRef,</span></span><br><span class="line"><span class="built_in">  Component,</span></span><br><span class="line"><span class="built_in">  PureComponent,</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">  createContext,</span></span><br><span class="line"><span class="built_in">  forwardRef,</span></span><br><span class="line"><span class="built_in">  lazy,</span></span><br><span class="line"><span class="built_in">  memo,</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">  useCallback,</span></span><br><span class="line"><span class="built_in">  useContext,</span></span><br><span class="line"><span class="built_in">  useEffect,</span></span><br><span class="line"><span class="built_in">  useImperativeHandle,</span></span><br><span class="line"><span class="built_in">  useDebugValue,</span></span><br><span class="line"><span class="built_in">  useLayoutEffect,</span></span><br><span class="line"><span class="built_in">  useMemo,</span></span><br><span class="line"><span class="built_in">  useReducer,</span></span><br><span class="line"><span class="built_in">  useRef,</span></span><br><span class="line"><span class="built_in">  useState,</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">  Fragment:</span> REACT_FRAGMENT_TYPE,</span><br><span class="line"><span class="symbol">  StrictMode:</span> REACT_STRICT_MODE_TYPE,</span><br><span class="line"><span class="symbol">  Suspense:</span> REACT_SUSPENSE_TYPE,</span><br><span class="line"></span><br><span class="line"><span class="symbol">  createElement: __DEV__ ? createElementWithValidation :</span> createElement,</span><br><span class="line"><span class="symbol">  cloneElement: __DEV__ ? cloneElementWithValidation :</span> cloneElement,</span><br><span class="line"><span class="symbol">  createFactory: __DEV__ ? createFactoryWithValidation :</span> createFactory,</span><br><span class="line"><span class="symbol">  isValidElement:</span> isValidElement,</span><br><span class="line"></span><br><span class="line"><span class="symbol">  version:</span> ReactVersion,</span><br><span class="line"></span><br><span class="line"><span class="symbol">  unstable_ConcurrentMode:</span> REACT_CONCURRENT_MODE_TYPE,</span><br><span class="line"><span class="symbol">  unstable_Profiler:</span> REACT_PROFILER_TYPE,</span><br><span class="line">  // 这一行跳过</span><br><span class="line"><span class="symbol">  __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED:</span> ReactSharedInternals,</span><br><span class="line">&#125;<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>这边定义了React里面的所有的通用方法，这边只做一个概览，每一个具体的用处会在后面进行详细的介绍。</p><h3 id="Children"><a href="#Children" class="headerlink" title="Children"></a>Children</h3><p>这个里面封装的是对一个组件的子组件进行遍历等的一些操作，我们一般不会用到，讲真我除了看源码会用他来试一试其他的真没见到有人用它。</p><ul><li><p>forEach,map 类似于数组的遍历对象遍历啥的</p></li><li><p>count 用来计算子组件的数量</p></li><li><p>only 官方解释：验证 children 是否只有一个子节点（一个 React 元素），如果有则返回它，否则此方法会抛出错误。 Tips：不可以使用<code>React.Children.map</code>方法的返回值作为参数，因为map的返回值是一个数组而不是一个React元素</p></li><li><p>toArray 将Children按照数组的形式扁平展开并返回</p></li></ul><p>搞不懂没关系，后面会介绍，有一个印象就好</p><h3 id="createRef"><a href="#createRef" class="headerlink" title="createRef"></a>createRef</h3><p>ref 属性是在开发中经常使用的，说白了就是用来获取真实Dom的，新版的React中使用ref的操作也变了</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.inputRef = <span class="type">React</span>.createRef();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 这是一种</span></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> &lt;input <span class="class"><span class="keyword">type</span></span>=<span class="string">"text"</span> ref=&#123;<span class="keyword">this</span>.inputRef&#125; /&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 这是另外一种</span></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> &lt;input <span class="class"><span class="keyword">type</span></span>=<span class="string">"text"</span> ref=&#123;node =&gt; <span class="keyword">this</span>.inputRef = node&#125;&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Component-PureComponent"><a href="#Component-PureComponent" class="headerlink" title="Component, PureComponent"></a>Component, PureComponent</h3><p>这两个大家应该都很熟悉，创建一个React组件，PureComponent在判断组件是否改更新的时候更加的方便。</p><h3 id="createContext"><a href="#createContext" class="headerlink" title="createContext"></a>createContext</h3><p>创建一个上下文，返回一个<code>Context</code>对象，里面包含了<code>Provider，Consumer</code>属性，一般用来往组件树的更深处传递数据，避免一个组件一个组件的往下传，不方便解藕</p><h3 id="forwardRef"><a href="#forwardRef" class="headerlink" title="forwardRef"></a>forwardRef</h3><p>创建一个React组件,这个组件能够将其接受的 ref 属性转发到其组件树下的另一个组件中.<code>React.forwardRef</code> 接受渲染函数作为参数。React 将使用 props 和 ref 作为参数来调用此函数。此函数应返回 React 节点。</p><h3 id="lazy"><a href="#lazy" class="headerlink" title="lazy"></a>lazy</h3><p>组件懒加载</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const SomeComponent = React.lazy(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'./SomeComponent'</span>));</span><br></pre></td></tr></table></figure><h3 id="memo"><a href="#memo" class="headerlink" title="memo"></a>memo</h3><p>用来创建一个HOC的</p><h3 id="useState…"><a href="#useState…" class="headerlink" title="useState…"></a>useState…</h3><p>接下来这几个就是React16大名鼎鼎的Hook函数，功能强大，函数式组件的福音，亲切感倍足</p><h3 id="Fragment-StrictMode-Suspense-unstable-ConcurrentMode-unstable-Profiler"><a href="#Fragment-StrictMode-Suspense-unstable-ConcurrentMode-unstable-Profiler" class="headerlink" title="Fragment StrictMode Suspense unstable_ConcurrentMode unstable_Profiler"></a>Fragment StrictMode Suspense unstable_ConcurrentMode unstable_Profiler</h3><p>这四个都是React提供的组件，但他们呢其实都只是占位符，都是一个Symbol，在React实际检测到他们的时候会做一些特殊的处理，比如StrictMode和AsyncMode会让他们的子节点对应的Fiber的mode都变成和他们一样的mode</p><h3 id="createElement"><a href="#createElement" class="headerlink" title="createElement"></a>createElement</h3><p>createElement 这是React中最重要的方法了，用来创建<code>ReactElement</code></p><h3 id="cloneElement"><a href="#cloneElement" class="headerlink" title="cloneElement"></a>cloneElement</h3><p>顾名思义，克隆一个<code>ReactElement</code></p><h3 id="createFactory"><a href="#createFactory" class="headerlink" title="createFactory"></a>createFactory</h3><p>创建一个工厂，这个工厂专门用来创建某一类<code>ReactElement</code></p><h3 id="isValidElement"><a href="#isValidElement" class="headerlink" title="isValidElement"></a>isValidElement</h3><p>用来检测是否是一个<code>ReactElement</code></p><h3 id="version"><a href="#version" class="headerlink" title="version"></a>version</h3><p>记录React的当前版本号</p><h2 id="React-Children-详解"><a href="#React-Children-详解" class="headerlink" title="React.Children 详解"></a>React.Children 详解</h2><blockquote><p>React.Children 提供了用于处理 this.props.children 不透明数据结构的实用方法。</p></blockquote><p>这一部分的代码在 <code>packages/react/react/src/ReactChildren.js</code>里面，主要分装了<code>forEach map count only toArray</code>，前两者用于遍历Reach Children。</p><ul><li><p><code>count</code> 用于返回该组件的children数量</p></li><li><p><code>only</code> 用于判断该组件是不是只有一个子节点</p></li><li><p><code>toArray</code> 将React.Children以扁平的形式返回出来，并附加<code>key</code></p></li></ul><p>在<code>React</code>中，一段文本可以被称为一个子节点，一段标签也可以被成为一个节点。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    constructor(props) &#123;</span><br><span class="line">        <span class="keyword">super</span>(props);</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="comment">// Hello World</span></span><br><span class="line">        console.log(<span class="keyword">this</span>.props.children);</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;&lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">ReactDom</span>.render(</span><br><span class="line">    &lt;<span class="type">App</span>&gt;</span><br><span class="line">        <span class="comment">// 一段文本也是一个子节点</span></span><br><span class="line">        <span class="type">Hello</span> <span class="type">World</span></span><br><span class="line">    &lt;/<span class="type">App</span>&gt; ,</span><br><span class="line">    document.getElementById(<span class="symbol">'roo</span>t')</span><br><span class="line">);</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">        <span class="keyword">super</span>(props);</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="comment">// 被标记为一个React.Element</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.props.children);</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDom.render(</span><br><span class="line">    &lt;App&gt;</span><br><span class="line">        <span class="comment">// 一段标签也可以是一个子节点</span></span><br><span class="line">        &lt;div&gt;Hello World&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>App&gt; ,</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>在上面的示例代码中，如果传递的子节点是一段html标签，那么打印出来的结果是这样的：</p><p><img src="http://static.zybuluo.com/shenweizheng/s26qv0gdxzzh7z46ri153dqa/image_1dkp91mf4199d1kds1ul615rklpr9.png" alt="image_1dkp91mf4199d1kds1ul615rklpr9.png-36.3kB"></p><p>我们也可以在<code>App</code>组件中显示我们传递的这个Children</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    constructor(props) &#123;</span><br><span class="line">        <span class="keyword">super</span>(props);</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">        console.log(<span class="keyword">this</span>.props.children);</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;&#123; <span class="keyword">this</span>.props.children &#125;&lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://static.zybuluo.com/shenweizheng/3mo8ztspn32aw1yv80rj3rrr/image_1dkp98tod16gl3u91q614tj1a7jm.png" alt="image_1dkp98tod16gl3u91q614tj1a7jm.png-2.4kB"></p><p>如果传递的是多个节点，那么就会被解析成一个数组</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">App</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>Hello China<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">App</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="http://static.zybuluo.com/shenweizheng/pgtbpsapbp5zibhv8w8v493t/image_1dkp9bfcjqb5ptn1dt02dm8lp13.png" alt="image_1dkp9bfcjqb5ptn1dt02dm8lp13.png-22.8kB"></p><p>那么<code>Reach.Children</code>的方法应该就是在这里进行使用，因为我实际上也没有使用过，做个简单的示例，我们可以打印一下<code>App</code>这个组件的子节点�数，使用<code>count</code>方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">        <span class="keyword">super</span>(props);</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="comment">// 2</span></span><br><span class="line">        <span class="built_in">console</span>.log(React.Children.count(<span class="keyword">this</span>.props.children));</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;&#123; <span class="keyword">this</span>.props.children &#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        )</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDom.render(</span></span><br><span class="line"><span class="regexp">    &lt;App&gt;</span></span><br><span class="line"><span class="regexp">        &lt;div&gt;Hello World&lt;/</span>div&gt;</span><br><span class="line">        &lt;div&gt;Hello China&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>App&gt; ,</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>这边会打印出来一个 2 因为我们传递的是两个节点</p><p>示例看完了我们可以来分析一下源码了，介绍一下<code>map</code>的源码</p><p>找到<code>ReactChildren.js</code>（这是在React源码里，不是在node_modules里），找到最下面模块导出语句</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">export &#123;</span><br><span class="line">  forEachChildren <span class="keyword">as</span> <span class="keyword">forEach</span>,</span><br><span class="line">  mapChildren <span class="keyword">as</span> map,</span><br><span class="line">  countChildren <span class="keyword">as</span> <span class="keyword">count</span>,</span><br><span class="line">  onlyChild <span class="keyword">as</span> only,</span><br><span class="line">  toArray,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看到<code>map</code>是<code>mapChildren</code>的一个别名，下面找到这个函数</p><figure class="highlight puppet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Maps children that are typically specified as `props.children`.</span><br><span class="line"> *</span><br><span class="line"> * See https://reactjs.org/docs/react-api.html<span class="comment">#reactchildrenmap</span></span><br><span class="line"> *</span><br><span class="line"> * The provided mapFunction(child, key, index) will be called for each</span><br><span class="line"> * leaf child.</span><br><span class="line"> *</span><br><span class="line"> * @<span class="keyword">param</span> &#123;?*&#125; <span class="keyword">children</span> <span class="keyword">Children</span> <span class="keyword">tree</span> <span class="keyword">container</span>.</span><br><span class="line"> * @<span class="keyword">param</span> &#123;function(*, int)&#125; <span class="keyword">func</span> <span class="keyword">The</span> <span class="keyword">map</span> <span class="keyword">function</span>.</span><br><span class="line"> * @<span class="keyword">param</span> &#123;*&#125; <span class="keyword">context</span> <span class="keyword">Context</span> <span class="keyword">for</span> <span class="keyword">mapFunction</span>.</span><br><span class="line"> * @<span class="keyword">return</span> &#123;object&#125; <span class="keyword">Object</span> <span class="keyword">containing</span> <span class="keyword">the</span> <span class="keyword">ordered</span> <span class="keyword">map</span> <span class="keyword">of</span> <span class="keyword">results</span>.</span><br><span class="line"> */</span><br><span class="line">function mapChildren(children, func, context) &#123;</span><br><span class="line">  if (children == null) &#123;</span><br><span class="line">    return children;</span><br><span class="line">  &#125;</span><br><span class="line">  const result = [];</span><br><span class="line">  mapIntoWithKeyPrefixInternal(children, result, null, func, context);</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法接受三个参数，第一个参数是我们传递的<code>this.props.children</code>,也是必选参数，第二个参数是一个function，在遍历的过程中，会对每一个节点都使用这个function，这个function接受一个参数，参数就是当前遍历的节点，第三个参数是一个上下文，一般不用传。<br>可以看出重点是<code>mapIntoWithKeyPrefixInternal</code>这个方法。</p><p>使用示例<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    constructor(props) &#123;</span><br><span class="line">        <span class="keyword">super</span>(props);</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="type">React</span>.<span class="type">Children</span>.map(<span class="keyword">this</span>.props.children, (item) =&gt; &#123;</span><br><span class="line">            console.log(item);</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;&#123; <span class="keyword">this</span>.props.children &#125;&lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function mapIntoWithKeyPrefixInternal(children, array, <span class="keyword">prefix</span>, <span class="function"><span class="keyword">func</span>, <span class="title">context</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 被忽视的前缀</span></span><br><span class="line">  <span class="keyword">let</span> escapedPrefix = '';</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">prefix</span> != null) &#123;</span><br><span class="line">    escapedPrefix = escapeUserProvidedKey(<span class="keyword">prefix</span>) + '/';</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 遍历上下文</span></span><br><span class="line">  const traverseContext = getPooledTraverseContext(</span><br><span class="line">    array,</span><br><span class="line">    escapedPrefix,</span><br><span class="line">    <span class="function"><span class="keyword">func</span>,</span></span><br><span class="line"><span class="function">    <span class="title">context</span>,</span></span><br><span class="line"><span class="function">  );</span></span><br><span class="line"><span class="function">  <span class="title">traverseAllChildren</span><span class="params">(children, mapSingleChildIntoContext, traverseContext)</span></span>;</span><br><span class="line">  releaseTraverseContext(traverseContext);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先是获取一下遍历的上下文，这个在后面的方法应该会用到，下面就是开始遍历所有的Children了，重点是<code>traverseAllChildren(children, mapSingleChildIntoContext, traverseContext);</code>，第一个参数好理解就是我们传递的<code>this.props.children</code>，第二个参数是一个方法，第三个参数就是前面获取到的遍历上下文。</p><p>首先看一下这个<code>getPooledTraverseContext</code>方法</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> POOL_SIZE = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> traverseContextPool = [];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getPooledTraverseContext</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  mapResult,</span></span></span><br><span class="line"><span class="function"><span class="params">  keyPrefix,</span></span></span><br><span class="line"><span class="function"><span class="params">  mapFunction,</span></span></span><br><span class="line"><span class="function"><span class="params">  mapContext,</span></span></span><br><span class="line"><span class="function"><span class="params">)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (traverseContextPool.length) &#123;</span><br><span class="line">    <span class="keyword">const</span> traverseContext = traverseContextPool.pop();</span><br><span class="line">    traverseContext.result = mapResult;</span><br><span class="line">    traverseContext.keyPrefix = keyPrefix;</span><br><span class="line">    traverseContext.func = mapFunction;</span><br><span class="line">    traverseContext.context = mapContext;</span><br><span class="line">    traverseContext.count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> traverseContext;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      result: mapResult,</span><br><span class="line">      keyPrefix: keyPrefix,</span><br><span class="line">      func: mapFunction,</span><br><span class="line">      context: mapContext,</span><br><span class="line">      count: <span class="number">0</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用了一个闭包，外层有一个<code>traverseContextPool</code>记录者遍历上下文的一个<code>pool</code>，我脑海中蹦出来的词是连接池，所以暂且就这么理解他，这个连接池的容量为10，如果这个连接池里有东西的话，也就是说这个<code>traverseContextPool.length !== 0</code>的话，那么会弹出最后一个进行赋值然后返回，如果池里没有东西的话就直接返回一个新的对象。</p><p>下面看重点方法<code>traverseAllChildren</code></p><figure class="highlight puppet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Traverses children that are typically specified as `props.children`, but</span><br><span class="line"> * might also be specified through attributes:</span><br><span class="line"> *</span><br><span class="line"> * - `traverseAllChildren(this.props.children, ...)`</span><br><span class="line"> * - `traverseAllChildren(this.props.leftPanelChildren, ...)`</span><br><span class="line"> *</span><br><span class="line"> * The `traverseContext` is an optional argument that is passed through the</span><br><span class="line"> * entire traversal. It can be used to store accumulations or anything else that</span><br><span class="line"> * the callback might find relevant.</span><br><span class="line"> *</span><br><span class="line"> * @<span class="keyword">param</span> &#123;?*&#125; <span class="keyword">children</span> <span class="keyword">Children</span> <span class="keyword">tree</span> <span class="keyword">object</span>.</span><br><span class="line"> * @<span class="keyword">param</span> &#123;!function&#125; <span class="keyword">callback</span> <span class="keyword">To</span> <span class="keyword">invoke</span> <span class="keyword">upon</span> <span class="keyword">traversing</span> <span class="keyword">each</span> <span class="keyword">child</span>.</span><br><span class="line"> * @<span class="keyword">param</span> &#123;?*&#125; <span class="keyword">traverseContext</span> <span class="keyword">Context</span> <span class="keyword">for</span> <span class="keyword">traversal</span>.</span><br><span class="line"> * @<span class="keyword">return</span> &#123;!number&#125; <span class="keyword">The</span> <span class="keyword">number</span> <span class="keyword">of</span> <span class="keyword">children</span> <span class="keyword">in</span> <span class="keyword">this</span> <span class="keyword">subtree</span>.</span><br><span class="line"> */</span><br><span class="line">function traverseAllChildren(children, callback, traverseContext) &#123;</span><br><span class="line">  if (children == null) &#123;</span><br><span class="line">    return 0;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return traverseAllChildrenImpl(children, <span class="string">''</span>, callback, traverseContext);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要看这个方法的实现<code>traverseAllChildrenImpl</code></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;?*&#125; children Children tree container.</span></span><br><span class="line"><span class="comment"> * @param &#123;!string&#125; nameSoFar Name of the key path so far.</span></span><br><span class="line"><span class="comment"> * @param &#123;!function&#125; callback Callback to invoke with each child found.</span></span><br><span class="line"><span class="comment"> * @param &#123;?*&#125; traverseContext Used to pass information throughout the traversal</span></span><br><span class="line"><span class="comment"> * process.</span></span><br><span class="line"><span class="comment"> * @return &#123;!number&#125; The number of children in this subtree.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">traverseAllChildrenImpl</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  children,</span></span></span><br><span class="line"><span class="function"><span class="params">  nameSoFar,</span></span></span><br><span class="line"><span class="function"><span class="params">  callback,</span></span></span><br><span class="line"><span class="function"><span class="params">  traverseContext,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">type</span> = <span class="keyword">typeof</span> children;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">type</span> === <span class="string">'undefined'</span> || <span class="keyword">type</span> === <span class="string">'boolean'</span>) &#123;</span><br><span class="line">    <span class="comment">// All of the above are perceived as null.</span></span><br><span class="line">    children = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> invokeCallback = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (children === <span class="literal">null</span>) &#123;</span><br><span class="line">    invokeCallback = <span class="literal">true</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> (<span class="keyword">type</span>) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'string'</span>:</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'number'</span>:</span><br><span class="line">        invokeCallback = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'object'</span>:</span><br><span class="line">        <span class="keyword">switch</span> (children.$$<span class="keyword">typeof</span>) &#123;</span><br><span class="line">          <span class="keyword">case</span> REACT_ELEMENT_TYPE:</span><br><span class="line">          <span class="keyword">case</span> REACT_PORTAL_TYPE:</span><br><span class="line">            invokeCallback = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (invokeCallback) &#123;</span><br><span class="line">    callback(</span><br><span class="line">      traverseContext,</span><br><span class="line">      children,</span><br><span class="line">      <span class="comment">// If it's the only child, treat the name as if it was wrapped in an array</span></span><br><span class="line">      <span class="comment">// so that it's consistent if the number of children grows.</span></span><br><span class="line">      nameSoFar === <span class="string">''</span> ? SEPARATOR + getComponentKey(children, <span class="number">0</span>) : nameSoFar,</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> child;</span><br><span class="line">  <span class="keyword">let</span> nextName;</span><br><span class="line">  <span class="keyword">let</span> subtreeCount = <span class="number">0</span>; <span class="comment">// Count of children found in the current subtree.</span></span><br><span class="line">  <span class="keyword">const</span> nextNamePrefix =</span><br><span class="line">    nameSoFar === <span class="string">''</span> ? SEPARATOR : nameSoFar + SUBSEPARATOR;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(children)) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; children.length; i++) &#123;</span><br><span class="line">      child = children[i];</span><br><span class="line">      nextName = nextNamePrefix + getComponentKey(child, i);</span><br><span class="line">      subtreeCount += traverseAllChildrenImpl(</span><br><span class="line">        child,</span><br><span class="line">        nextName,</span><br><span class="line">        callback,</span><br><span class="line">        traverseContext,</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> iteratorFn = getIteratorFn(children);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> iteratorFn === <span class="string">'function'</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">        <span class="comment">// Warn about using Maps as children</span></span><br><span class="line">        <span class="keyword">if</span> (iteratorFn === children.entries) &#123;</span><br><span class="line">          warning(</span><br><span class="line">            didWarnAboutMaps,</span><br><span class="line">            <span class="string">'Using Maps as children is unsupported and will likely yield '</span> +</span><br><span class="line">              <span class="string">'unexpected results. Convert it to a sequence/iterable of keyed '</span> +</span><br><span class="line">              <span class="string">'ReactElements instead.'</span>,</span><br><span class="line">          );</span><br><span class="line">          didWarnAboutMaps = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> iterator = iteratorFn.call(children);</span><br><span class="line">      <span class="keyword">let</span> step;</span><br><span class="line">      <span class="keyword">let</span> ii = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span> (!(step = iterator.next()).done) &#123;</span><br><span class="line">        child = step.value;</span><br><span class="line">        nextName = nextNamePrefix + getComponentKey(child, ii++);</span><br><span class="line">        subtreeCount += traverseAllChildrenImpl(</span><br><span class="line">          child,</span><br><span class="line">          nextName,</span><br><span class="line">          callback,</span><br><span class="line">          traverseContext,</span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">type</span> === <span class="string">'object'</span>) &#123;</span><br><span class="line">      <span class="keyword">let</span> addendum = <span class="string">''</span>;</span><br><span class="line">      <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">        addendum =</span><br><span class="line">          <span class="string">' If you meant to render a collection of children, use an array '</span> +</span><br><span class="line">          <span class="string">'instead.'</span> +</span><br><span class="line">          ReactDebugCurrentFrame.getStackAddendum();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">const</span> childrenString = <span class="string">''</span> + children;</span><br><span class="line">      invariant(</span><br><span class="line">        <span class="literal">false</span>,</span><br><span class="line">        <span class="string">'Objects are not valid as a React child (found: %s).%s'</span>,</span><br><span class="line">        childrenString === <span class="string">'[object Object]'</span></span><br><span class="line">          ? <span class="string">'object with keys &#123;'</span> + <span class="built_in">Object</span>.keys(children).join(<span class="string">', '</span>) + <span class="string">'&#125;'</span></span><br><span class="line">          : childrenString,</span><br><span class="line">        addendum,</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> subtreeCount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分步解析<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">let invokeCallback = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (children === <span class="literal">null</span>) &#123;</span><br><span class="line">    invokeCallback = <span class="literal">true</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'string'</span>:</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'number'</span>:</span><br><span class="line">        invokeCallback = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'object'</span>:</span><br><span class="line">        <span class="keyword">switch</span> (children.$$typeof) &#123;</span><br><span class="line">          <span class="keyword">case</span> <span class="string">REACT_ELEMENT_TYPE:</span></span><br><span class="line">          <span class="keyword">case</span> <span class="string">REACT_PORTAL_TYPE:</span></span><br><span class="line">            invokeCallback = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (invokeCallback) &#123;</span><br><span class="line">    callback(</span><br><span class="line">      traverseContext,</span><br><span class="line">      children,</span><br><span class="line">      <span class="comment">// If it's the only child, treat the name as if it was wrapped in an array</span></span><br><span class="line">      <span class="comment">// so that it's consistent if the number of children grows.</span></span><br><span class="line">      nameSoFar === <span class="string">''</span> ? SEPARATOR + getComponentKey(children, 0) : nameSoFar,</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>这一块是用来判断 children 类型的，如果是<code>string</code>比如说传递一个文本，<code>number</code>,<code>object</code>比如说一个dom节点，那么表明 children 只是一个节点，那么就直接执行 <code>callback</code> 返回一个 1</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (Array.isArray(children)) &#123;</span><br><span class="line">    <span class="keyword">for</span> (let <span class="built_in">i</span> = <span class="number">0</span>; <span class="built_in">i</span> &lt; children.<span class="built_in">length</span>; <span class="built_in">i</span>++) &#123;</span><br><span class="line">      child = children[<span class="built_in">i</span>];</span><br><span class="line">      nextName = nextNamePrefix + getComponentKey(child, <span class="built_in">i</span>);</span><br><span class="line">      subtreeCount += traverseAllChildrenImpl(</span><br><span class="line">        child,</span><br><span class="line">        nextName,</span><br><span class="line">        callback,</span><br><span class="line">        traverseContext,</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>如果我们传递的是多个节点，那么会遍历children数组，进行递归遍历，直到返回的是上面显示的几个类型。</p><p>上边提到的<code>callback</code>就是传递的<code>mapSingleChildIntoContext</code>,这边就是利用到之前的<code>traverseContextPool</code>被我称之为连接池的东西.</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">function mapSingleChildIntoContext(bookKeeping, child, childKey) &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123;result, keyPrefix, <span class="function"><span class="keyword">func</span>, <span class="title">context</span>&#125; = <span class="title">bookKeeping</span>;</span></span><br><span class="line"></span><br><span class="line">  let mappedChild = <span class="function"><span class="keyword">func</span>.<span class="title">call</span><span class="params">(context, child, bookKeeping.count++)</span>;</span></span><br><span class="line">  <span class="keyword">if</span> (Array.<span class="built_in">isArray</span>(mappedChild)) &#123;</span><br><span class="line">    mapIntoWithKeyPrefixInternal(mappedChild, result, childKey, c =&gt; c)<span class="comment">;</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mappedChild != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (isValidElement(mappedChild)) &#123;</span><br><span class="line">      mappedChild = cloneAndReplaceKey(</span><br><span class="line">        mappedChild,</span><br><span class="line">        // Keep both the (mapped) <span class="literal">and</span> old keys <span class="keyword">if</span> they differ, just as</span><br><span class="line">        // traverseAllChildren used <span class="keyword">to</span> <span class="keyword">do</span> <span class="keyword">for</span> objects as children</span><br><span class="line">        keyPrefix +</span><br><span class="line">          (mappedChild.key &amp;&amp; (!child || child.key !== mappedChild.key)</span><br><span class="line">            ? escapeUserProvidedKey(mappedChild.key) + <span class="string">'/'</span></span><br><span class="line">            : <span class="string">''</span>) +</span><br><span class="line">          childKey,</span><br><span class="line">      )<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">    result.push(mappedChild)<span class="comment">;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这边的<code>mappedChild</code>就是我们传递的funcion的返回值，function呢就是调用<code>React.Children.map(children,callback)</code>这里的callback了，如果这个返回值返回的是一个数组的话，那么就进行递归调用，这个时候就需要用到之前的连接池了。</p><p>采用这个连接池的目的我也是在其他的地方看到了</p><blockquote><p>因为对Children的处理一般在render里面，所以会比较频繁，所以设置一个pool减少声明和gc的开销</p></blockquote><p>这就是<code>React.Children.map</code>的实现。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;最近闲来无事，研究一波React源码，一开始是以Vue源码起步的，结果发现我对Vue实在是不熟悉，看Vue源码还不够格，相比而言，我更喜欢React，可能是因为第一个学的框架学的就是React，所以对React更加的充满热情，也更加的熟练，个人观点，React还是要比Vue牛逼一点好看一点的。&lt;/p&gt;
&lt;p&gt;React本身的源码是很少的，根据打包出来的Commonjs版本看来，React只有两千多行代码，但是ReactDom据说有两万多行，框架开发者实属伟大！致敬！！！&lt;/p&gt;
&lt;p&gt;那么这一篇是React一些通用的API概况和React.Children方法的解析，如有不到位或错误的地方欢迎指教，我的邮箱 &lt;a href=&quot;mailto:1103107216@qq.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;1103107216@qq.com&lt;/a&gt; 您也可以下方评论。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;React源码获取&quot;&gt;&lt;a href=&quot;#React源码获取&quot; class=&quot;headerlink&quot; title=&quot;React源码获取&quot;&gt;&lt;/a&gt;React源码获取&lt;/h2&gt;&lt;p&gt;我发现有两种方式，一种呢就是从&lt;code&gt;github&lt;/code&gt;上拉取&lt;code&gt;react&lt;/code&gt;项目的源码，github地址大家可以自己找，&lt;code&gt;git clone&lt;/code&gt;下来之后，在&lt;code&gt;/packages/react&lt;/code&gt;下面就是&lt;code&gt;react&lt;/code&gt;的源码了，可以看到下面是分成了很多个小文件的，这个我一般用来看的不是用来调试的。&lt;/p&gt;
&lt;p&gt;另一个呢就是建一个项目，安装一下&lt;code&gt;cnpm i react react-dom -S&lt;/code&gt;之后在&lt;code&gt;node_modules&lt;/code&gt;里面找到&lt;code&gt;react&lt;/code&gt;的源码，建一个项目，用&lt;code&gt;webpack&lt;/code&gt;打包，装个&lt;code&gt;babel&lt;/code&gt;一套，毕竟es6比es5好使多了，开个热更新，之后就直接修改这个&lt;code&gt;node_modules&lt;/code&gt;里面的源码进行打印调试了，我个人喜欢&lt;code&gt;console.log&lt;/code&gt;不解释，只有在调试一些算法问题时我才会开Debug模式。&lt;/p&gt;
    
    </summary>
    
    
      <category term="源码" scheme="http://shenweini.cn/tags/%E6%BA%90%E7%A0%81/"/>
    
      <category term="React" scheme="http://shenweini.cn/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>void (0) ??? undefined ???</title>
    <link href="http://shenweini.cn/2019/09/10/void%20(0)%20???%20undefined%20???/"/>
    <id>http://shenweini.cn/2019/09/10/void (0) ??? undefined ???/</id>
    <published>2019-09-10T06:58:13.686Z</published>
    <updated>2019-09-10T11:36:09.242Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>今天看React的源码，发现了一个很有意思的写法，在<code>ReactChildren.js</code>中看见了这么一行代码<code>var child = void 0</code>,这个是出现在React编译之后的<code>cjs/react.development.js</code>中。在我的认知里，<code>void</code>是用来表示一个函数没有返回值的。尽然还有这种写法，是JS的神奇的magic嘛</p></blockquote><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>首先看几个示例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">void</span> <span class="number">0</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">void</span> <span class="number">100</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">void</span> <span class="literal">true</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">void</span> alert(<span class="string">'test'</span>));</span><br></pre></td></tr></table></figure><p>在看打印的结果</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">undefined</span></span><br><span class="line"><span class="literal">undefined</span></span><br><span class="line"><span class="literal">undefined</span></span><br><span class="line"><span class="literal">undefined</span></span><br></pre></td></tr></table></figure><p>结果都是<code>undefined</code></p><p>那么和<code>undefined</code> 做一个比较</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log((<span class="keyword">void</span> <span class="number">0</span>) === <span class="literal">undefined</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>可以发现 <code>void 0</code> 是可以作为<code>undefined</code> 的一个替代</p><a id="more"></a><h2 id="void-运算符"><a href="#void-运算符" class="headerlink" title="void 运算符"></a>void 运算符</h2><p>查看 MDN 的解释</p><blockquote><p>void 运算符 对给定的表达式进行求值，然后返回 undefined。</p><p>这个运算符能向期望一个表达式的值是undefined的地方插入会产生副作用的表达式。<br>void 运算符通常只用于获取 undefined的原始值，一般使用void(0)（等同于void 0）。在上述情况中，也可以使用全局变量undefined 来代替（假定其仍是默认值）。</p></blockquote><p>直白的讲就是会调用后面的表达式然后返回一个<code>undefined</code></p><p>做个示例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">void</span> (<span class="built_in">console</span>.log(<span class="string">'test console'</span>)));</span><br><span class="line"></span><br><span class="line"><span class="comment">// test console</span></span><br><span class="line"><span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>如果直接写成 <code>void 0</code> 后面的表达式没有任何操作的话，那么就是无副作用的。</p><h2 id="void-和-undefined-的区别"><a href="#void-和-undefined-的区别" class="headerlink" title="void 和 undefined 的区别"></a>void 和 undefined 的区别</h2><p><code>undefined</code>不是保留字，只是全局对象的一个属性，在低版本的ie上是可以改写的,但是我发现在chrome上也可以改写，神奇。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;今天看React的源码，发现了一个很有意思的写法，在&lt;code&gt;ReactChildren.js&lt;/code&gt;中看见了这么一行代码&lt;code&gt;var child = void 0&lt;/code&gt;,这个是出现在React编译之后的&lt;code&gt;cjs/react.development.js&lt;/code&gt;中。在我的认知里，&lt;code&gt;void&lt;/code&gt;是用来表示一个函数没有返回值的。尽然还有这种写法，是JS的神奇的magic嘛&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;示例&quot;&gt;&lt;a href=&quot;#示例&quot; class=&quot;headerlink&quot; title=&quot;示例&quot;&gt;&lt;/a&gt;示例&lt;/h2&gt;&lt;p&gt;首先看几个示例&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; alert(&lt;span class=&quot;string&quot;&gt;&#39;test&#39;&lt;/span&gt;));&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在看打印的结果&lt;/p&gt;
&lt;figure class=&quot;highlight actionscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;literal&quot;&gt;undefined&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;literal&quot;&gt;undefined&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;literal&quot;&gt;undefined&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;literal&quot;&gt;undefined&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;结果都是&lt;code&gt;undefined&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;那么和&lt;code&gt;undefined&lt;/code&gt; 做一个比较&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log((&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;) === &lt;span class=&quot;literal&quot;&gt;undefined&lt;/span&gt;); &lt;span class=&quot;comment&quot;&gt;// true&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;可以发现 &lt;code&gt;void 0&lt;/code&gt; 是可以作为&lt;code&gt;undefined&lt;/code&gt; 的一个替代&lt;/p&gt;
    
    </summary>
    
    
      <category term="js" scheme="http://shenweini.cn/tags/js/"/>
    
      <category term="magic" scheme="http://shenweini.cn/tags/magic/"/>
    
  </entry>
  
  <entry>
    <title>Nginx 反向代理 + 缓存 + 静态资源服务器 + 负载均衡</title>
    <link href="http://shenweini.cn/2019/08/23/Nginx%20%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%20+%20%E7%BC%93%E5%AD%98%20+%20%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E6%9C%8D%E5%8A%A1%E5%99%A8%20+%20%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
    <id>http://shenweini.cn/2019/08/23/Nginx 反向代理 + 缓存 + 静态资源服务器 + 负载均衡/</id>
    <published>2019-08-23T13:32:40.481Z</published>
    <updated>2019-08-23T13:32:40.482Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>nginx经常挂在嘴边的就是反向代理，不过他还可以干很多事，我所了解的只是反向代理、静态文件缓存、静态资源服务器，对于负载均衡只是略有涉及。</p></blockquote><blockquote><p>Nginx (“engine x”) 是一个高性能的 HTTP 和 反向代理 服务器 ，也是一个 IMAP/POP3/SMTP 代理 服务器 。 Nginx 是由 Igor Sysoev 为俄罗斯访问量第二的 Rambler.ru 站点开发的，第一个公开版本0.1.0发布于2004年10月4日。其将源代码以类BSD许可证的形式发布，因它的稳定性、丰富的功能集、示例配置文件和低系统资源的消耗而闻名</p></blockquote><blockquote><p>引用一下菜鸟教程的简介：Nginx功能丰富，可作为HTTP服务器，也可作为反向代理服务器，邮件服务器。支持FastCGI、SSL、Virtual Host、URL Rewrite、Gzip等功能。并且支持很多第三方的模块扩展。Nginx的稳定性、功能集、示例配置文件和低系统资源的消耗让他后来居上，在全球活跃的网站中有12.18%的使用比率，大约为2220万个网站。</p></blockquote><blockquote><p>特点<br>(1)：代理服务器，快速高效反向代理，提升网站性能。<br>(2)：负载均衡器，内部支持Rails和PHP,也可支持HTTP代理服务器，对外进行服务。同时支持简单容错和利用算法进行负载均衡。<br>(3)：性能方面，Nginx专门为性能设计，实现注重效率。采用Poll模型，可以支持更多的并发连接，并在大并发时占用很低内存。<br>(4)：稳定性方面，采用分阶段资源分配技术，使CPU资源占用率低。<br>(5)：高可用性方面，支持热备，启动迅速。</p></blockquote><a id="more"></a><h2 id="nginx安装"><a href="#nginx安装" class="headerlink" title="nginx安装"></a>nginx安装</h2><p>mac 下安装</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">brew </span><span class="keyword">install </span>nginx</span><br></pre></td></tr></table></figure><p>安装目录为 <code>/usr/local/Cellar/nginx/1.17.2/</code><br>配置文件目录为 <code>/usr/local/etc/nginx/nginx.conf</code><br>服务器默认路径 <code>/usr/local/var/www</code></p><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><p>mac 下的启动命令</p><ul><li><p>启动 <code>nginx</code></p></li><li><p>快速停止关闭 <code>nignx -s stop</code></p></li><li><p>优雅的关闭 <code>nginx -s quit</code></p></li><li><p>承载配置文件 <code>nginx -s reload</code></p></li><li><p>查看nginx进程 <code>ps -ef | grep nginx</code></p></li><li><p>查看配置文件是否正确 <code>nginx -t</code></p></li><li><p>优雅的杀死nginx进程 <code>kill -quit 进程号</code></p></li><li><p>快速的杀死nginx进程 <code>kill -term 进程号</code></p></li></ul><h2 id="nginx配置"><a href="#nginx配置" class="headerlink" title="nginx配置"></a>nginx配置</h2><p>nginx 文件的默认配置文件位置 <code>/usr/local/etc/nginx/nginx.conf</code></p><p>打开 <code>/usr/local/etc/nginx/</code> 目录可以看到，里面有很多的配置文件，启动有一个<code>nginx.conf</code> 和 <code>nginx.conf.default</code>两个配置文件,刚开始安装的时候，两个文件的内容是一样的，所以我们可以肆意的修改<code>nginx.conf</code>搞崩的话就直接把<code>nginx.conf.default</code>中的内容复制过来就行了又是一个新的nginx。</p><h3 id="配置文件架构"><a href="#配置文件架构" class="headerlink" title="配置文件架构"></a>配置文件架构</h3><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// nginx全局块</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// events块</span></span><br><span class="line">events &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// http 块</span></span><br><span class="line">http &#123;</span><br><span class="line">    <span class="comment">// http全局块</span></span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// server块</span></span><br><span class="line">    server &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// http全局块</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="配置文件加注释说明"><a href="#配置文件加注释说明" class="headerlink" title="配置文件加注释说明"></a>配置文件加注释说明</h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># 配置nginx的用户组 默认为nobody</span></span><br><span class="line"><span class="meta">#user  nobody;</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># 配置nginx的主线程数量 nginx是一个主线程下面多个子线程</span></span><br><span class="line">worker_processes  <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta"># 配置nginx的错误日志 格式为 log路径 log级别</span></span><br><span class="line"><span class="meta"># error_log 的日志级别为： debug info notice warn <span class="meta-keyword">error</span> crit alert emerg 紧急由低到高</span></span><br><span class="line"><span class="meta"># error_log的默认日志级别为<span class="meta-keyword">error</span>，那么就只有紧急程度大于等于<span class="meta-keyword">error</span>的才会记录在日志</span></span><br><span class="line"><span class="meta"># error_log 的作用域为 main http mail stream server location</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#error_log  logs/<span class="meta-keyword">error</span>.log;</span></span><br><span class="line"><span class="meta">#error_log  logs/<span class="meta-keyword">error</span>.log  notice;</span></span><br><span class="line"><span class="meta">#error_log  logs/<span class="meta-keyword">error</span>.log  info;</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># 指定nginx进程运行文件存放地址</span></span><br><span class="line"><span class="meta">#pid        logs/nginx.pid;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    <span class="meta"># poll是多路复用IO中的一种方式,但是仅用于linux2.6以上内核,可以大大提高nginx的性能</span></span><br><span class="line">    <span class="meta"># use poll</span></span><br><span class="line">    </span><br><span class="line">    <span class="meta"># 设置网络的连接序列化 防止惊群现象发生 默认为 on</span></span><br><span class="line">    <span class="meta"># accept_mutex on;</span></span><br><span class="line">    </span><br><span class="line">    <span class="meta"># 设置一个进程是否同时接受多个网络连接 默认为 off</span></span><br><span class="line">    <span class="meta"># multi_accept off</span></span><br><span class="line">    </span><br><span class="line">    <span class="meta"># 最大连接数 默认为 512</span></span><br><span class="line">    worker_connections  <span class="number">1024</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    <span class="meta"># 文件扩展名和文件类型映射表</span></span><br><span class="line">    include       mime.types;</span><br><span class="line">    </span><br><span class="line">    <span class="meta"># 默认文件类型</span></span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line">    </span><br><span class="line">    <span class="meta"># 日志格式 文章后面会介绍</span></span><br><span class="line">    <span class="meta">#log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '</span></span><br><span class="line">    <span class="meta">#                  '$status $body_bytes_sent "$http_referer" '</span></span><br><span class="line">    <span class="meta">#                  '"$http_user_agent" "$http_x_forwarded_for"';</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 允许通过日志配置</span></span><br><span class="line">    <span class="meta">#access_log  logs/access.log  main;</span></span><br><span class="line">    </span><br><span class="line">    <span class="meta"># sendfile 指定使用 sendfile 系统调用来传输文件。优点在于在两个文件描述符之间传递数据（完全在内核中操作），从而避免了数据在内核缓冲区和用户缓冲区之间的拷贝，效率高，称之为零拷贝，这个东西有点讲究，自行百度</span></span><br><span class="line">    <span class="meta"># sendfile 作用域 location server http</span></span><br><span class="line">    sendfile        <span class="keyword">on</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">#tcp_nopush     on;</span></span><br><span class="line">    </span><br><span class="line">    <span class="meta"># 链接超时时间 默认 75s 作用域 http server location</span></span><br><span class="line">    <span class="meta">#keepalive_timeout  0;</span></span><br><span class="line">    keepalive_timeout  <span class="number">65</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="meta"># 开始gzip压缩</span></span><br><span class="line">    <span class="meta">#gzip  on;</span></span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        <span class="meta"># 端口号</span></span><br><span class="line">        listen       <span class="number">8080</span>;</span><br><span class="line">        <span class="meta"># 域名或ip</span></span><br><span class="line">        server_name  localhost;</span><br><span class="line"></span><br><span class="line">        <span class="meta">#charset koi8-r;</span></span><br><span class="line"></span><br><span class="line">        <span class="meta">#access_log  logs/host.access.log  main;</span></span><br><span class="line">        </span><br><span class="line">        <span class="meta"># 对请求的路由进行过滤 正则匹配</span></span><br><span class="line">        location / &#123;</span><br><span class="line">            root   html;</span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    include servers<span class="comment">/*;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="nginx-日志"><a href="#nginx-日志" class="headerlink" title="nginx 日志"></a>nginx 日志</h2><p>nginx的日志大致分为 <code>access_log</code> 和 <code>error_log</code>。error_log 记录的是nginx的错误日志。（以下对日志的理解不是很全面，还只是基础的）</p><h3 id="error-log"><a href="#error-log" class="headerlink" title="error_log"></a>error_log</h3><ul><li>记录nginx错误日志</li><li>作用域为 <code>main http mail stream server location</code></li><li>日志级别 <code>debug info notice warn error crit alert emerg</code></li><li>日志级别默认为 error 当级别高于或等于指定级别时才会记录</li></ul><h3 id="access-log"><a href="#access-log" class="headerlink" title="access_log"></a>access_log</h3><ul><li>记录请求通过的日志</li><li>作用域为 <code>http server location limit_except</code></li><li>日志格式默认为 <code>combined</code></li><li>日志格式是可以自定义的</li></ul><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义一个为 main 的日志格式</span></span><br><span class="line"><span class="attribute">log_format</span>  main  <span class="string">'<span class="variable">$remote_addr</span> - <span class="variable">$remote_user</span> [<span class="variable">$time_local</span>] "<span class="variable">$request</span>" '</span></span><br><span class="line">                      <span class="string">'<span class="variable">$status</span> <span class="variable">$body_bytes_sent</span> "<span class="variable">$http_referer</span>" '</span></span><br><span class="line">                      <span class="string">'"<span class="variable">$http_user_agent</span>" "<span class="variable">$http_x_forwarded_for</span>"'</span>;</span><br><span class="line">                      </span><br><span class="line"><span class="attribute">access_log</span>  logs/access.log  main;</span><br></pre></td></tr></table></figure><p>上方的 <code>log_format</code> 后面类似 <code>$remote_addr</code> 是nginx的内置变量，取值如下<br><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"><span class="meta-keyword">$remote</span>_addr, $http_x_forwarded_for（反向） 记录客户端IP地址</span></span><br><span class="line"><span class="meta"><span class="meta-keyword">$remote</span>_user 记录客户端用户名称</span></span><br><span class="line"><span class="meta"><span class="meta-keyword">$request</span> 记录请求的URL和HTTP协议</span></span><br><span class="line"><span class="meta"><span class="meta-keyword">$status</span> 记录请求状态</span></span><br><span class="line"><span class="meta"><span class="meta-keyword">$body</span>_bytes_sent 发送给客户端的字节数，不包括响应头的大小； 该变量与Apache模块mod_log_config里的“%B”参数兼容。</span></span><br><span class="line"><span class="meta"><span class="meta-keyword">$bytes</span>_sent 发送给客户端的总字节数。</span></span><br><span class="line"><span class="meta"><span class="meta-keyword">$connection</span> 连接的序列号。</span></span><br><span class="line"><span class="meta"><span class="meta-keyword">$connection</span>_requests 当前通过一个连接获得的请求数量。</span></span><br><span class="line"><span class="meta"><span class="meta-keyword">$msec</span> 日志写入时间。单位为秒，精度是毫秒。</span></span><br><span class="line"><span class="meta"><span class="meta-keyword">$pipe</span> 如果请求是通过HTTP流水线(pipelined)发送，pipe值为“p”，否则为“.”。</span></span><br><span class="line"><span class="meta"><span class="meta-keyword">$http</span>_referer 记录从哪个页面链接访问过来的</span></span><br><span class="line"><span class="meta"><span class="meta-keyword">$http</span>_user_agent 记录客户端浏览器相关信息</span></span><br><span class="line"><span class="meta"><span class="meta-keyword">$request</span>_length 请求的长度（包括请求行，请求头和请求正文）。</span></span><br><span class="line"><span class="meta"><span class="meta-keyword">$request</span>_time 请求处理时间，单位为秒，精度毫秒； 从读入客户端的第一个字节开始，直到把最后一个字符发送给客户端后进行日志写入为止。</span></span><br><span class="line"><span class="meta"><span class="meta-keyword">$time</span>_iso8601 ISO8601标准格式下的本地时间。</span></span><br><span class="line"><span class="meta"><span class="meta-keyword">$time</span>_local 通用日志格式下的本地时间。</span></span><br></pre></td></tr></table></figure></p><h2 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h2><h3 id="正向代理-反向代理"><a href="#正向代理-反向代理" class="headerlink" title="正向代理 反向代理"></a>正向代理 反向代理</h3><ul><li>正向代理大概的意思就是，客户端发送一个请求，这个请求包含服务器地址，那么代理服务器收到了请求后会将请求发送到客户端指定的服务器，并将响应内容传递给客户端，在这个过程中，客户端是知道请求的服务器地址的，但是服务器是不知道哪个客户端请求的。VPN做的就是这个事。</li><li>反向代理大概的意思就是，客户端发送一个请求给代理服务器，由代理服务器来决定这个请求该交给哪个服务器，这就是实现了服务器负载均衡，可以将请求转发到比较空闲的服务器来响应，这个时候，代理服务器就是相对于客户端的服务器，因为此时客户端也不知道请求交给了哪个服务器。</li></ul><p>我所理解的正向代理和反向代理就是这个意思，如有错误欢迎下方评论。</p><h3 id="proxy-pass"><a href="#proxy-pass" class="headerlink" title="proxy_pass"></a>proxy_pass</h3><p>那么nginx使用的就是<code>proxy_pass</code>属性来进行反向代理的处理，使用也是很简单。下面以nodejs开启一个建立在 localhost:4000 的服务</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"></span><br><span class="line">http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>)</span>&#123;</span><br><span class="line">    res.writeHead(<span class="number">200</span>, &#123;<span class="string">'Content-Type'</span>: <span class="string">'text/plain'</span>&#125;);</span><br><span class="line">    res.end(<span class="string">'server 4000'</span>);</span><br><span class="line">&#125;).listen(<span class="number">4000</span>);</span><br></pre></td></tr></table></figure><p>请求 <code>localhost:4000</code> 可以打开我们的页面</p><p><img src="http://static.zybuluo.com/shenweizheng/pdz5sg6oeac5ui35uf7oft28/image_1disp1dvl1fii1dhj1dlk1qrnbuj9.png" alt="image_1disp1dvl1fii1dhj1dlk1qrnbuj9.png-13.8kB"></p><p>那么我们需要做的是将 <code>localhost:5000</code>的所有请求都代理到4000这个server里，这样就会出现我们访问5000和访问4000一样的效果。具体配置如下</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">        <span class="comment"># 监听 localhost:5000</span></span><br><span class="line">        <span class="attribute">listen</span>     <span class="number">5000</span>;</span><br><span class="line">        <span class="attribute">server_name</span> localhost;</span><br><span class="line">        <span class="comment"># / 表示匹配所有的请求，所有的请求都会经过这个过滤器</span></span><br><span class="line">        <span class="attribute">location</span> / &#123;</span><br><span class="line">            <span class="comment"># 设定请求转发的地址</span></span><br><span class="line">        <span class="attribute">proxy_pass</span> http://localhost:4000;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这边需要注意的是 <code>proxy_pass</code> 的写法，必须是<code>http://</code>或者<code>https://</code>开头的，http头是不能省的。</p><p>请求5000端口效果如下：</p><p><img src="http://static.zybuluo.com/shenweizheng/ej0dbxfapbx9f29dhvknejxq/image_1dispgpetav110mb1tqkf718ufm.png" alt="image_1dispgpetav110mb1tqkf718ufm.png-15.9kB"></p><h3 id="本地代理至百度"><a href="#本地代理至百度" class="headerlink" title="本地代理至百度"></a>本地代理至百度</h3><p>上方的例子过于简单，那么这一个和上面的有点类似，这次是将4000的端口号代理到<code>www.baidu.com</code>。修改一下<code>proxy_pass</code></p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">        <span class="comment"># 监听 localhost:5000</span></span><br><span class="line">        <span class="attribute">listen</span>     <span class="number">5000</span>;</span><br><span class="line">        <span class="attribute">server_name</span> localhost;</span><br><span class="line">        <span class="comment"># / 表示匹配所有的请求，所有的请求都会经过这个过滤器</span></span><br><span class="line">        <span class="attribute">location</span> / &#123;</span><br><span class="line">            <span class="comment"># 设定请求转发的地址</span></span><br><span class="line">        <span class="attribute">proxy_pass</span> https://www.baidu.com;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就可以了，至于这边写的是<code>http</code> 还是 <code>https</code>，这个倒是不影响，因为百度内部会自动将<code>http</code>转成<code>https</code>毕竟安全嘛。</p><h3 id="百度代理至本地"><a href="#百度代理至本地" class="headerlink" title="百度代理至本地"></a>百度代理至本地</h3><p>那么按照刚刚的思路就是监听 <code>www.baidu.com</code> 然后设置一下 <code>proxy_pass</code> 为 <code>localhost:4000</code></p><p>配置如下</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span>     <span class="number">80</span>;</span><br><span class="line">        <span class="attribute">server_name</span> www.baidu.com;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">location</span> / &#123;</span><br><span class="line">        <span class="attribute">proxy_pass</span> http://localhost:4000;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>试一下，是不是没有用，没有用就对了。要是这么轻松的搞定<code>nginx</code>还玩个蛋。那么这个里面又有点操作了，先看正确的配置，修改本地的hosts文件，mac下的文件位置为 <code>/etc/hosts</code>但是需要 sudo 来进行修改，毕竟这个文件比较重要嘛</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim <span class="regexp">/etc/</span>hosts</span><br></pre></td></tr></table></figure><p>添加一句</p><p><img src="http://static.zybuluo.com/shenweizheng/guwjrur3gs80l7quyukxa71j/image_1div5kqsk1jpe7gg10jg18k01g.png" alt="image_1div5kqsk1jpe7gg10jg18k01g.png-4.1kB"></p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span>     <span class="number">80</span>;</span><br><span class="line">        <span class="attribute">server_name</span> baidu.com;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">location</span> / &#123;</span><br><span class="line">        <span class="attribute">proxy_pass</span> http://127.0.0.1:4000;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般在本地开发的时候我们都会修改本地的<code>hosts</code>文件，但是会遇到一个问题就是有的时候是有用的有的时候又没用了，我这边的解决办法是，每次修改完<code>hosts</code>文件就清楚浏览器的浏览数据，尤其是缓存这一块的东西。</p><p><img src="http://static.zybuluo.com/shenweizheng/fj2rw8j3zvjzt43tmmukwrf0/image_1div63u0e1s6j18fgtr11vhq101h1t.png" alt="image_1div63u0e1s6j18fgtr11vhq101h1t.png-105.2kB"></p><p>如果遇到nginx配置完全正确<code>hosts</code>文件也配置了，但是还是没有用，不妨清一下缓存，至少在我这是每次都是清完缓存才有用的。</p><h2 id="nginx跨域"><a href="#nginx跨域" class="headerlink" title="nginx跨域"></a>nginx跨域</h2><p>跨域的解决办法就是在<code>header</code>里面加上允许跨域的源等信息</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;  </span><br><span class="line">    add_header <span class="keyword">Access</span>-Control-Allow-Origin *;</span><br><span class="line">    add_header <span class="keyword">Access</span>-Control-Allow-Methods <span class="symbol">'GET</span>, POST, OPTIONS';</span><br><span class="line">    add_header <span class="keyword">Access</span>-Control-Allow-Headers <span class="symbol">'DNT</span>,X-Mx-ReqToken,Keep-Alive,User-Agent,X-Requested-<span class="keyword">With</span>,<span class="keyword">If</span>-Modified-Since,Cache-Control,Content-<span class="keyword">Type</span>,Authorization';</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ($request_method = <span class="symbol">'OPTIONS</span>') &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">204</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是在实际项目里。<code>origin</code>还是不要设置为<code>*</code>比较好，因为前端使用axios的话在获取session这一块会出现问题。</p><h2 id="nginx缓存"><a href="#nginx缓存" class="headerlink" title="nginx缓存"></a>nginx缓存</h2><blockquote><p>这边有一个需要注意的地方，nginx作为静态资源服务器的时候是不做缓存的，只有当nginx进行反向代理的时候才具备缓存这个功能。我一开始写了半天发现鸟用都没有，最后才发现只有做代理的时候才具备缓存。</p></blockquote><p>各大浏览器本身已经具有缓存了，比如说谷歌，我们可以写一个html，然后在html引入一张图片，我们可以看看浏览器是怎么对图片这些静态资源进行缓存的。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"./static/test.jpg"</span> <span class="attr">alt</span>=<span class="string">""</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这个html代码我使用<code>http-server</code>部署在了<code>http-server -a 127.0.0.1 -p 4000</code>可以看出是在<code>127.0.0.1 4000</code>端口。</p><p>这是首次加载的时候的状况</p><p><img src="http://static.zybuluo.com/shenweizheng/9q4w4k01dez4fpr3s5nfp96p/image_1div6rf381gma14094n10vib32q.png" alt="image_1div6rf381gma14094n10vib32q.png-31.3kB"></p><p>刷新一下</p><p><img src="http://static.zybuluo.com/shenweizheng/5rep6dzl2or6zjqe66yxy4xy/image_1div6slsb1niq1atp1oonksd1ubt37.png" alt="image_1div6slsb1niq1atp1oonksd1ubt37.png-28.4kB"></p><p>那么区别还是很大的</p><ul><li><code>html</code>文件的状态码从200到304，304状态码表明该文件是从缓存中读取</li><li><code>jpg</code>文件可以发现在<code>size</code>这一列，多了一个<code>memory cache</code>，这表明这个图片是从浏览器缓存中读取的</li><li>各个文件的加载事件明显减少，尤其是图片</li></ul><p>可能有的人会发现第一次加载的时候，显示的是<code>from desk cache</code>，那么chrome浏览器的缓存分为两种，一种是磁盘缓存一种是内存缓存，</p><p>官方文档：</p><blockquote><p>Chrome employs two caches — an on-disk cache and a very fast in-memory cache. The lifetime of an in-memory cache is attached to the lifetime of a render process, which roughly corresponds to a tab. Requests that are answered from the in-memory cache are invisible to the web request API. If a request handler changes its behavior (for example, the behavior according to which requests are blocked), a simple page refresh might not respect this changed behavior. To make sure the behavior change goes through, call handlerBehaviorChanged() to flush the in-memory cache. But don’t do it often; flushing the cache is a very expensive operation. You don’t need to call handlerBehaviorChanged() after registering or unregistering an event listener.</p></blockquote><p>大概意思就是：chrome有两种缓存，一种是<code>desk cache</code>一种是<code>memory cache</code>，然后<code>memory cache</code>的效率高于前者。</p><p>那么打开chrome devtools点开图片可以发现</p><p><img src="http://static.zybuluo.com/shenweizheng/q9u7y601st5mogf7kuh24cfv/image_1div7hhk3no5hfq1jft2j41t43k.png" alt="image_1div7hhk3no5hfq1jft2j41t43k.png-39.4kB"></p><p>在<code>cache-control</code>后面有一个<code>max-age</code>，那么具体的有关缓存的技术这边就不说了我回头整理一下</p><p>那么针对不同类型的文件进行缓存还是很简单的，需要注意的在于<code>location</code>的正则匹配</p><p>那么第一种最简单的缓存，就是直接设置<code>expires 缓存时间</code></p><h3 id="设置expires"><a href="#设置expires" class="headerlink" title="设置expires"></a>设置<code>expires</code></h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span> <span class="regexp">~ .*\.(jpg|png)$</span> &#123;</span><br><span class="line"><span class="attribute">proxy_pass</span> http://127.0.0.1:4000;</span><br><span class="line">    <span class="attribute">expires</span> <span class="number">3m</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://static.zybuluo.com/shenweizheng/rfve3ikhd0makef97uluzfdm/image_1div8c7nk1jv05ds1tvo1a7n1bm841.png" alt="image_1div8c7nk1jv05ds1tvo1a7n1bm841.png-44.2kB"></p><p><code>expires</code>是以秒为单位的，那么我们设置为<code>3m</code> 也就是180秒，发现确实是可以的。</p><h3 id="proxy-cache-path-的使用"><a href="#proxy-cache-path-的使用" class="headerlink" title="proxy_cache_path 的使用"></a>proxy_cache_path 的使用</h3><p>那么我们也可以指定我们的nginx缓存目录，通过proxy_cache_path 属性</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">proxy_cache_path</span> /tmp/cache/test levels=<span class="number">1</span>:<span class="number">2</span> keys_zone=my_cache:<span class="number">10m</span> max_size=<span class="number">10g</span> inactive=<span class="number">60m</span> use_temp_path=<span class="literal">off</span>;</span><br><span class="line"><span class="attribute">location</span> <span class="regexp">~ .*\.(jpg|png)$</span> &#123;</span><br><span class="line"> <span class="attribute">proxy_pass</span> http://127.0.0.1:4000;</span><br><span class="line"> <span class="attribute">proxy_cache</span> my_cache;</span><br><span class="line"> <span class="attribute">proxy_cache_valid</span> <span class="number">200</span> <span class="number">304</span> <span class="number">1y</span>;</span><br><span class="line"> <span class="attribute">proxy_cache_valid</span> any <span class="number">1m</span>;</span><br><span class="line"> <span class="attribute">expires</span> <span class="number">1y</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>proxy_cache_path 执行缓存文件的目录，如果没有的话需要提前创建，不然nginx会报错</li><li>levels 采用2级目录来存储</li><li>key_zone 在共享内存中设置一块存储区域来存放缓存的key和metadata（类似使用次数），这样nginx可以快速判断一个request是否命中或者未命中缓存，1m可以存储8000个key，10m可以存储80000个key</li><li>max_size 最大cache空间，如果不指定，会使用掉所有disk space，当达到配额后，会删除最少使用的cache文件</li><li>inactive 未被访问文件在缓存中保留时间，在指定时间内未被访问的文件会被删除</li><li>use_temp_path 如果为off，则nginx会将缓存文件直接写入指定的cache文件中，而不是使用temp_path存储，official建议为off，避免文件在不同文件系统中不必要的拷贝；</li><li>proxy_cache 启用proxy cache，对应着配置的key_zone;</li><li>proxy_cache_valid 根据不同的状态码设置不同的缓存时间</li></ul><p>可以查看一下<code>nginx</code>进程，会发现这个时候是有缓存的进程在开着的。</p><p><img src="http://static.zybuluo.com/shenweizheng/stieixi5zmk6iemyo0h7gjzt/image_1div91gppe5h1n0gh751eqv13u54e.png" alt="image_1div91gppe5h1n0gh751eqv13u54e.png-75.1kB"></p><p>这边可以看到，我们的图片的缓存时间已经被设置为1年</p><p><img src="http://static.zybuluo.com/shenweizheng/k8jfc8inqt864uvifo3qe98e/image_1div9h7o75lk4vgdqv1iidk5v4r.png" alt="image_1div9h7o75lk4vgdqv1iidk5v4r.png-45.4kB"></p><h3 id="location匹配优先级"><a href="#location匹配优先级" class="headerlink" title="location匹配优先级"></a>location匹配优先级</h3><p>在缓存中需要注意的一点就是location的匹配规则和优先级</p><ul><li>= 开头表示精确匹配</li><li>^~ 开头表示uri以某个常规字符串开头，不是正则匹配;</li><li>~ 开头表示区分大小写的正则匹配;</li><li>~* 开头表示不区分大小写的正则匹配;</li><li>/ 通用匹配, 如果没有其它匹配,任何请求都会匹配到;</li></ul><h2 id="upstream负载均衡"><a href="#upstream负载均衡" class="headerlink" title="upstream负载均衡"></a>upstream负载均衡</h2><p>负载均衡是nginx的另一大特点，可以配置多个服务器，将请求分发到最合适的那台服务器，避免某一台服务器请求太多而崩溃。使用<code>upstream</code>属性来配置</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">upstream</span> favtomcat &#123;</span><br><span class="line">       <span class="attribute">server</span> <span class="number">192.168.1.100:4000</span>;</span><br><span class="line">       <span class="attribute">server</span> <span class="number">192.168.1.111:5000</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="attribute">location</span> / &#123;</span><br><span class="line">            <span class="attribute">root</span>   html;</span><br><span class="line">            <span class="attribute">index</span>  index.html index.htm;</span><br><span class="line">            <span class="comment"># 对应上方的 favtomcat</span></span><br><span class="line">            <span class="attribute">proxy_pass</span> http://favtomcat;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是最基础的负载均衡配置，采用的是<code>轮询</code>的策略进行负载，每个请求按时间顺序逐一分配到不同的后端服务器，适用于图片服务器集群和纯静态页面服务器集群。<br>优点： 方式简便、成本低廉<br>缺点： 可靠性低和负载分配不均衡</p><p>那么<code>upstream</code>还有其他的负载策略</p><h3 id="weight权重"><a href="#weight权重" class="headerlink" title="weight权重"></a>weight权重</h3><p>可以给每一台服务器设置一个权重，这样权重高的干的活也就会多一点</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">upstream favtomcat &#123;</span><br><span class="line">      <span class="built_in"> server </span>192.168.1.100:4000 <span class="attribute">weight</span>=5;</span><br><span class="line">      <span class="built_in"> server </span>192.168.1.111:5000 <span class="attribute">weight</span>=10;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ip-hash"><a href="#ip-hash" class="headerlink" title="ip_hash"></a>ip_hash</h3><p>这种方式是基于客户端的ip地址，采用hash算法计算下一个请求要选择哪一个服务器，这样固定的ip会访问同一个服务器，可以解决session问题</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">upstream favtomcat &#123;</span><br><span class="line">       ip_hash;</span><br><span class="line">      <span class="built_in"> server </span>192.168.1.100:4000;</span><br><span class="line">      <span class="built_in"> server </span>192.168.1.111:5000;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="least-conn最少链接"><a href="#least-conn最少链接" class="headerlink" title="least_conn最少链接"></a>least_conn最少链接</h3><p>会将下一个请求分发到当前链接数最少的一台服务器<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">upstream favtomcat &#123;</span><br><span class="line">       least_conn;</span><br><span class="line">      <span class="built_in"> server </span>192.168.1.100:4000;</span><br><span class="line">      <span class="built_in"> server </span>192.168.1.111:5000;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="fair"><a href="#fair" class="headerlink" title="fair"></a>fair</h3><p>按后端服务器的响应时间来分配请求，响应时间短的优先分配。<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">upstream favtomcat &#123;</span><br><span class="line">       fair;</span><br><span class="line">      <span class="built_in"> server </span>192.168.1.100:4000;</span><br><span class="line">      <span class="built_in"> server </span>192.168.1.111:5000;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="url-hash"><a href="#url-hash" class="headerlink" title="url_hash"></a>url_hash</h3><p>按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">upstream backserver &#123; </span><br><span class="line">   <span class="built_in"> server </span>squid1:3128; </span><br><span class="line">   <span class="built_in"> server </span>squid2:3128; </span><br><span class="line">    hash <span class="variable">$request_uri</span>; </span><br><span class="line">    hash_method crc32; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>参考<br><a href="https://juejin.im/post/59f94f626fb9a045023af34c；" target="_blank" rel="noopener">https://juejin.im/post/59f94f626fb9a045023af34c；</a><br><a href="https://www.jianshu.com/p/625c2b15dad5" target="_blank" rel="noopener">Nginx Proxy Cache原理和最佳实践</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;nginx经常挂在嘴边的就是反向代理，不过他还可以干很多事，我所了解的只是反向代理、静态文件缓存、静态资源服务器，对于负载均衡只是略有涉及。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Nginx (“engine x”) 是一个高性能的 HTTP 和 反向代理 服务器 ，也是一个 IMAP/POP3/SMTP 代理 服务器 。 Nginx 是由 Igor Sysoev 为俄罗斯访问量第二的 Rambler.ru 站点开发的，第一个公开版本0.1.0发布于2004年10月4日。其将源代码以类BSD许可证的形式发布，因它的稳定性、丰富的功能集、示例配置文件和低系统资源的消耗而闻名&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;引用一下菜鸟教程的简介：Nginx功能丰富，可作为HTTP服务器，也可作为反向代理服务器，邮件服务器。支持FastCGI、SSL、Virtual Host、URL Rewrite、Gzip等功能。并且支持很多第三方的模块扩展。Nginx的稳定性、功能集、示例配置文件和低系统资源的消耗让他后来居上，在全球活跃的网站中有12.18%的使用比率，大约为2220万个网站。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;特点&lt;br&gt;(1)：代理服务器，快速高效反向代理，提升网站性能。&lt;br&gt;(2)：负载均衡器，内部支持Rails和PHP,也可支持HTTP代理服务器，对外进行服务。同时支持简单容错和利用算法进行负载均衡。&lt;br&gt;(3)：性能方面，Nginx专门为性能设计，实现注重效率。采用Poll模型，可以支持更多的并发连接，并在大并发时占用很低内存。&lt;br&gt;(4)：稳定性方面，采用分阶段资源分配技术，使CPU资源占用率低。&lt;br&gt;(5)：高可用性方面，支持热备，启动迅速。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="nginx" scheme="http://shenweini.cn/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>node.js Express框架中使用websoecket 包含 ts 和 非 ts 环境</title>
    <link href="http://shenweini.cn/2019/08/19/node.js%20Express%E6%A1%86%E6%9E%B6%E4%B8%AD%E4%BD%BF%E7%94%A8websoecket%20%E5%8C%85%E5%90%AB%20ts%20%E5%92%8C%20%E9%9D%9E%20ts%20%E7%8E%AF%E5%A2%83/"/>
    <id>http://shenweini.cn/2019/08/19/node.js Express框架中使用websoecket 包含 ts 和 非 ts 环境/</id>
    <published>2019-08-19T13:32:00.741Z</published>
    <updated>2019-08-19T13:32:00.741Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>websocket是啥我就简单的说一下，这个大家知道的应该挺多的。那么首先它是一个协议，类似于我们的HTTP协议，但是不同的是HTTP协议是客户端向服务器端请求，然后服务器端响应并且只能响应一次，但是无法做到服务器端主动向浏览器端推送数据。那么websocket主要就是解决服务器端无法向客户端主动推送数据的。当我们需要保持一种长链接时，我们就需要用到websocket<br>使用场景如下：浏览器发起请求，这个请求会经历大量的计算，并且返回给浏览器当前计算到了哪一步，这个时候浏览器就可以展示一个弹窗告诉用户当前已经到了哪一步，适当的更可以展示一个进度条，避免用户因为请求时间太长看久了loading也会腻不是。<br>它的主要特点就是，服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话<br>特点包括：<br>（1）建立在 TCP 协议之上，服务器端的实现比较容易。<br>（2）与 HTTP 协议有着良好的兼容性。默认端口也是80和443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。<br>（3）数据格式比较轻量，性能开销小，通信高效。<br>（4）可以发送文本，也可以发送二进制数据。<br>（5）没有同源限制，客户端可以与任意服务器通信。<br>（6）协议标识符是ws（如果加密，则为wss），服务器网址就是 URL。</p></blockquote><a id="more"></a><h2 id="服务器端"><a href="#服务器端" class="headerlink" title="服务器端"></a>服务器端</h2><p>这边是用node.js 的express框架进行操作,使用<code>express-ws</code>插件</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm <span class="selector-tag">i</span> -S express-ws</span><br></pre></td></tr></table></figure><h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><p>使用express-ws插件对app进行操作，对于不是ts环境下的通过</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> express <span class="keyword">from</span> <span class="string">'express'</span>;</span><br><span class="line"><span class="keyword">import</span> expressWs <span class="keyword">from</span> <span class="string">'express-ws'</span>;</span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line">app = expressWs(app);</span><br></pre></td></tr></table></figure><p>对于 ts 环境下的操作<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> express <span class="keyword">from</span> <span class="string">'express'</span>;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> expressWs <span class="keyword">from</span> <span class="string">'express-ws'</span>;</span><br><span class="line"><span class="keyword">const</span> appBase = express();</span><br><span class="line"><span class="comment">// 引入 websocket</span></span><br><span class="line"><span class="keyword">let</span> wsInstance = expressWs(appBase);</span><br><span class="line"><span class="keyword">let</span> &#123; app &#125; = wsInstance;</span><br></pre></td></tr></table></figure></p><p>获取到实例之后，可以通过app.ws进行操作了</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">//</span> 设置websocket</span><br><span class="line">app.ws(<span class="string">'/autoSchedule'</span>, <span class="function"><span class="params">(ws, req)</span> =&gt;</span> &#123;</span><br><span class="line">    ws.send(<span class="string">'已连接'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>之前看到有说可以通过router进行使用ws，因为router相当于一个mini 的app实例，但是我在ts环境下试了很多次都没有成功,比如说一下代码<br><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> expres <span class="keyword">from</span> <span class="string">'express'</span>;</span><br><span class="line"><span class="keyword">import</span> expressWs <span class="keyword">from</span> <span class="string">'express-ws'</span>;</span><br><span class="line">const router = expressWs(express().Router());</span><br><span class="line">router.ws(<span class="string">'/autoSchedule'</span>, <span class="function"><span class="params">(ws, req)</span> =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>这种方式也是需要app做<code>expressWS(app)</code>操作的。但是在ts下我没有试成功过，一直包的是router没有ws方法，或者是<code>expressWs(express().Router())</code>操作时说router不是一个app实例。总之很神奇。那么我采用的方法是，将我的业务代码封装成一个大的函数然后通过模块导出，在app.ts文件下引用使用，这个操作的关键在于需要将<code>app.ws(&#39;/autoSchedule&#39;,(ws: any, req: any))</code>回调函数中的ws传递给该函数，已达到模块划分的目的.</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// app.ts</span></span><br><span class="line"><span class="comment">// 引入封装好的函数模块</span></span><br><span class="line"><span class="keyword">import</span> scheduleWs <span class="keyword">from</span> <span class="string">'./src/util/autoSchedule'</span>;</span><br><span class="line"><span class="comment">// 设置websocket</span></span><br><span class="line">app.ws(<span class="string">'/autoSchedule'</span>, <span class="function">(<span class="params">ws: <span class="built_in">any</span>, req: <span class="built_in">any</span></span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 将 ws 传递给函数</span></span><br><span class="line">    scheduleWs(ws);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">util/autoSchedule.ts</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> (ws: any) =&gt; &#123;</span><br><span class="line">    ws.send(<span class="string">'开始调用'</span>);</span><br><span class="line">    <span class="comment">// 业务代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a>特别说明</h2><p>websocket在执行<code>send</code>方法，发送信息的时候，<code>send</code>函数的参数只支持字符串、二进制数据。所以我一般会将所需要的数据转成 JSON字符串，然后在前端在解析，例如</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 服务器端</span></span><br><span class="line"><span class="selector-tag">ws</span><span class="selector-class">.send</span>(JSON.stringify(&#123;</span><br><span class="line">    <span class="attribute">code</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attribute">msg</span>: <span class="string">'开始调度'</span></span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 客户端</span></span><br><span class="line">ws.onmessage = <span class="function">(<span class="params">e: <span class="built_in">any</span></span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> res: <span class="built_in">any</span> = <span class="built_in">JSON</span>.parse(e.data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行完全部任务时，记得关闭socket连接<br><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ws.close()<span class="comment">;</span></span><br></pre></td></tr></table></figure></p><h2 id="客户端的API"><a href="#客户端的API" class="headerlink" title="客户端的API"></a>客户端的API</h2><h3 id="websocket实例化"><a href="#websocket实例化" class="headerlink" title="websocket实例化"></a>websocket实例化</h3><p>websocket协议的接口地址是以 ws 开头</p><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ws = <span class="keyword">new</span> WebSocket(<span class="string">'ws://localhost:3000/autoSchedule'</span>);</span><br></pre></td></tr></table></figure><h3 id="websocket-的状态"><a href="#websocket-的状态" class="headerlink" title="websocket 的状态"></a>websocket 的状态</h3><ul><li>CONNECTING：值为0，表示正在连接</li><li>OPEN：值为1，表示连接成功，可以通信了</li><li>CLOSING：值为2，表示连接正在关闭</li><li>CLOSED：值为3，表示连接已经关闭，或者打开连接失败</li></ul><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (ws.readyState) &#123;</span><br><span class="line">  <span class="keyword">case</span> WebSocket.<span class="string">CONNECTING:</span></span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> WebSocket.<span class="string">OPEN:</span></span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> WebSocket.<span class="string">CLOSING:</span></span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> WebSocket.<span class="string">CLOSED:</span></span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"><span class="symbol">  default:</span></span><br><span class="line">    <span class="comment">// this never happens</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="websocket-open"><a href="#websocket-open" class="headerlink" title="websocket.open"></a>websocket.open</h3><p>监听连接开启</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ws.onopen = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'已连接'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="websocket-close"><a href="#websocket-close" class="headerlink" title="websocket.close"></a>websocket.close</h3><p>监听连接关闭<br><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ws.onclose = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'已关闭'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="websocket-onerror"><a href="#websocket-onerror" class="headerlink" title="websocket.onerror"></a>websocket.onerror</h3><p>监听连接发生错误</p><figure class="highlight moonscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ws.onerror = <span class="function"><span class="params">(<span class="built_in">error</span>: any)</span> =&gt;</span> &#123;</span><br><span class="line">    console.log(<span class="built_in">error</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="websocket-onmessage"><a href="#websocket-onmessage" class="headerlink" title="websocket.onmessage"></a>websocket.onmessage</h3><p>监听服务器端发来的消息</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ws.onmessage = <span class="function"><span class="params">(e)</span> =&gt;</span> &#123;</span><br><span class="line">    let res = e.data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="websocket-sned"><a href="#websocket-sned" class="headerlink" title="websocket.sned"></a>websocket.sned</h3><p>向服务器端发送消息</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ws.<span class="built_in">send</span>(<span class="string">'hello world'</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;websocket是啥我就简单的说一下，这个大家知道的应该挺多的。那么首先它是一个协议，类似于我们的HTTP协议，但是不同的是HTTP协议是客户端向服务器端请求，然后服务器端响应并且只能响应一次，但是无法做到服务器端主动向浏览器端推送数据。那么websocket主要就是解决服务器端无法向客户端主动推送数据的。当我们需要保持一种长链接时，我们就需要用到websocket&lt;br&gt;使用场景如下：浏览器发起请求，这个请求会经历大量的计算，并且返回给浏览器当前计算到了哪一步，这个时候浏览器就可以展示一个弹窗告诉用户当前已经到了哪一步，适当的更可以展示一个进度条，避免用户因为请求时间太长看久了loading也会腻不是。&lt;br&gt;它的主要特点就是，服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话&lt;br&gt;特点包括：&lt;br&gt;（1）建立在 TCP 协议之上，服务器端的实现比较容易。&lt;br&gt;（2）与 HTTP 协议有着良好的兼容性。默认端口也是80和443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。&lt;br&gt;（3）数据格式比较轻量，性能开销小，通信高效。&lt;br&gt;（4）可以发送文本，也可以发送二进制数据。&lt;br&gt;（5）没有同源限制，客户端可以与任意服务器通信。&lt;br&gt;（6）协议标识符是ws（如果加密，则为wss），服务器网址就是 URL。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="node.js" scheme="http://shenweini.cn/tags/node-js/"/>
    
      <category term="express" scheme="http://shenweini.cn/tags/express/"/>
    
  </entry>
  
  <entry>
    <title>Axios二次封装</title>
    <link href="http://shenweini.cn/2019/08/19/Axios%E4%BA%8C%E6%AC%A1%E5%B0%81%E8%A3%85/"/>
    <id>http://shenweini.cn/2019/08/19/Axios二次封装/</id>
    <published>2019-08-19T12:44:00.172Z</published>
    <updated>2019-08-19T12:44:00.173Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>axios是一个基于Promise的http库，可以用在浏览器和node.js中。同时也是对原生浏览器请求XMLHttpRequest的封装，支持Promise的APi请求，避免了回掉地狱问题，可以对请求进行拦截，在发出请求前对请求参数进行修改，接受服务器响应时，也可以根据返回的code进行统一的处理，且客户端支持防御XSRF。可以开箱即用，但是在实际项目时，需要对axios进行二次封装</p></blockquote><a id="more"></a><h2 id="实例-Or-defaults"><a href="#实例-Or-defaults" class="headerlink" title="实例 Or defaults"></a>实例 Or defaults</h2><p>对 axios 进行二次封装由两种方式，一种是创建一个axios实例，另外一种是直接修改axios的defaults</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import axios from 'axios';</span><br><span class="line">var<span class="built_in"> instance </span>= axios.create(&#123;</span><br><span class="line">  baseURL: 'https://some-domain.com/api/',</span><br><span class="line">  timeout: 1000,</span><br><span class="line">  headers: &#123;'X-Custom-Header': 'foobar'&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">'axios'</span>;</span><br><span class="line">axios.defaults.baseURL = SERVICE;</span><br></pre></td></tr></table></figure><p>当然在使用第一种创建一个实例时，也可以设置这个实例的defaults，就像这样<br><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import axios from 'axios';</span><br><span class="line">var<span class="built_in"> instance </span>= axios.create(&#123;</span><br><span class="line">  baseURL: 'https://some-domain.com/api/',</span><br><span class="line">  timeout: 1000,</span><br><span class="line">  headers: &#123;'X-Custom-Header': 'foobar'&#125;</span><br><span class="line">&#125;);</span><br><span class="line">instance.defaults.baseUR<span class="class">L = SERVICE;</span></span><br></pre></td></tr></table></figure></p><h2 id="设置baseURL"><a href="#设置baseURL" class="headerlink" title="设置baseURL"></a>设置baseURL</h2><p>在前后端分离项目，往往需要定义一个全局变量来声明后台的接口地址，一般我会选择通过 webpack 的 definePlugin 插件来给页面设置全局变量，并且根据不同的环境传递不同的值。比如说后台的接口部署在了 <a href="http://localhost:3000" target="_blank" rel="noopener">http://localhost:3000</a><br>那么首先使用 webpack 定义一个叫 SERVICE 的全局变量</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">new</span> <span class="selector-tag">webpack</span><span class="selector-class">.DefinePlugin</span>(&#123;</span><br><span class="line">    <span class="attribute">SERVICE</span>: <span class="string">"'http://localhost:3000'"</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>然后就可以在页面中使用这个全局变量，当然如果是在ts项目下的话，直接使用SERVICE会抱一个未定义的错，那么只需要在使用SERVICE的文件中申明一下即可，未使用ts 的可以跳过这句声明。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">'axios'</span>;</span><br><span class="line"><span class="comment">// ts 下使用 需要先声明</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">const</span> SERVICE: <span class="built_in">string</span>;</span><br><span class="line">axios.defaults.baseURL = SERVICE;</span><br></pre></td></tr></table></figure><h2 id="设置Content-type"><a href="#设置Content-type" class="headerlink" title="设置Content-type"></a>设置Content-type</h2><p>在 post 请求和 put 请求中，需要在请求头里设置一下content-type 为 application/x-www-form-urlencoded</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">axios.defaults.headers.post[<span class="symbol">'Content</span>-<span class="keyword">Type</span>'] = <span class="symbol">'application</span>/x-www-form-urlencoded';</span><br><span class="line">axios.defaults.headers.put[<span class="symbol">'Content</span>-<span class="keyword">Type</span>'] = <span class="symbol">'application</span>/x-www-form-urlencoded';</span><br></pre></td></tr></table></figure><h2 id="设置withCredentials"><a href="#设置withCredentials" class="headerlink" title="设置withCredentials"></a>设置withCredentials</h2><p>axios发起请求时，默认是不会携带cookie的，这就导致了在前后端分离项目中，做一个登录的页面，登录完之后跳转主页面，但是主页面中请求的接口未检测到用户已登录那么就会跳回登录页面，大概时这样的场景。那么缘由就是因为axios在发起请求时是不会携带cookie的，通过设置withCredentials为true 来解决</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">axios.defaults.<span class="attr">withCredentials</span> = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><h2 id="请求拦截-request处理"><a href="#请求拦截-request处理" class="headerlink" title="请求拦截 request处理"></a>请求拦截 request处理</h2><p>可以通过对请求的拦截，修改参数，对参数进行序列化处理，防止XSRF攻击。序列化使用 <code>qs</code>来实现，<code>qs</code>的优点是可以对深层次的json array 等复杂类型进行序列化。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">axios.interceptors.request.use((config: <span class="built_in">any</span>): <span class="function"><span class="params">any</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 给请求添加请求时间</span></span><br><span class="line">    <span class="keyword">if</span> (config.url.indexOf(<span class="string">'?'</span>) !== <span class="number">-1</span>) &#123;</span><br><span class="line">        config.url += <span class="string">`&amp;t=<span class="subst">$&#123;new Date().getTime()&#125;</span>`</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        config.url += <span class="string">`?t=<span class="subst">$&#123;new Date().getTime()&#125;</span>`</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// `transformRequest` 允许在向服务器发送前，修改请求数据</span></span><br><span class="line">    <span class="comment">// 只能用在 'PUT', 'POST' 和 'PATCH' 这几个请求方法</span></span><br><span class="line">    <span class="comment">// 后面数组中的函数必须返回一个字符串，或 ArrayBuffer，或 Stream</span></span><br><span class="line">    config.transformRequest = [<span class="function">(<span class="params">data: <span class="built_in">any</span>, headers: <span class="built_in">any</span></span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> qs.stringify(data, &#123;</span><br><span class="line">            allowDots: <span class="literal">true</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;];</span><br><span class="line">    <span class="comment">// `paramsSerializer` 是一个负责 `params` 序列化的函数</span></span><br><span class="line">    config.paramsSerializer = <span class="function">(<span class="params">params: <span class="built_in">any</span></span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> qs.stringify(params, &#123;</span><br><span class="line">            arrayFormat: <span class="string">'repeat'</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> config;</span><br><span class="line">&#125;, <span class="function">(<span class="params">error: <span class="built_in">any</span></span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="对response进行处理"><a href="#对response进行处理" class="headerlink" title="对response进行处理"></a>对response进行处理</h2><p>有这么一个场景，当接口返回的code为2时，表明用户未登录，这时需要前端对请求的response返回的code进行判断，那么一个请求一个请求的判断肯定是会很麻烦的，哪个请求忘了加判断就完蛋了，所以axios提供了对响应进行拦截的操作。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">axios.interceptors.response.use((response: <span class="built_in">any</span>): <span class="function"><span class="params">any</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; data &#125; = response;</span><br><span class="line">    <span class="keyword">if</span>(data.code === <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="built_in">window</span>.location.href = <span class="string">`/login?from=<span class="subst">$&#123;window.location.pathname&#125;</span>`</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">&#125;, <span class="function">(<span class="params">error: <span class="built_in">any</span></span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">Promise</span>.reject(error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="axios常规操作"><a href="#axios常规操作" class="headerlink" title="axios常规操作"></a>axios常规操作</h2><h3 id="GET请求"><a href="#GET请求" class="headerlink" title="GET请求"></a>GET请求</h3><p>get请求,对于需要参数的get请求，请一定要将参数放在 params 里，不然你会吃亏的。使用场景如下，获取一个邮件的id，mailId是一个非常长的一串各种字符组成的，恰巧这里面包含了一些 . 或者 \ 或者 : 啥的，具体的我也不知道，最后导致的原因是这个邮箱的mailID穿不到后台，因为这个参数直接放在路由后面是有问题的，所以请直接讲参数放在params里，因为上面已经对params里的参数进行了处理。<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">axios</span><span class="selector-class">.get</span>(<span class="string">'/api/info'</span>,&#123;</span><br><span class="line">    <span class="attribute">params</span>: &#123;</span><br><span class="line">        <span class="attribute">id</span>: <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)<span class="selector-class">.then</span>(res =&gt; &#123;</span><br><span class="line"></span><br><span class="line">&#125;)<span class="selector-class">.catch</span>(err =&gt; &#123;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h3 id="POST请求"><a href="#POST请求" class="headerlink" title="POST请求"></a>POST请求</h3><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">axios</span><span class="selector-class">.post</span>(<span class="string">'/api/info'</span>,&#123;</span><br><span class="line">    <span class="attribute">username</span>: <span class="string">'haha'</span>,</span><br><span class="line">    <span class="attribute">password</span>: <span class="string">'123456'</span></span><br><span class="line">&#125;)<span class="selector-class">.then</span>(res =&gt; &#123;</span><br><span class="line"></span><br><span class="line">&#125;)<span class="selector-class">.catch</span>(err =&gt; &#123;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>delete 请求类似于get请求 put请求类似于post请求</p></blockquote><h3 id="链式调用"><a href="#链式调用" class="headerlink" title="链式调用"></a>链式调用</h3><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">axios</span><span class="selector-class">.get</span>(<span class="string">'/api/info'</span>,&#123;</span><br><span class="line">    <span class="attribute">params</span>: &#123;</span><br><span class="line">        <span class="attribute">id</span>: <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)<span class="selector-class">.then</span>(res =&gt; &#123;</span><br><span class="line">    <span class="selector-tag">return</span> <span class="selector-tag">axios</span><span class="selector-class">.post</span>(<span class="string">'/api/info'</span>,&#123;</span><br><span class="line">        <span class="attribute">username</span>: <span class="string">'haha'</span>,</span><br><span class="line">        <span class="attribute">password</span>: <span class="string">'123456'</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;)<span class="selector-class">.then</span>(res =&gt; &#123;</span><br><span class="line"></span><br><span class="line">&#125;)<span class="selector-class">.catch</span>(err =&gt; &#123;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="axios-all"><a href="#axios-all" class="headerlink" title="axios.all"></a>axios.all</h3><p>与 <code>Promise.all</code> 类似，用于多个请求并罚处理，等待请求全部完成时执行回调，并且回调参数为一个数组，数组里的顺序与请求的顺序是一致的，也就是说他是按顺序将返回值存进去的</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">axios</span><span class="selector-class">.all</span>([</span><br><span class="line">    axios.get(<span class="string">'/api/info'</span>,&#123;</span><br><span class="line">        <span class="attribute">params</span>: &#123;</span><br><span class="line">            <span class="attribute">id</span>: <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;),</span><br><span class="line">    axios.post(<span class="string">'/api/info'</span>,&#123;</span><br><span class="line">        <span class="attribute">username</span>: <span class="string">'haha'</span>,</span><br><span class="line">        <span class="attribute">password</span>: <span class="string">'123456'</span></span><br><span class="line">    &#125;);</span><br><span class="line">])<span class="selector-class">.then</span>(resArray =&gt; &#123;</span><br><span class="line">    <span class="comment">// resArray[0] 为axios.get('/api/info') 的res</span></span><br><span class="line">    <span class="comment">// resArray[1] 为axios.post('/api/info') 的res</span></span><br><span class="line">&#125;)<span class="selector-class">.catch</span>(err =&gt; &#123;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="完整代码-模块化开发"><a href="#完整代码-模块化开发" class="headerlink" title="完整代码-模块化开发"></a>完整代码-模块化开发</h2><p>封装完了之后将axios导出，其他的页面直接引用该axios就行。完整代码如下</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// request.js</span></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">'axios'</span>;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> qs <span class="keyword">from</span> <span class="string">'qs'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">const</span> SERVICE: <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line">axios.defaults.baseURL = SERVICE;</span><br><span class="line">axios.defaults.withCredentials = <span class="literal">true</span>;</span><br><span class="line">axios.defaults.headers.post[<span class="string">'Content-Type'</span>] = <span class="string">'application/x-www-form-urlencoded'</span>;</span><br><span class="line">axios.defaults.headers.put[<span class="string">'Content-Type'</span>] = <span class="string">'application/x-www-form-urlencoded'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// qs 序列化 防止XSRF攻击 可以对深层次的json array进行序列化</span></span><br><span class="line">axios.interceptors.request.use((config: <span class="built_in">any</span>): <span class="function"><span class="params">any</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (config.url.indexOf(<span class="string">'?'</span>) !== <span class="number">-1</span>) &#123;</span><br><span class="line">        config.url += <span class="string">`&amp;t=<span class="subst">$&#123;new Date().getTime()&#125;</span>`</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        config.url += <span class="string">`?t=<span class="subst">$&#123;new Date().getTime()&#125;</span>`</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// `transformRequest` 允许在向服务器发送前，修改请求数据</span></span><br><span class="line">    <span class="comment">// 只能用在 'PUT', 'POST' 和 'PATCH' 这几个请求方法</span></span><br><span class="line">    <span class="comment">// 后面数组中的函数必须返回一个字符串，或 ArrayBuffer，或 Stream</span></span><br><span class="line">    config.transformRequest = [<span class="function">(<span class="params">data: <span class="built_in">any</span>, headers: <span class="built_in">any</span></span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> qs.stringify(data, &#123;</span><br><span class="line">            allowDots: <span class="literal">true</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;];</span><br><span class="line">    <span class="comment">// `paramsSerializer` 是一个负责 `params` 序列化的函数</span></span><br><span class="line">    config.paramsSerializer = <span class="function">(<span class="params">params: <span class="built_in">any</span></span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> qs.stringify(params, &#123;</span><br><span class="line">            arrayFormat: <span class="string">'repeat'</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> config;</span><br><span class="line">&#125;, <span class="function">(<span class="params">error: <span class="built_in">any</span></span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">axios.interceptors.response.use((response: <span class="built_in">any</span>): <span class="function"><span class="params">any</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; data &#125; = response;</span><br><span class="line">    <span class="keyword">if</span>(data.code === <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="built_in">window</span>.location.href = <span class="string">`/login?from=<span class="subst">$&#123;window.location.pathname&#125;</span>`</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">&#125;, <span class="function">(<span class="params">error: <span class="built_in">any</span></span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">Promise</span>.reject(error);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> axios;</span><br></pre></td></tr></table></figure><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// action.js</span></span><br><span class="line"><span class="keyword">import</span> axios from <span class="string">'./request'</span>;</span><br><span class="line">axios.<span class="keyword">get</span>(<span class="string">''</span>)</span><br><span class="line">    .then(res = &gt; &#123;</span><br><span class="line">        <span class="comment">// 业务代码</span></span><br><span class="line">    &#125;)</span><br><span class="line">    .<span class="keyword">catch</span>(err =&gt; &#123;</span><br><span class="line">        <span class="comment">// 业务代码</span></span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;axios是一个基于Promise的http库，可以用在浏览器和node.js中。同时也是对原生浏览器请求XMLHttpRequest的封装，支持Promise的APi请求，避免了回掉地狱问题，可以对请求进行拦截，在发出请求前对请求参数进行修改，接受服务器响应时，也可以根据返回的code进行统一的处理，且客户端支持防御XSRF。可以开箱即用，但是在实际项目时，需要对axios进行二次封装&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="js" scheme="http://shenweini.cn/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式学习</title>
    <link href="http://shenweini.cn/2019/08/14/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AD%A6%E4%B9%A0/"/>
    <id>http://shenweini.cn/2019/08/14/正则表达式学习/</id>
    <published>2019-08-14T02:26:39.186Z</published>
    <updated>2019-08-14T02:26:39.186Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>正则表达式博大精深，作为一名开发人员不能不会正则，效率好使用方便，写起来还干净利落简直就是神器。使用场景也很多，webpack中的loader配置，devServer中的historyFallBack中的路由匹配，表单验证等等使用正则及其方便。</p></blockquote><h2 id="创建一个正则"><a href="#创建一个正则" class="headerlink" title="创建一个正则"></a>创建一个正则</h2><p>创建一个正则有两种方式和我们创建正常的变量一样。</p><ul><li>字面量 <code>var test = /a+/</code> 使用两个<code>/</code>包裹</li><li>创建<code>RegExp</code>对象， <code>var test = new RegExp(&quot;a+&quot;);</code></li></ul><h2 id="手机号匹配"><a href="#手机号匹配" class="headerlink" title="手机号匹配"></a>手机号匹配</h2><ul><li>以 1 开始</li><li>第二个数字为 3 4 5 7 8 中的一个</li><li>接 9 个数字</li></ul><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ^ 表示匹配正则开始 $ 表示匹配正则结束</span></span><br><span class="line"><span class="comment">// () 表示子正则表达式 | 表示或</span></span><br><span class="line"><span class="comment">// \d 表示一个0-9的数字等价于[0-9] &#123;n&#125; 表示前面一个字符出现 n 次</span></span><br><span class="line">var phoneTest = /^<span class="number">1</span>(<span class="number">3</span>|<span class="number">4</span>|<span class="number">5</span>|<span class="number">7</span>|<span class="number">8</span>)\d&#123;<span class="number">9</span>&#125;$/;</span><br></pre></td></tr></table></figure><p>那么 <code>/^1(3|4|5|7|8)\d{9}$/</code> 就是最终的正则验证表达式。</p><h2 id="邮箱验证"><a href="#邮箱验证" class="headerlink" title="邮箱验证"></a>邮箱验证</h2><ul><li>以大写字母、小写字母、数字、下划线、-、. 开始并重复1到n次</li><li>中间以 @ 连接</li><li>后接 大写字母、小写字母、数字、下划线、-、. 重复1 到n 次</li><li>以 . 接2到4位的大小写字母</li></ul><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// - 和 . 都是特殊字符 使用时需要进行转义</span><br><span class="line">var emailTest = /^[a-zA-Z0-9_<span class="tag">\<span class="name">-</span></span><span class="tag">\<span class="name">.</span></span>]+@[a-zA-Z0-9_<span class="tag">\<span class="name">-</span></span><span class="tag">\<span class="name">.</span></span>]+<span class="tag">\<span class="name">.</span><span class="string">[a-zA-Z]</span><span class="string">&#123;2,4&#125;</span></span>/</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;正则表达式博大精深，作为一名开发人员不能不会正则，效率好使用方便，写起来还干净利落简直就是神器。使用场景也很多，webpack中的loader配置，devServer中的historyFallBack中的路由匹配，表单验证等等使用正则及其方便。&lt;/
      
    
    </summary>
    
    
      <category term="正则" scheme="http://shenweini.cn/tags/%E6%AD%A3%E5%88%99/"/>
    
  </entry>
  
  <entry>
    <title>解决行内元素之间的间隙</title>
    <link href="http://shenweini.cn/2019/08/13/%E8%A7%A3%E5%86%B3%E8%A1%8C%E5%86%85%E5%85%83%E7%B4%A0%E4%B9%8B%E9%97%B4%E7%9A%84%E9%97%B4%E9%9A%99/"/>
    <id>http://shenweini.cn/2019/08/13/解决行内元素之间的间隙/</id>
    <published>2019-08-13T06:13:04.149Z</published>
    <updated>2019-08-13T06:13:04.149Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>今天写demo，用行内元素的时候，发现了一个小问题，行内元素之间尽然会有一个小空隙，但是我没有加左右的margin真的是神奇。突然明白为什么每次面试问我行内元素和块级元素的区别时，面试官脸上的失望是从哪里来的。</p></blockquote><p>上代码：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">.main&#123;</span><br><span class="line"><span class="symbol">    margin:</span> <span class="number">100</span>px;</span><br><span class="line">&#125;</span><br><span class="line">span&#123;</span><br><span class="line"><span class="symbol">    background:</span> blue;</span><br><span class="line"><span class="symbol">    color:</span> white;</span><br><span class="line">&#125;    </span><br><span class="line"><span class="params">&lt;div class="main"&gt;</span></span><br><span class="line">    <span class="params">&lt;span&gt;</span>第一个<span class="params">&lt;/span&gt;</span></span><br><span class="line">    <span class="params">&lt;span&gt;</span>第一个<span class="params">&lt;/span&gt;</span></span><br><span class="line">    <span class="params">&lt;span&gt;</span>第一个<span class="params">&lt;/span&gt;</span></span><br><span class="line"><span class="params">&lt;/div&gt;</span></span><br></pre></td></tr></table></figure><p><img src="http://static.zybuluo.com/shenweizheng/64t51of6himpombw4l501jf8/image_1di4oeu1skdd1jhe125are5bhv9.png" alt="image_1di4oeu1skdd1jhe125are5bhv9.png-4.8kB"></p><p>这三个span之间的空格岂不是很玄妙。<br>换种写法</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"main"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>第一个<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>第一个<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>第一个<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="http://static.zybuluo.com/shenweizheng/i6hpzoa17umdwyw88oq8ix9p/image_1di4ojmqnggm13e58a2vatl8sm.png" alt="image_1di4ojmqnggm13e58a2vatl8sm.png-4.8kB"></p><p>间隙消失了，那么可以看出之所以产生间隙是因为行内元素后面换了行所以产生了间隙。<br>那么解决办法也有很多。</p><h2 id="负边距"><a href="#负边距" class="headerlink" title="负边距"></a>负边距</h2><p>行内元素在水平方向上的 margin 是存在的，在垂直方向上不存在，所以加一个负的margin就可以了。</p><h2 id="使用font-size-0"><a href="#使用font-size-0" class="headerlink" title="使用font-size = 0"></a>使用font-size = 0</h2><p>神奇的属性</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">.main&#123;</span><br><span class="line"><span class="symbol">    margin:</span> <span class="number">100</span>px;</span><br><span class="line">    font-size: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">span&#123;</span><br><span class="line"><span class="symbol">    background:</span> blue;</span><br><span class="line"><span class="symbol">    color:</span> white;</span><br><span class="line">    font-size: <span class="number">16</span>px;</span><br><span class="line">&#125;</span><br><span class="line"><span class="params">&lt;div class="main"&gt;</span></span><br><span class="line">    <span class="params">&lt;span&gt;</span>第一个<span class="params">&lt;/span&gt;</span></span><br><span class="line">    <span class="params">&lt;span&gt;</span>第一个<span class="params">&lt;/span&gt;</span></span><br><span class="line">    <span class="params">&lt;span&gt;</span>第一个<span class="params">&lt;/span&gt;</span></span><br><span class="line"><span class="params">&lt;/div&gt;</span></span><br></pre></td></tr></table></figure><p>当然其他还有很多去除间隙的方法，我还是更喜欢 font-size 这一种</p><p><img src="http://static.zybuluo.com/shenweizheng/6o55pyf87hmqn5mro8a6an4f/image_1di4orf6p7pj1du01gs21mn1s1b13.png" alt="image_1di4orf6p7pj1du01gs21mn1s1b13.png-4.4kB"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;今天写demo，用行内元素的时候，发现了一个小问题，行内元素之间尽然会有一个小空隙，但是我没有加左右的margin真的是神奇。突然明白为什么每次面试问我行内元素和块级元素的区别时，面试官脸上的失望是从哪里来的。&lt;/p&gt;
&lt;/blockquote&gt;

      
    
    </summary>
    
    
      <category term="css" scheme="http://shenweini.cn/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>css 实现三角形、梯形、平行四边形、爱心等形状</title>
    <link href="http://shenweini.cn/2019/08/13/css%20%E5%AE%9E%E7%8E%B0%E4%B8%89%E8%A7%92%E5%BD%A2%E3%80%81%E6%A2%AF%E5%BD%A2%E3%80%81%E5%B9%B3%E8%A1%8C%E5%9B%9B%E8%BE%B9%E5%BD%A2%E3%80%81%E7%88%B1%E5%BF%83%E7%AD%89%E5%BD%A2%E7%8A%B6/"/>
    <id>http://shenweini.cn/2019/08/13/css 实现三角形、梯形、平行四边形、爱心等形状/</id>
    <published>2019-08-13T05:35:03.351Z</published>
    <updated>2019-08-13T05:35:03.351Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>css 是一门很高深的学问，是前端页面是否好看的支柱。之前一直小看了css的力量，最近看其他博主的书才明白自己的css是多么的菜，以为会点布局就是css了有点贻笑大方了。这篇博客利用css 实现各种形状的编写。</p><p>完整代码 <a href="https://github.com/shenweizheng110/study/blob/master/demo/cssShape.html" target="_blank" rel="noopener">https://github.com/shenweizheng110/study/blob/master/demo/cssShape.html</a></p></blockquote><p>css 要想实现三角形、梯形灯形状，主要利用 border 的相关特性。那么首先看一下border属性，我们给一个div设置很宽的border。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">width</span>: <span class="number">40px</span>;</span><br><span class="line"><span class="attribute">height</span>: <span class="number">40px</span>;</span><br><span class="line"><span class="attribute">border-top</span>: <span class="number">50px</span> solid red;</span><br><span class="line"><span class="attribute">border-left</span>: <span class="number">50px</span> solid black;</span><br><span class="line"><span class="attribute">border-right</span>: <span class="number">50px</span> solid yellow;</span><br><span class="line"><span class="attribute">border-bottom</span>: <span class="number">50px</span> solid blue;</span><br></pre></td></tr></table></figure><p>效果为：</p><p><img src="http://static.zybuluo.com/shenweizheng/enpxiprs301m0huftiqh3klq/image_1dhe36eagier2e71cekou71g6r9.png" alt="image_1dhe36eagier2e71cekou71g6r9.png-3kB"></p><a id="more"></a><p>为了看起来清楚一点，我用了四种不同的颜色进行区分。那么我们设置 width 和 hight 都为 0 ，也就是content所占据的面积为0 那么在标准盒模型下，整个div所展示的面积就会由我们的border的宽度所占据，毕竟我们这里没有margin 和 padding。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">width</span>: <span class="number">40px</span>;</span><br><span class="line"><span class="attribute">height</span>: <span class="number">40px</span>;</span><br><span class="line"><span class="attribute">border-top</span>: <span class="number">50px</span> solid red;</span><br><span class="line"><span class="attribute">border-left</span>: <span class="number">50px</span> solid black;</span><br><span class="line"><span class="attribute">border-right</span>: <span class="number">50px</span> solid yellow;</span><br><span class="line"><span class="attribute">border-bottom</span>: <span class="number">50px</span> solid blue;</span><br></pre></td></tr></table></figure><p><img src="http://static.zybuluo.com/shenweizheng/58qgfr5l43fnx7j0soxqgkie/image_1dhe3fpe91mi59qlo4j1evr1i6pm.png" alt="image_1dhe3fpe91mi59qlo4j1evr1i6pm.png-2.5kB"></p><p>如果我们只需要下面蓝色的那个三角形，只需要不设置 上边框，然后左右两个边框的颜色为透明的就可以。当然也可以设置除了蓝色的其余边边框的颜色为透明的也可以。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line"><span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line"><span class="attribute">border</span>: <span class="number">50px</span> solid transparent;</span><br><span class="line"><span class="attribute">border-bottom-color</span>: blue;</span><br></pre></td></tr></table></figure><p><img src="http://static.zybuluo.com/shenweizheng/u5p4mfsvekyb8ixaw0vf2go9/image_1dhe3upqv16sfov16l7tcdep113.png" alt="image_1dhe3upqv16sfov16l7tcdep113.png-1.8kB"></p><p>接下来我们看一下改变三角形的变长，大家都知道改变边框的宽度用的是 border-width 属性。我们可以逐渐的加大 border-bottom 试试<br>border-bottom 为 100 px 时：</p><p><img src="http://static.zybuluo.com/shenweizheng/e1dshqq513uz2q5kckdu6rqb/image_1dhe49cdo1ke3157mvr917gp1pua1g.png" alt="image_1dhe49cdo1ke3157mvr917gp1pua1g.png-2.7kB"></p><p>可以看的出来时三角形的高变大了，而不是三角形的底变大了。之前我也在懵逼为什么会是这样的，结果我发现对 border-width 的了解出现了偏差。事实上，border-width 是这样的：</p><p><img src="http://static.zybuluo.com/shenweizheng/3zdfwy9ga8s4vd9eajazndul/image_1dhe5d7ea36mceuqqq1ij4r401t.png" alt="image_1dhe5d7ea36mceuqqq1ij4r401t.png-33.4kB"></p><p>图中的这条白线才是 border-width。<br>那么同样的，蓝色三角形的边长是 border-left-width 加上 border-right-width 的和，高度为 border-bottom-width。</p><h2 id="直角三角形"><a href="#直角三角形" class="headerlink" title="直角三角形"></a>直角三角形</h2><p>上面说了三角形的边和高的构成，那么直角三角形就是将border-left 或者 border-right其中一个置为0；</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line"><span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line"><span class="attribute">border-left</span>: <span class="number">50px</span> solid transparent;</span><br><span class="line"><span class="attribute">border-bottom</span>: <span class="number">50px</span> solid blue;</span><br></pre></td></tr></table></figure><p><img src="http://static.zybuluo.com/shenweizheng/jabxz4dhmdd7p0kwf2vwed6r/image_1dhe5n3ab15sbemfjog1brsp882a.png" alt="image_1dhe5n3ab15sbemfjog1brsp882a.png-0.9kB"></p><h2 id="等边三角形"><a href="#等边三角形" class="headerlink" title="等边三角形"></a>等边三角形</h2><p>等边三角形的定义是三角形的三边长相等，高为边的 $\sqrt 3$, 那么高是由border-bottom-width控制的，而变长是由 border-left-width 与 border-right-width 的和。那么如果我们的 border-left-width 和 border-right-width 都为 50px 的话，高就是 $50\sqrt 3$, 粗略的为 86px</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line"><span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line"><span class="attribute">border-left</span>: <span class="number">50px</span> solid transparent;</span><br><span class="line"><span class="attribute">border-right</span>: <span class="number">50px</span> solid transparent;</span><br><span class="line"><span class="attribute">border-bottom</span>: <span class="number">86px</span> solid blue;</span><br></pre></td></tr></table></figure><p><img src="http://static.zybuluo.com/shenweizheng/b0z16sii7eg33047adswnmtg/image_1dhe67t11uj4kt01k3bbb9sjl2n.png" alt="image_1dhe67t11uj4kt01k3bbb9sjl2n.png-2.8kB"></p><h2 id="梯形"><a href="#梯形" class="headerlink" title="梯形"></a>梯形</h2><h3 id="直角梯形"><a href="#直角梯形" class="headerlink" title="直角梯形"></a>直角梯形</h3><p>只需要将上边框取消，左右选取一个将其颜色置为透明<br><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line"><span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line"><span class="attribute">border-left</span>: <span class="number">50px</span> solid transparent;</span><br><span class="line"><span class="attribute">border-right</span>: <span class="number">50px</span> solid yellow;</span><br><span class="line"><span class="attribute">border-bottom</span>: <span class="number">50px</span> solid blue;</span><br></pre></td></tr></table></figure></p><p><img src="http://static.zybuluo.com/shenweizheng/70cxwgul0fxu8lc2u68qvzeo/image_1di4cei5b12bm1e28ipfmn41g8k9.png" alt="image_1di4cei5b12bm1e28ipfmn41g8k9.png-2.1kB"></p><h3 id="普通梯形"><a href="#普通梯形" class="headerlink" title="普通梯形"></a>普通梯形</h3><p>普通梯形的上边框需要使用width属性指定，要给他一定的宽度<br><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">width</span>: <span class="number">25px</span>;</span><br><span class="line"><span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line"><span class="attribute">border-left</span>: <span class="number">50px</span> solid transparent;</span><br><span class="line"><span class="attribute">border-right</span>: <span class="number">50px</span> solid transparent;</span><br><span class="line"><span class="attribute">border-bottom</span>: <span class="number">50px</span> solid blue;</span><br></pre></td></tr></table></figure></p><p><img src="http://static.zybuluo.com/shenweizheng/1c7o51i00fibxmfhp75km2wx/image_1di4chtfv1ls718n7p4d1rr68vam.png" alt="image_1di4chtfv1ls718n7p4d1rr68vam.png-1.7kB"></p><h2 id="菱形"><a href="#菱形" class="headerlink" title="菱形"></a>菱形</h2><p>这个就简单了，只要将正方形旋转 45 度。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line"><span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line"><span class="attribute">border-top</span>: <span class="number">50px</span> solid red;</span><br><span class="line"><span class="attribute">border-left</span>: <span class="number">50px</span> solid black;</span><br><span class="line"><span class="attribute">border-right</span>: <span class="number">50px</span> solid yellow;</span><br><span class="line"><span class="attribute">border-bottom</span>: <span class="number">50px</span> solid blue;</span><br><span class="line"><span class="attribute">transform</span>: rotate(<span class="number">45deg</span>);</span><br></pre></td></tr></table></figure><p><img src="http://static.zybuluo.com/shenweizheng/j4x5db0fuvszpubr6wlzxob5/image_1di4dvmqhsnt1hmfr8216cd1r8013.png" alt="image_1di4dvmqhsnt1hmfr8216cd1r8013.png-3.8kB"></p><h2 id="平行四边形"><a href="#平行四边形" class="headerlink" title="平行四边形"></a>平行四边形</h2><p>借助 transform 中的 skew 属性来实现，由于直接在div中使用，会导致内部的字体也会相应的倾斜，一种解决方案是对里面的文本加一个反向的倾斜，另一种解决方案是利用为元素进行倾斜，这样内部的文本就不会继承倾斜了。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.rhomboid</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.rhomboid</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">''</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">z-index</span>: -<span class="number">1</span>;</span><br><span class="line">    <span class="attribute">background</span>: blue;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">skew</span>(45deg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://static.zybuluo.com/shenweizheng/pdzf4qkdzy5ykog9tb7brsj7/image_1di4fae5a1t7316a01oqc1opu7cq1g.png" alt="image_1di4fae5a1t7316a01oqc1opu7cq1g.png-3.3kB"></p><h2 id="爱心"><a href="#爱心" class="headerlink" title="爱心"></a>爱心</h2><p>爱心可以通过的其他元素进行遮掩拼接实现。首先画一个正方形</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.love</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">background</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://static.zybuluo.com/shenweizheng/ist4ccrw14wllj02xdvb6c3r/image_1di4mgturg9ud8j4gt1h8f4er1t.png" alt="image_1di4mgturg9ud8j4gt1h8f4er1t.png-1.1kB"></p><p>通过为元素画两个圆覆盖在正方形上</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.love</span><span class="selector-pseudo">::before</span>&#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">''</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">left</span>: -<span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">background</span>: yellow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.love</span><span class="selector-pseudo">::after</span>&#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">''</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: -<span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">background</span>: yellow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://static.zybuluo.com/shenweizheng/kwj2g5my4vw7ii5iw7js5x2a/image_1di4mkpv0lp8se91sink8t2p22a.png" alt="image_1di4mkpv0lp8se91sink8t2p22a.png-4.1kB"></p><p><img src="http://static.zybuluo.com/shenweizheng/pb3wtmyl4dqrimn16f5upnhc/image_1di4mlfpfkip1k76v917cmfl2n.png" alt="image_1di4mlfpfkip1k76v917cmfl2n.png-5.4kB"></p><p>旋转 45 度 颜色改成一致的</p><p><img src="http://static.zybuluo.com/shenweizheng/jv5frcyxvv5ku00twgxd158h/image_1di4mmm0r1l5l1prvr8m8p43rr34.png" alt="image_1di4mmm0r1l5l1prvr8m8p43rr34.png-5.9kB"></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;css 是一门很高深的学问，是前端页面是否好看的支柱。之前一直小看了css的力量，最近看其他博主的书才明白自己的css是多么的菜，以为会点布局就是css了有点贻笑大方了。这篇博客利用css 实现各种形状的编写。&lt;/p&gt;
&lt;p&gt;完整代码 &lt;a href=&quot;https://github.com/shenweizheng110/study/blob/master/demo/cssShape.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/shenweizheng110/study/blob/master/demo/cssShape.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;css 要想实现三角形、梯形灯形状，主要利用 border 的相关特性。那么首先看一下border属性，我们给一个div设置很宽的border。&lt;/p&gt;
&lt;figure class=&quot;highlight scss&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attribute&quot;&gt;width&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;40px&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attribute&quot;&gt;height&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;40px&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attribute&quot;&gt;border-top&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;50px&lt;/span&gt; solid red;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attribute&quot;&gt;border-left&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;50px&lt;/span&gt; solid black;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attribute&quot;&gt;border-right&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;50px&lt;/span&gt; solid yellow;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attribute&quot;&gt;border-bottom&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;50px&lt;/span&gt; solid blue;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;效果为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://static.zybuluo.com/shenweizheng/enpxiprs301m0huftiqh3klq/image_1dhe36eagier2e71cekou71g6r9.png&quot; alt=&quot;image_1dhe36eagier2e71cekou71g6r9.png-3kB&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="css" scheme="http://shenweini.cn/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>BFC的触发条件、布局规则、使用场景</title>
    <link href="http://shenweini.cn/2019/07/31/BFC%E7%9A%84%E8%A7%A6%E5%8F%91%E6%9D%A1%E4%BB%B6%E3%80%81%E5%B8%83%E5%B1%80%E8%A7%84%E5%88%99%E3%80%81%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/"/>
    <id>http://shenweini.cn/2019/07/31/BFC的触发条件、布局规则、使用场景/</id>
    <published>2019-07-31T01:36:51.240Z</published>
    <updated>2019-08-03T14:21:28.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>BFC指的是块级格式化上下文，简单的来说，BFC就是创建一个盒子，盒子内部的元素布局不影响盒子外部的元素。html根元素就是一个BFC</p></blockquote><h2 id="BFC-的触发条件"><a href="#BFC-的触发条件" class="headerlink" title="BFC 的触发条件"></a>BFC 的触发条件</h2><ul><li>html根元素 <code>&lt;html&gt;</code></li><li>float 不为 none</li><li>绝对定位元素 也就是 position 为 absolute 和 fixed</li><li>行内快元素 display 为 inline-block</li><li>display 为 table-cell inline-block flex inline-flex grid inline-grid table-caption(表格标题)</li><li>overflow 不为 visible</li></ul><a id="more"></a><h2 id="BFC-的规则"><a href="#BFC-的规则" class="headerlink" title="BFC 的规则"></a>BFC 的规则</h2><ol><li>内部的Box会在垂直方向，一个接一个地放置。Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠。</li><li>每个元素的margin box的左边， 与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。</li><li>BFC的区域不会与float box重叠。</li><li>FC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。</li><li>计算BFC的高度时，浮动元素也参与计算。</li></ol><h2 id="BFC解决的问题"><a href="#BFC解决的问题" class="headerlink" title="BFC解决的问题"></a>BFC解决的问题</h2><h3 id="垂直方向-margin-重叠"><a href="#垂直方向-margin-重叠" class="headerlink" title="垂直方向 margin 重叠"></a>垂直方向 margin 重叠</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.out&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">background</span>: black;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="selector-tag">div</span> class=<span class="string">'out'</span>&gt;&lt;/div&gt;</span><br><span class="line">&lt;<span class="selector-tag">div</span> class=<span class="string">'out'</span>&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>理论上讲，这两个 div 上下间隙有 40px 因为两个div 的margin都是 20px 加起来就是40px，但是看一下效果图。</p><p><img src="http://static.zybuluo.com/shenweizheng/ht4jg65uch1aetpqj3qss3bx/image_1dh2ouhd51bsjc015lseft7nnm.png" alt="image_1dh2ouhd51bsjc015lseft7nnm.png-2.1kB"></p><p>这个实际上，只有 20px 的间隙，原因是一个容器内部的所有box会从上往下进行堆叠，并且垂直相邻的距离(即margin)是由各自的margin决定的，在垂直方向上会发生 margin 重叠。解决方案是将两个 div 分属于不同的BFC。</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">div</span> <span class="built_in">class</span>='out'&gt;&lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">&lt;<span class="keyword">div</span> style=<span class="string">"overflow: hidden"</span>&gt;</span><br><span class="line">    &lt;<span class="keyword">div</span> <span class="built_in">class</span>='out'&gt;&lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">&lt;/<span class="keyword">div</span>&gt;</span><br></pre></td></tr></table></figure><p>在其中一个out外面包裹一层div，设置 overflow: hidden 使其变成一个BFC，这样两个out就不会发生margin重叠了。</p><p><img src="http://static.zybuluo.com/shenweizheng/q6ic9t4n3v75zghzybkz2jv0/image_1dh2p3qqkk1g1c2dasi6tb1cbn13.png" alt="image_1dh2p3qqkk1g1c2dasi6tb1cbn13.png-2.8kB"></p><p>在看另一外一种margin重叠</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">.out&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">background</span>: black;</span><br><span class="line">    <span class="attribute">margin-top</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.inner&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">background</span>: red;</span><br><span class="line">    <span class="attribute">margin-top</span>: <span class="number">30px</span>;</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="selector-tag">div</span> class=<span class="string">'out'</span>&gt;</span><br><span class="line">    &lt;<span class="selector-tag">div</span> class=<span class="string">"inner"</span>&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p><img src="http://static.zybuluo.com/shenweizheng/1t50d2gchk4f9pm9o8l1yv1p/image_1dh2p80er1035cd61n5611r9q1v1g.png" alt="image_1dh2p80er1035cd61n5611r9q1v1g.png-6.1kB"></p><p>可以看出，整个元素距离顶部的距离是由子元素 inner 的margin-top决定的，因为 inner 的marginTop是大于外部的out的，并且他们都属于 html 跟元素下的BFC，所以margin在垂直方向上会发生重叠，取最大值。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.out</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">background</span>: black;</span><br><span class="line">    <span class="attribute">margin-top</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">overflow</span>: hidden;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>给 out 设置 overflow: hidden 让他变成一个 BFC</p><p><img src="http://static.zybuluo.com/shenweizheng/2ss8m8qjet3nrlpkik471lfx/image_1dh2ped1p1r5s10ehbnf1a388071t.png" alt="image_1dh2ped1p1r5s10ehbnf1a388071t.png-1.5kB"></p><h3 id="文本不环绕浮动元素"><a href="#文本不环绕浮动元素" class="headerlink" title="文本不环绕浮动元素"></a>文本不环绕浮动元素</h3><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">.<span class="built_in">float</span>&#123;</span><br><span class="line">    <span class="built_in">float</span>: left;</span><br><span class="line">    <span class="built_in">width</span>: <span class="number">100</span>px;</span><br><span class="line">    <span class="built_in">height</span>: <span class="number">100</span>px;</span><br><span class="line">    <span class="built_in">background</span>: <span class="built_in">red</span>;</span><br><span class="line">    <span class="built_in">color</span>: white;</span><br><span class="line">&#125;</span><br><span class="line">p&#123;</span><br><span class="line">    <span class="built_in">width</span>: <span class="number">200</span>px;</span><br><span class="line">    <span class="built_in">height</span>: <span class="number">200</span>px;</span><br><span class="line">    <span class="built_in">background</span>: <span class="built_in">blue</span>;</span><br><span class="line">    <span class="built_in">color</span>: white;</span><br><span class="line">&#125;</span><br><span class="line">&lt;div class=<span class="string">"float"</span>&gt;I am a floated <span class="built_in">box</span>!&lt;/div&gt;</span><br><span class="line">&lt;p&gt;I am content inside the container.&lt;/p&gt;</span><br></pre></td></tr></table></figure><p><img src="http://static.zybuluo.com/shenweizheng/6p2jtzzqff03j50aornozxos/image_1dh2pth9oj4p9412k11kro1tn02a.png" alt="image_1dh2pth9oj4p9412k11kro1tn02a.png-13.2kB"></p><p>现在我们的蓝色区域的文本是围绕着浮动元素进行排列的，如果要实现两栏布局的话有一种办法是让蓝色区域的marginLeft设置为红色区域的宽 + 你想要的边距</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">background</span>: blue;</span><br><span class="line">    <span class="attribute">color</span>: white;</span><br><span class="line">    <span class="attribute">overflow</span>: hidden;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将 p 变成BFC</p><h3 id="解决包裹浮动元素没有高度的问题"><a href="#解决包裹浮动元素没有高度的问题" class="headerlink" title="解决包裹浮动元素没有高度的问题"></a>解决包裹浮动元素没有高度的问题</h3><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.inner&#123;</span><br><span class="line"><span class="symbol">    float:</span> left;</span><br><span class="line"><span class="symbol">    width:</span> <span class="number">100</span>px;</span><br><span class="line"><span class="symbol">    height:</span> <span class="number">100</span>px;</span><br><span class="line"><span class="symbol">    background:</span> red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="params">&lt;div&gt;</span></span><br><span class="line">    <span class="params">&lt;div class='inner'&gt;</span><span class="params">&lt;/div&gt;</span></span><br><span class="line"><span class="params">&lt;/div&gt;</span></span><br></pre></td></tr></table></figure><p><img src="http://static.zybuluo.com/shenweizheng/9fug72v07c84wmoc0xgmbfz0/image_1dh2qc0vdmsu698slaa112dn3k.png" alt="image_1dh2qc0vdmsu698slaa112dn3k.png-4.7kB"></p><p>一般来说，div 不设置宽高的话，他的宽高会由子元素的宽高给撑起来，但是这边 包裹了一个浮动元素，发现父级元素的高度为 0</p><p><img src="http://static.zybuluo.com/shenweizheng/7pxxvy6tkz4ov0ku7jtqd55p/image_1dh2qhk4l1guf1koqjbokt41ne74e.png" alt="image_1dh2qhk4l1guf1koqjbokt41ne74e.png-11.8kB"></p><p><img src="http://static.zybuluo.com/shenweizheng/jpwg0iwwcwuqncwygfiycsuz/image_1dh2qgtdi1nvsf2b19uo11ej19q541.png" alt="image_1dh2qgtdi1nvsf2b19uo11ej19q541.png-5kB"></p><p>同样的设置为BFC</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;BFC指的是块级格式化上下文，简单的来说，BFC就是创建一个盒子，盒子内部的元素布局不影响盒子外部的元素。html根元素就是一个BFC&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;BFC-的触发条件&quot;&gt;&lt;a href=&quot;#BFC-的触发条件&quot; class=&quot;headerlink&quot; title=&quot;BFC 的触发条件&quot;&gt;&lt;/a&gt;BFC 的触发条件&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;html根元素 &lt;code&gt;&amp;lt;html&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;float 不为 none&lt;/li&gt;
&lt;li&gt;绝对定位元素 也就是 position 为 absolute 和 fixed&lt;/li&gt;
&lt;li&gt;行内快元素 display 为 inline-block&lt;/li&gt;
&lt;li&gt;display 为 table-cell inline-block flex inline-flex grid inline-grid table-caption(表格标题)&lt;/li&gt;
&lt;li&gt;overflow 不为 visible&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="css" scheme="http://shenweini.cn/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>原型链 与 继承的理解</title>
    <link href="http://shenweini.cn/2019/07/26/%E5%8E%9F%E5%9E%8B%E9%93%BE%20%E4%B8%8E%20%E7%BB%A7%E6%89%BF%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <id>http://shenweini.cn/2019/07/26/原型链 与 继承的理解/</id>
    <published>2019-07-26T12:47:05.904Z</published>
    <updated>2019-08-03T14:22:16.982Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原型链是前端面试几乎必问的东西，原型链实现了js中的继承。在看完阮一峰老师的博客后，理解了原型链的作用。</p></blockquote><h2 id="new-的由来"><a href="#new-的由来" class="headerlink" title="new 的由来"></a>new 的由来</h2><p>关于new的由来大家可以借阅阮一峰老师的博客<a href="http://www.ruanyifeng.com/blog/2011/06/designing_ideas_of_inheritance_mechanism_in_javascript.html" target="_blank" rel="noopener">Javascript继承机制的设计思想</a></p><a id="more"></a><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>在es5之前还没有类的时候，js都是 new 一个构造函数来生成一个构造函数的对象，这边的构造函数相当于java中的class，在es6之后，为了方便js也诞生了 class 关键字。<br>构造函数和普通的function最直观的区别是 构造函数的函数名是大写的，它张这个样子<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dog</span><span class="params">(name)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.type = <span class="string">'dog'</span>;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这边是定义了一个 Dog 的构造函数，那么我们可以使用 new 来创建一只狗</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> dog = <span class="keyword">new</span> Dog(<span class="string">'哈士奇'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(dog.name); <span class="comment">// 哈士奇</span></span><br></pre></td></tr></table></figure><p>至于构造函数中的this指向问题，这边就不说了，在我的上一篇博客详细的介绍了<a href="https://blog.csdn.net/qq_38606793/article/details/97309053" target="_blank" rel="noopener">js中的this指向问题</a>。</p><p>下面我们了解一下 new 一个对象的中间发生了什么</p><h2 id="new-的过程"><a href="#new-的过程" class="headerlink" title="new 的过程"></a>new 的过程</h2><p>节选自js高级程序设计（第三版），创建一个实例，一共分为四个步骤</p><p>（1）创建一个新对象；</p><p>（2）将构造函数的作用域赋给新对象（因此this就指向了这个新对象）；</p><p>（3）执行构造函数中的代码（为这个新对象添加属性）；</p><p>（4）返回新对象。</p><h2 id="new-的缺点"><a href="#new-的缺点" class="headerlink" title="new 的缺点"></a>new 的缺点</h2><p>前面提到了 new 运算符可以实例化一个对象，但是 new 也有一个缺点，就是new出来的两个对象之间没有任何的联系，做不到数据共享，这个缺点有违 new 创建的初衷。下面看一段示例<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dog</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.type = <span class="string">'dog'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> dogA = <span class="keyword">new</span> Dog(<span class="string">'哈士奇'</span>);</span><br><span class="line"><span class="keyword">let</span> dogB = <span class="keyword">new</span> Dog(<span class="string">'大金毛'</span>);</span><br><span class="line"></span><br><span class="line">dogA.type = <span class="string">'大型犬'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(dogB.type); <span class="comment">// 'dog'</span></span><br></pre></td></tr></table></figure></p><p>通过 Dog 构造函数实例化出了两个对象，修改其中一个对象的属性，并不会改变另一个对象的属性，这并不是 new 设计的初衷， dogA 和 dogB 两个对象之间无法做到数据共享，就好像没有任何关系一样。</p><h2 id="prototype-的引入"><a href="#prototype-的引入" class="headerlink" title="prototype 的引入"></a>prototype 的引入</h2><p>为了解决上面所述的问题，new 的创始人引入了 prototype 属性，</p><blockquote><p>这个属性包含一个对象（以下简称”prototype对象”），所有实例对象需要共享的属性和方法，都放在这个对象里面；那些不需要共享的属性和方法，就放在构造函数里面。</p><p>实例对象一旦创建，将自动引用prototype对象的属性和方法。也就是说，实例对象的属性和方法，分成两种，一种是本地的，另一种是引用的。</p></blockquote><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function Dog(name)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">&#125;</span><br><span class="line">Dog.prototype.<span class="keyword">type</span> = <span class="string">'dog'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> dogA = <span class="literal">new</span> Dog(<span class="string">'哈士奇'</span>);</span><br><span class="line"><span class="keyword">let</span> dogB = <span class="literal">new</span> Dog(<span class="string">'大金毛'</span>);</span><br><span class="line"></span><br><span class="line">console.<span class="keyword">log</span>(dogA.<span class="keyword">type</span>); <span class="comment">// dog</span></span><br><span class="line">Dog.prototype.<span class="keyword">type</span> = <span class="string">'大型犬'</span>;</span><br><span class="line">console.<span class="keyword">log</span>(dogA.<span class="keyword">type</span>, dogB.<span class="keyword">type</span>); <span class="comment">//大型犬 大型犬</span></span><br></pre></td></tr></table></figure><p>type属性是 Dog实例化出的对象所共享的属性，只要修改了 prototype中的type属性，每一个对象的 type 值都会被改变。</p><h2 id="构造函数实现继承"><a href="#构造函数实现继承" class="headerlink" title="构造函数实现继承"></a>构造函数实现继承</h2><p>构造函数实现继承有很多中实现方式，首先看第一种</p><h3 id="call-apply-绑定"><a href="#call-apply-绑定" class="headerlink" title="call apply 绑定"></a>call apply 绑定</h3><p>这种是直接将父构造函数绑定在子构造函数中<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.type = <span class="string">'dog'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dog</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    Animal.call(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> dogA = <span class="keyword">new</span> Dog(<span class="string">'哈士奇'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(dogA.type); <span class="comment">// dog</span></span><br></pre></td></tr></table></figure></p><h3 id="使用prototype进行继承"><a href="#使用prototype进行继承" class="headerlink" title="使用prototype进行继承"></a>使用prototype进行继承</h3><p>由于 prototype 属性可以存在对象共享的属性，那么我们可以按照封装的思想，将公共的部分抽离出来，变成一个公共的构造函数，也就是这些对象的父类也是基类，我觉得叫基类更加的合适，因为它存储着每一个对象的公共部分。实现方式只需要将子构造函数的 prototype 属性赋值为父构造函数<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.type = <span class="string">'dog'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dog</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Dog.prototype = <span class="keyword">new</span> Animal();</span><br><span class="line">Dog.prototype.constructor = Dog;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> dogA = <span class="keyword">new</span> Dog(<span class="string">'哈士奇'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(dogA.type); <span class="comment">// dog</span></span><br></pre></td></tr></table></figure></p><ul><li>第 9 行：将Dog 的原型属性赋值为Animal的实例</li><li>第 10 行：修改 prototype 属性的costructor对象为Dog，这是因为每一个 prototype 对象都包含了它的构造函数对象，在上一行将 Dog 的原型直接赋值为 Animal的构造函数，所以此时Dog的原型对象中的 constructor其实是指向Animal的构造函数的，所以我们这边要修改回来，不然引起原型链的絮乱。</li></ul><h3 id="直接继承prototype"><a href="#直接继承prototype" class="headerlink" title="直接继承prototype"></a>直接继承prototype</h3><blockquote><p>第三种方法是对第二种方法的改进。由于Animal对象中，不变的属性都可以直接写入Animal.prototype。所以，我们也可以让Cat()跳过 Animal()，直接继承Animal.prototype。</p></blockquote><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span><span class="params">()</span><span class="comment">&#123; &#125;</span>;</span></span><br><span class="line">Animal.prototype.<span class="keyword">type</span> = <span class="string">'dog'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dog</span><span class="params">(<span class="keyword">name</span>)</span><span class="comment">&#123;</span></span></span><br><span class="line"><span class="function"><span class="comment">    this.name = name;</span></span></span><br><span class="line"><span class="function"><span class="comment">&#125;</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">Dog</span>.<span class="title">prototype</span> = <span class="title">Animal</span>.<span class="title">prototype</span>;</span></span><br><span class="line">Dog.prototype.<span class="keyword">constructor</span> = Dog;</span><br><span class="line"></span><br><span class="line">let dogA = new Dog(<span class="string">'哈士奇'</span>);</span><br><span class="line">console.log(dogA.<span class="keyword">type</span>); <span class="comment">// dog</span></span><br></pre></td></tr></table></figure><p>这种方法相比于第二种方法，优点是效率高，因为他跳过了执行创建一个 Animal 实例，省内存。但是也有缺点，缺点是直接将 Animal 的prototype 属性赋值给了 Dog 的 prototype 这是一个浅拷贝，因为prototype 是一个 object，所以对于任何Dog 的 prototype的修改都会响应在 Animal.prototype；</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log<span class="params">(Animal.prototype.<span class="attr">constructor</span> === Dog)</span>; <span class="string">//</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>我们在第 9 行修改了Dog.prototype中的 constructor属性，这边打印发现 Animal 的 prototype中的 constructor 也指向了 Dog</p><h3 id="利用空对象作为中介"><a href="#利用空对象作为中介" class="headerlink" title="利用空对象作为中介"></a>利用空对象作为中介</h3><p>为了解决上面一种方式引起的问题，可以采用空对象作为媒介。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params"></span>)</span>&#123; &#125;;</span><br><span class="line">Animal.prototype.type = <span class="string">'dog'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dog</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Temp = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; &#125;;</span><br><span class="line">Temp.prototype = Animal.prototype;</span><br><span class="line">Dog.prototype = <span class="keyword">new</span> Temp();</span><br><span class="line">Dog.prototype.constructor = Dog;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> dogA = <span class="keyword">new</span> Dog(<span class="string">'哈士奇'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(dogA.type); <span class="comment">// dog</span></span><br><span class="line"><span class="built_in">console</span>.log(Animal.prototype.constructor === Dog); <span class="comment">// false</span></span><br></pre></td></tr></table></figure></p><p>利用空对象作为媒介，空对象几乎不占内存，也不会影响 Animal 的 prototype</p><h3 id="拷贝继承"><a href="#拷贝继承" class="headerlink" title="拷贝继承"></a>拷贝继承</h3><p>顾名思义，就是将父对象的所有属性和方法，拷贝进子对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params"></span>)</span>&#123; &#125;;</span><br><span class="line">Animal.prototype.type = <span class="string">'dog'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dog</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">extendOfCopy</span>(<span class="params">Child, Parent</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> c = Child.prototype;</span><br><span class="line">    <span class="keyword">let</span> p = Parent.prototype;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">in</span> p)&#123;</span><br><span class="line">        c[i] = p[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">extendOfCopy(Dog, Animal);</span><br><span class="line"><span class="keyword">let</span> dogA = <span class="keyword">new</span> Dog(<span class="string">'哈士奇'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(dogA.type); <span class="comment">// dog</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;原型链是前端面试几乎必问的东西，原型链实现了js中的继承。在看完阮一峰老师的博客后，理解了原型链的作用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;new-的由来&quot;&gt;&lt;a href=&quot;#new-的由来&quot; class=&quot;headerlink&quot; title=&quot;new 的由来&quot;&gt;&lt;/a&gt;new 的由来&lt;/h2&gt;&lt;p&gt;关于new的由来大家可以借阅阮一峰老师的博客&lt;a href=&quot;http://www.ruanyifeng.com/blog/2011/06/designing_ideas_of_inheritance_mechanism_in_javascript.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Javascript继承机制的设计思想&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="js" scheme="http://shenweini.cn/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>js 微任务 宏任务</title>
    <link href="http://shenweini.cn/2019/07/26/js%20%E5%BE%AE%E4%BB%BB%E5%8A%A1%20%E5%AE%8F%E4%BB%BB%E5%8A%A1%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%E8%A7%A3%E9%87%8A/"/>
    <id>http://shenweini.cn/2019/07/26/js 微任务 宏任务的执行顺序解释/</id>
    <published>2019-07-26T01:19:57.075Z</published>
    <updated>2019-08-03T14:22:54.278Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>js 是单线程执行的，js中的任务按顺序一个一个的执行，但是一个任务耗时太长，那么后面的任务就需要等待，为了解决这种情况，将任务分为了同步任务和异步任务，而异步任务又可以分为微任务和宏任务。</p></blockquote><p>首先第一段示例代码<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">console.<span class="built_in">log</span>(<span class="string">'script start'</span>);</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span><span class="params">()</span></span> &#123;</span><br><span class="line">  console.<span class="built_in">log</span>(<span class="string">'setTimeout'</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">Promise.resolve().<span class="keyword">then</span>(<span class="function"><span class="keyword">function</span><span class="params">()</span></span> &#123;</span><br><span class="line">  console.<span class="built_in">log</span>(<span class="string">'promise1'</span>);</span><br><span class="line">&#125;).<span class="keyword">then</span>(<span class="function"><span class="keyword">function</span><span class="params">()</span></span> &#123;</span><br><span class="line">  console.<span class="built_in">log</span>(<span class="string">'promise2'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">console.<span class="built_in">log</span>(<span class="string">'script end'</span>);</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>打印顺序为：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">script start</span><br><span class="line">script end</span><br><span class="line">promise1</span><br><span class="line">promise</span><br><span class="line">setTimeout</span><br></pre></td></tr></table></figure></p><p>具体为什么会打印出这个顺序，下面在具体解释。<br>我们具体看一下js的执行流程：<br><img src="http://static.zybuluo.com/shenweizheng/iy5q6fscnpe2c6cch47ck9na/image_1dglrup181e0m18gr10lc187e19549.png" alt="image_1dglrup181e0m18gr10lc187e19549.png-496.3kB"></p><p><a href="https://juejin.im/post/5b498d245188251b193d4059" target="_blank" rel="noopener">张倩qianniuerlv-2 JS事件循环机制（event loop）之宏任务/微任务</a>解读：</p><ol><li>同步和异步任务分别进入不同的执行”场所”，同步的进入主线程，异步的进入Event Table并注册函数</li><li>当指定的事情完成时，Event Table会将这个函数移入Event Queue。</li><li>主线程内的任务执行完毕为空，会去Event Queue读取对应的函数，进入主线程执行。</li><li>上述过程会不断重复，也就是常说的Event Loop(事件循环)。</li></ol><p>在js引擎中，存在一个叫monitoring process的进程，这个进程会不断的检查主线程的执行情况，一旦为空，就会去Event Quene检查有哪些待执行的函数。</p><h2 id="微任务-和-宏任务"><a href="#微任务-和-宏任务" class="headerlink" title="微任务 和 宏任务"></a>微任务 和 宏任务</h2><blockquote><p>微任务和宏任务的问题应该是前端面试中比较常见的，他们都从属于异步任务，主要区别在于他们的执行顺序，Event Loop的走向和取值</p></blockquote><p><img src="http://static.zybuluo.com/shenweizheng/cegc5egyrr3orq4ylwf1136k/image_1dglsb50i1tvh1ul01ur318fa6h39.png" alt="image_1dglsb50i1tvh1ul01ur318fa6h39.png-293.5kB"></p><p>这张图的意思就是：</p><ol><li>存在微任务的话，那么就执行所有的微任务</li><li>微任务都执行完之后，执行第一个宏任务，</li><li>循环 1， 2</li></ol><p>从参考博主的博客里看到这段，这边不得不提一句，我也是看了这为博主的博客才理清楚了微任务和宏任务的概念。博主的链接会在文章末给出。</p><blockquote><p>一个掘金的老哥（ssssyoki）的文章摘要：<br>那么如此看来我给的答案还是对的。但是js异步有一个机制，就是遇到宏任务，先执行宏任务，将宏任务放入eventqueue，然后在执行微任务，将微任务放入eventqueue最骚的是，这两个queue不是一个queue。当你往外拿的时候先从微任务里拿这个回掉函数，然后再从宏任务的queue上拿宏任务的回掉函数。 我当时看到这我就服了还有这种骚操作。</p></blockquote><p>这边我们可以看出，微任务和宏任务是同属于两个不同的队列的！！！</p><ul><li>宏任务一般包括：整体代码script，setTimeout，setInterval、setImmediate。</li><li>微任务一般包括：原生Promise(有些实现的promise将then方法放到了宏任务中)、process.nextTick、Object.observe(已废弃)、 MutationObserver </li></ul><p>一段丧心病狂的代码<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'1'</span>);</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'2'</span>);</span><br><span class="line">    process.nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'3'</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'4'</span>);</span><br><span class="line">        resolve();</span><br><span class="line">    &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'5'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">process.nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'6'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'7'</span>);</span><br><span class="line">    resolve();</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'8'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'9'</span>);</span><br><span class="line">    process.nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'10'</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'11'</span>);</span><br><span class="line">        resolve();</span><br><span class="line">    &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'12'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>第一轮循环：</p><ul><li>首先打印 1</li><li>下面是setTimeout是异步任务且是宏任务，加入宏任务暂且记为 setTimeout1</li><li>下面是 process 微任务 加入微任务队列 记为 process1</li><li>下面是 new Promise 里面直接 resolve(7) 所以打印 7 后面的then是微任务 记为 then1</li><li>setTimeout 宏任务 记为 setTimeout2</li></ul><p>第一轮循环打印出的是 1 7<br>当前宏任务队列：setTimeout1, setTimeout2<br>当前微任务队列：process1, then1, </p><p>第二轮循环：</p><ul><li>执行所有微任务</li><li>执行process1，打印出 6 </li><li>执行then1 打印出8</li><li>微任务都执行结束了，开始执行第一个宏任务</li><li>执行  setTimeout1 也就是 第 3 - 14 行</li><li>首先打印出 2</li><li>遇到 process 微任务 记为 process2</li><li>new Promise中resolve 打印出 4</li><li>then 微任务 记为 then2</li></ul><p>第二轮循环结束，当前打印出来的是  1 7 6 8 2 4<br>当前宏任务队列：setTimeout2<br>当前微任务队列：process2, then2</p><p>第三轮循环：</p><ul><li>执行所有的微任务</li><li>执行 process2 打印出 3</li><li>执行 then2 打印出 5</li><li>执行第一个宏任务，也就是执行 setTimeout2 对应代码中的 25 - 36 行</li><li>首先打印出 9</li><li>process 微任务 记为 process3</li><li>new Promise执行resolve 打印出 11</li><li>then 微任务 记为 then3</li></ul><p>当前打印顺序为：1 7 6 8 2 4 3 5 9 11<br>当前宏任务队列为空<br>当前微任务队列：process3，then3</p><p>第四轮循环：</p><ul><li>执行所有的微任务</li><li>执行process3 打印出 10</li><li>执行then3 打印出 12</li></ul><p>代码执行结束：<br>最终打印顺序为：1 7 6 8 2 4 3 5 9 11 10 12<br>(请注意，node环境下的事件监听依赖libuv与前端环境不完全相同，输出顺序可能会有误差)</p><p>参考文章：<br><a href="https://juejin.im/post/5b498d245188251b193d4059" target="_blank" rel="noopener">JS事件循环机制（event loop）之宏任务/微任务</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;js 是单线程执行的，js中的任务按顺序一个一个的执行，但是一个任务耗时太长，那么后面的任务就需要等待，为了解决这种情况，将任务分为了同步任务和异步任务，而异步任务又可以分为微任务和宏任务。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;首先第一段示例代码&lt;br&gt;&lt;figure class=&quot;highlight lua&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;console.&lt;span class=&quot;built_in&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&#39;script start&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;setTimeout(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  console.&lt;span class=&quot;built_in&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&#39;setTimeout&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Promise.resolve().&lt;span class=&quot;keyword&quot;&gt;then&lt;/span&gt;(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  console.&lt;span class=&quot;built_in&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&#39;promise1&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;).&lt;span class=&quot;keyword&quot;&gt;then&lt;/span&gt;(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  console.&lt;span class=&quot;built_in&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&#39;promise2&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;console.&lt;span class=&quot;built_in&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&#39;script end&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="js" scheme="http://shenweini.cn/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>对 js 中的this 的理解</title>
    <link href="http://shenweini.cn/2019/07/25/%E5%AF%B9%20js%20%E4%B8%AD%20this%20%E6%8C%87%E5%90%91%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <id>http://shenweini.cn/2019/07/25/对 js 中 this 指向的理解/</id>
    <published>2019-07-25T14:11:00.364Z</published>
    <updated>2019-08-03T14:21:36.841Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>this 指针一直都是一个很玄学的东西，它是函数运行时，函数内部自动生成的对象，只能在函数体内部使用。一下示例都是测试过的，对于答案请放心。如有疑问欢迎评论</p></blockquote><a id="more"></a><h2 id="纯粹的函数调用"><a href="#纯粹的函数调用" class="headerlink" title="纯粹的函数调用"></a>纯粹的函数调用</h2><blockquote><p>这是函数通常的用法，属于全局性的调用，所以this指向全局。</p></blockquote><p>最简单的示例<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="keyword">this</span>.x);</span><br><span class="line">&#125;</span><br><span class="line">test();  <span class="comment">// 1</span></span><br></pre></td></tr></table></figure></p><h2 id="作为对象的一个属性"><a href="#作为对象的一个属性" class="headerlink" title="作为对象的一个属性"></a>作为对象的一个属性</h2><blockquote><p>此时，谁调用这个函数，函数内部的this就指向谁</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">'window'</span>;</span><br><span class="line"><span class="keyword">var</span> test = &#123;</span><br><span class="line">    name: <span class="string">'test'</span>,</span><br><span class="line">    getName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">test.getName(); <span class="comment">// test</span></span><br></pre></td></tr></table></figure><h2 id="作为构造函数的一个属性"><a href="#作为构造函数的一个属性" class="headerlink" title="作为构造函数的一个属性"></a>作为构造函数的一个属性</h2><blockquote><p>this指向当前实例</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">'window'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">'test'</span>;</span><br><span class="line">    <span class="keyword">this</span>.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> test = <span class="keyword">new</span> Test();</span><br><span class="line">test.getName(); <span class="comment">// test</span></span><br></pre></td></tr></table></figure><h2 id="call、apply、bind修改this指向"><a href="#call、apply、bind修改this指向" class="headerlink" title="call、apply、bind修改this指向"></a>call、apply、bind修改this指向</h2><p>使用call 和 apply 方法可以修改this的指向，两者的区别为：</p><blockquote><p>call this后面的参数为一个参数列表<br>apply this后面的参数为一个数组<br>bind bind绑定返回一个新的函数，bind的中this后面的参数是预先添加到绑定函数的参数列表中的参数。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> test = &#123;</span><br><span class="line">    name: <span class="string">'test'</span>,</span><br><span class="line">    getName: <span class="function"><span class="keyword">function</span>(<span class="params">extraParam1, extraParam2</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name, extraParam1, extraParam2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> testCall = &#123;</span><br><span class="line">    name: <span class="string">'testCall'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test.getName.call(testCall,<span class="string">'extraParam1'</span>,<span class="string">'extraParam2'</span>);</span><br><span class="line"><span class="comment">// testCall extraParam1 extraParam2</span></span><br></pre></td></tr></table></figure><p>这边可以看到打印出的时testCall对象的name属性，并且call方法后面携带的是一个参数列表</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> test = &#123;</span><br><span class="line">    name: <span class="string">'test'</span>,</span><br><span class="line">    getName: <span class="function"><span class="keyword">function</span>(<span class="params">extraParam1, extraParam2</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name, extraParam1, extraParam2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> testApply = &#123;</span><br><span class="line">    name: <span class="string">'testApply'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test.getName.apply(testApply,[<span class="string">'extraParam1'</span>,<span class="string">'extraParam2'</span>]);</span><br><span class="line"><span class="comment">// testApply extraParam1 extraParam2</span></span><br></pre></td></tr></table></figure><p>apply的参数为一个参数数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> test = &#123;</span><br><span class="line">    name: <span class="string">'test'</span>,</span><br><span class="line">    getName: <span class="function"><span class="keyword">function</span>(<span class="params">extraParam1, extraParam2</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name, extraParam1, extraParam2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> testBind = &#123;</span><br><span class="line">    name: <span class="string">'testBind'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> getNameBind = test.getName.bind(testBind,<span class="string">'前置参数'</span>);</span><br><span class="line">getNameBind(<span class="string">'extraParam1'</span>); <span class="comment">// testBind 前置参数 extraParam1</span></span><br><span class="line">test.getName(<span class="string">'extraParam1'</span>,<span class="string">'extraParam2'</span>); <span class="comment">// test extraParam1 extraParam2</span></span><br></pre></td></tr></table></figure><p>bind返回一个新的函数</p><h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><blockquote><p>箭头函数本身并不具备this对象，内部的this对象是继承父级作用域中的this,且箭头函数的this不可使用call、apply修改指向，但是可以通过修改父级的this来实现。简单来说要想知道箭头函数的this，需要查看箭头函数的定义位置，而不是调用位置。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.name = <span class="string">'window'</span>;</span><br><span class="line"><span class="keyword">var</span> test = &#123;</span><br><span class="line">    name: <span class="string">'getName'</span>,</span><br><span class="line">    getName: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> testCall = &#123;</span><br><span class="line">    name: <span class="string">'testCall'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> testApply = &#123;</span><br><span class="line">    name: <span class="string">'testApply'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> testBind = &#123;</span><br><span class="line">    name: <span class="string">'testBind'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test.getName(); <span class="comment">// window</span></span><br><span class="line">test.getName.call(testCall); <span class="comment">// window</span></span><br><span class="line">test.getName.apply(testApply); <span class="comment">// window</span></span><br><span class="line">test.getName.bind(testBind)(); <span class="comment">// window</span></span><br></pre></td></tr></table></figure><p>箭头函数定义在 test 对象的内部，test的作用域为全局作用域，所以，getName函数中的this指向的是全局，与调用位置无关。且无法通过call apply bind 直接修改this指向。然后在看下一个示例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.name = <span class="string">'window'</span>;</span><br><span class="line"><span class="keyword">var</span> test = &#123;</span><br><span class="line">    name: <span class="string">'test'</span>,</span><br><span class="line">    getName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> testCall = &#123;</span><br><span class="line">    name: <span class="string">'testCall'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> testApply = &#123;</span><br><span class="line">    name: <span class="string">'testApply'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> testBind = &#123;</span><br><span class="line">    name: <span class="string">'testBind'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test.getName()(); <span class="comment">// test</span></span><br><span class="line">test.getName.call(testCall)(); <span class="comment">// testCall</span></span><br><span class="line">test.getName.apply(testApply)(); <span class="comment">// testApply</span></span><br><span class="line">test.getName.bind(testBind)()(); <span class="comment">// testBind</span></span><br></pre></td></tr></table></figure><p>getName函数返回一个箭头函数，所以初始时箭头函数的父级作用域为getName函数的内部作用域，所以此时this指向应该是看谁调用getName就指向谁。既然如此的话，那我们就可以通过call、apply、bind来修改getName的this指向从而改变箭头函数的this指向。</p><p>说完以上几种情况，下面看两个综合题<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">'window'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = &#123;</span><br><span class="line">    name: <span class="string">'person1'</span>,</span><br><span class="line">    show1: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">    &#125;,</span><br><span class="line">    show2: <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="keyword">this</span>.name),</span><br><span class="line">    show3: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    show4: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person2 = &#123; <span class="attr">name</span>: <span class="string">'person2'</span> &#125;</span><br><span class="line"></span><br><span class="line">person1.show1() <span class="comment">// person1</span></span><br><span class="line">person1.show1.call(person2) <span class="comment">// person2</span></span><br><span class="line"></span><br><span class="line">person1.show2() <span class="comment">// window</span></span><br><span class="line">person1.show2.call(person2) <span class="comment">// window</span></span><br><span class="line"></span><br><span class="line">person1.show3()() <span class="comment">// window</span></span><br><span class="line">person1.show3().call(person2) <span class="comment">// person2</span></span><br><span class="line">person1.show3.call(person2)() <span class="comment">// window</span></span><br><span class="line"></span><br><span class="line">person1.show4()() <span class="comment">// person1</span></span><br><span class="line">person1.show4().call(person2) <span class="comment">// person1</span></span><br><span class="line">person1.show4.call(person2)() <span class="comment">// person2</span></span><br></pre></td></tr></table></figure></p><p>第 20 行：show1为普通函数，this指向调用对象，这边是person1调用，所以指向person1</p><p>第 21 行：使用call将show1函数的指针指向person2</p><p>第 23 行：show2函数为箭头函数，父级作用域为person1作用域即全局作用域，所以this指向window</p><p>地 24 行：箭头函数的this指向在定义时就已经确定。不随着call进行修改，所以此处this依旧是指向window</p><p>第 26 行：show3 返回一个函数，然后调用这个返回的函数，此行等价于<br><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let show<span class="number">3</span> = perso<span class="symbol">n1</span>.show<span class="number">3</span><span class="comment">()</span>; </span><br><span class="line">show<span class="number">3</span><span class="comment">()</span></span><br></pre></td></tr></table></figure></p><p>属于第一种情况，函数的直接调用，this指向全局</p><p>第 27 行：使用call将show3函数返回的函数的this指向了person2，等价与于<br><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let show<span class="number">3</span> = perso<span class="symbol">n1</span>.show<span class="number">3</span><span class="comment">()</span>;</span><br><span class="line">show<span class="number">3.</span><span class="keyword">call</span><span class="comment">(person2)</span>;</span><br></pre></td></tr></table></figure></p><p>第 28 行：和第 26 行道理一样，等价于<br><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let show<span class="number">3</span> = perso<span class="symbol">n1</span>.show<span class="number">3.</span><span class="keyword">call</span><span class="comment">(person2)</span>;</span><br><span class="line">show<span class="number">3</span><span class="comment">()</span>;</span><br></pre></td></tr></table></figure></p><p>函数直接调用，this指向全局</p><p>第 30 行：show4返回的是一个箭头函数，箭头函数的this是继承的父级函数show4的this，所以此处箭头函数的this取决于show4的this指向，此处使用person1进行调用，所以shoe4的this指向person1</p><p>第 31 行：show4返回的是一个箭头函数，箭头函数的this不会被call改变，依旧时取决于父级的show4函数的this，此处person1进行调用，所以依旧是指向的this</p><p>第 32 行：修改了show4函数的this指向，指向了person2，由于上面说的，此处箭头函数的this是取决于show4的，所以箭头函数的this也指向了person2。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">'window'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.show1 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.show2 = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">    <span class="keyword">this</span>.show3 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.show4 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> personA = <span class="keyword">new</span> Person(<span class="string">'personA'</span>)</span><br><span class="line"><span class="keyword">var</span> personB = <span class="keyword">new</span> Person(<span class="string">'personB'</span>)</span><br><span class="line"></span><br><span class="line">personA.show1() <span class="comment">// personA</span></span><br><span class="line">personA.show1.call(personB) <span class="comment">// personB</span></span><br><span class="line"></span><br><span class="line">personA.show2() <span class="comment">// personA</span></span><br><span class="line">personA.show2.call(personB) <span class="comment">// personA</span></span><br><span class="line"></span><br><span class="line">personA.show3()() <span class="comment">// window</span></span><br><span class="line">personA.show3().call(personB) <span class="comment">// personB</span></span><br><span class="line">personA.show3.call(personB)() <span class="comment">// window</span></span><br><span class="line"></span><br><span class="line">personA.show4()() <span class="comment">// personA</span></span><br><span class="line">personA.show4().call(personB) <span class="comment">// personA</span></span><br><span class="line">personA.show4.call(personB)() <span class="comment">// personB</span></span><br></pre></td></tr></table></figure><p>此题是一个构造函数，并且示例化出两个对象，personA 和 personB。<br>第 22 行：构造函数实例的对象调用函数，函数this指向调用对象，所以此处是指向了personA</p><p>第 23 行：show1函数的this被call修改，指向 personB</p><p>第 25 行：show2 为一个箭头函数，this指向父级作用域，此处也就是构造函数内部，取决于调用对象，此处是personA进行调用，所以this指向了personA</p><p>第 26 行：箭头函数的this指向不会被call修改，所以依旧是指向personA</p><p>第 28 行：show3 返回一个函数，属于全局调用，this指向全局，等价于<br><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let show3 = personA.show3()<span class="comment">;</span></span><br><span class="line">show3()<span class="comment">;</span></span><br></pre></td></tr></table></figure></p><p>第 29 行：等价于<br><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let show3 = personA.show3()<span class="comment">;</span></span><br><span class="line">show3.call(personB)<span class="comment">;</span></span><br></pre></td></tr></table></figure></p><p>第 30 行：等价于<br><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let show3 = personA.show3.call(personB)<span class="comment">;</span></span><br><span class="line">show3()<span class="comment">;</span></span><br></pre></td></tr></table></figure></p><p>第 32 行：show4 返回一个箭头函数，取决于show4的调用者，此处为 personA</p><p>第 33 行：箭头函数的this不会被call修改，此处依旧取决于 show4 的调用者，指向 personA</p><p>第 34 行：修改 show4 的this指向，而箭头函数的this取决于show4 所以此处this指向了 personB</p><p>以上为对js中this指向的阐述。得出结论：代码 === 玄学</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;this 指针一直都是一个很玄学的东西，它是函数运行时，函数内部自动生成的对象，只能在函数体内部使用。一下示例都是测试过的，对于答案请放心。如有疑问欢迎评论&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="js" scheme="http://shenweini.cn/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>js 变量提升和作用域的理解</title>
    <link href="http://shenweini.cn/2019/07/25/js%20%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87%E5%92%8C%E4%BD%9C%E7%94%A8%E5%9F%9F%E7%9A%84i%E7%90%86%E8%A7%A3/"/>
    <id>http://shenweini.cn/2019/07/25/js 变量提升和作用域的i理解/</id>
    <published>2019-07-25T06:45:29.270Z</published>
    <updated>2019-08-03T14:22:39.969Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>js 中的变量提升大体可以分为两种，一种是使用 var 声明的变量，另一种是函数的变量提升，而函数的创建可以分为函数声明和函数表达式两种，这两种具有不同的变量提升，以下为本人根据自己的理解参考其他博主的博客得出的看法，如有错误欢迎指正。</p></blockquote><h2 id="使用var声明的变量"><a href="#使用var声明的变量" class="headerlink" title="使用var声明的变量"></a>使用var声明的变量</h2><p>我们首先先看一段代码，<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">scopeTest</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(test); <span class="comment">// undefined</span></span><br><span class="line">    <span class="keyword">var</span> test = <span class="string">'hello'</span>;</span><br><span class="line">&#125;</span><br><span class="line">scopeTest();</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>以上代码输出的结果是 <code>undefined</code>，原因是 js 对于使用var声明的变量具有变量提升的特性，函数内部会首先声明函数内部需要的变量并赋值为undefined。以上代码等价于<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">scopeTest</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> test;</span><br><span class="line">    <span class="built_in">console</span>.log(test);</span><br><span class="line">    test = <span class="string">'hello'</span>;</span><br><span class="line">&#125;</span><br><span class="line">scopeTest();</span><br></pre></td></tr></table></figure></p><blockquote><p>没有使用var声明的会变成全局变量<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> test = <span class="string">'hello'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">scopeTest</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(test) <span class="comment">// hello</span></span><br><span class="line">    test = <span class="string">'helloworld'</span>;</span><br><span class="line">&#125;</span><br><span class="line">scopeTest();</span><br><span class="line"><span class="built_in">console</span>.log(test); <span class="comment">// helloworld</span></span><br></pre></td></tr></table></figure></p></blockquote><p>函数中的 test 变量没有使用var进行声明，所以并不具备变量提升，此时打印，打印的是上层作用域的test即 hello，由于 test 是直接声明的，那么 test 会成为全局变量，覆盖掉已经有的 test ，所以为函数执行完打印 test 输出的是 helloworld</p><h2 id="函数提升"><a href="#函数提升" class="headerlink" title="函数提升"></a>函数提升</h2><blockquote><p>函数的创建分为两种，一种是使用function加函数名进行声明，另一中将函数赋值给变量</p></blockquote><p>首先看第一种，声明方式如下<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a=<span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a); <span class="comment">//[Function: a]</span></span><br><span class="line">    a=<span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure></p><p>这边我们可以看到最后打印的出的 a 是 1 而不是函数里赋值的10，原因是函数具有变量提升的特性，以上代码等价于<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a=<span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123; &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(a); <span class="comment">//[Function: a]</span></span><br><span class="line">    a=<span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure></p><p>函数内部首先声明 function a 此时函数内部的 a 为function类型，此时打印 a 可以看出是一个function 接下来 a = 10 将 a 的类型转为 number 并赋值为 10；然后return 函数销毁，函数内部的 a 变量被回收。最后打印的 a 还是全局的 a</p><p>上面是使用 function 进行申明的，下面试一下使用函数表达式的方式进行声明<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a=<span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a); <span class="comment">//undefined</span></span><br><span class="line">    a=<span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure></p><p>这边可以看到第 3 行打印的是 undefined 而不是 function，同样具有变量提升但是两者却不一样，使用函数表达式的方式进行声明函数只会定义变量，函数体和函数内容并不会携带，但是使用function加函数名的方式会将函数名和函数体一起提升到函数的头部。<br>以上代码等价于<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a=<span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a;</span><br><span class="line">    <span class="built_in">console</span>.log(a); <span class="comment">//undefined</span></span><br><span class="line">    a=<span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">    a = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure></p><h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>js 的作用域分为全局作用域和函数作用域，没有块级作用域，说起作用域就得说到作用域链。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> global=<span class="string">'global context'</span>;</span><br><span class="line"><span class="keyword">var</span> inner=<span class="string">'global inner context'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(global); </span><br><span class="line">    <span class="built_in">console</span>.log(inner);</span><br><span class="line">    <span class="keyword">var</span> inner=<span class="string">'inner context'</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(inner);</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure></p><p>第4行：foo 函数内部，首先打印global，由于函数内部没有这个变量，那么会从foo函数的外部作用域开始找这个变量，然后打印。<br>第5行：inner这个变量，由于变量提升，所有函数的头部存在inner变量的定义，打印出undefined<br>第7行：inner变量赋值，打印出 inner context</p><p>与作用域息息相关的是闭包，this指向问题。</p><p>感谢博主的文章<br><a href="https://www.liaoxuefeng.com/wiki/1022910821149312/1023021187855808" target="_blank" rel="noopener">廖雪峰-变量作用域与解构赋值</a><br><a href="https://segmentfault.com/a/1190000000618597" target="_blank" rel="noopener">深入javascript——作用域和闭包</a><br><a href="https://segmentfault.com/a/1190000013656524" target="_blank" rel="noopener">js 变量提升和闭包理解</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;js 中的变量提升大体可以分为两种，一种是使用 var 声明的变量，另一种是函数的变量提升，而函数的创建可以分为函数声明和函数表达式两种，这两种具有不同的变量提升，以下为本人根据自己的理解参考其他博主的博客得出的看法，如有错误欢迎指正。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;使用var声明的变量&quot;&gt;&lt;a href=&quot;#使用var声明的变量&quot; class=&quot;headerlink&quot; title=&quot;使用var声明的变量&quot;&gt;&lt;/a&gt;使用var声明的变量&lt;/h2&gt;&lt;p&gt;我们首先先看一段代码，&lt;br&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;scopeTest&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(test); &lt;span class=&quot;comment&quot;&gt;// undefined&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; test = &lt;span class=&quot;string&quot;&gt;&#39;hello&#39;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;scopeTest();&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="js" scheme="http://shenweini.cn/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>js快排尾递归优化</title>
    <link href="http://shenweini.cn/2019/03/25/js%E5%BF%AB%E6%8E%92%E5%B0%BE%E9%80%92%E5%BD%92%E4%BC%98%E5%8C%96/"/>
    <id>http://shenweini.cn/2019/03/25/js快排尾递归优化/</id>
    <published>2019-03-25T13:09:51.000Z</published>
    <updated>2019-08-03T14:23:05.778Z</updated>
    
    <content type="html"><![CDATA[<p>尾递归是个什么东西这边就不介绍了。总之递归我是一直没有搞明白。但是我知道尾递归是为了解决递归造成的栈溢出和大量重复的计算。</p><a id="more"></a><h2 id="常规版本"><a href="#常规版本" class="headerlink" title="常规版本"></a>常规版本</h2><pre><code>function quickSort(arr, left, right) {    // 递归跳出条件    if (left &gt;= right)        return;    let i = left,        j = right,        flag = arr[left]; // 定义的基准    while (i &lt; j) {        // 找到比flag小的        while (i &lt; j &amp;&amp; arr[j] &gt;= flag)            j--;        // 找到比flag大的        while (i &lt; j &amp;&amp; arr[i] &lt;= flag)            i++;        // 交换i和j        if (i &lt;= j) {            let temp = arr[i];            arr[i] = arr[j];            arr[j] = temp;        }    }    // 交换基准和i    arr[left] = arr[i];    arr[i] = flag;    // 对左边快排    quickSort(arr, left, i - 1);    // 对右边快排    quickSort(arr, i + 1, right);}let testArr = [2, 4, 1, 5, 8, 6, 7, 9, 0];quickSort(testArr, 0, testArr.length - 1);console.log(testArr);</code></pre><h2 id="尾递归版本"><a href="#尾递归版本" class="headerlink" title="尾递归版本"></a>尾递归版本</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tailQuickSort</span><span class="params">(arr, left, right)</span> &#123;</span></span><br><span class="line">    let <span class="built_in">i</span> = left,</span><br><span class="line">        <span class="built_in">j</span> = right,</span><br><span class="line">        flag = arr[left];</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">i</span> &lt; <span class="built_in">j</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">i</span> &lt; <span class="built_in">j</span> &amp;&amp; arr[<span class="built_in">j</span>] &gt;= flag)</span><br><span class="line">            <span class="built_in">j</span>--;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">i</span> &lt; <span class="built_in">j</span> &amp;&amp; arr[<span class="built_in">i</span>] &lt;= flag)</span><br><span class="line">            <span class="built_in">i</span>++;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">i</span> &lt; <span class="built_in">j</span>) &#123;</span><br><span class="line">            let temp = arr[<span class="built_in">i</span>];</span><br><span class="line">            arr[<span class="built_in">i</span>] = arr[<span class="built_in">j</span>];</span><br><span class="line">            arr[<span class="built_in">j</span>] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    arr[left] = arr[<span class="built_in">i</span>];</span><br><span class="line">    arr[<span class="built_in">i</span>] = flag;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">i</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">quickSort</span><span class="params">(arr, left, right)</span> &#123;</span></span><br><span class="line">    let pivot = left;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        pivot = tailQuickSort(arr, left, right);</span><br><span class="line">        quickSort(arr, left, pivot - <span class="number">1</span>);</span><br><span class="line">        left = pivot + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let testArray = [<span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">4</span>];</span><br><span class="line">quickSort(testArray, <span class="number">0</span>, testArray.<span class="built_in">length</span> - <span class="number">1</span>);</span><br><span class="line">console.<span class="built_in">log</span>(testArray);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;尾递归是个什么东西这边就不介绍了。总之递归我是一直没有搞明白。但是我知道尾递归是为了解决递归造成的栈溢出和大量重复的计算。&lt;/p&gt;
    
    </summary>
    
    
      <category term="js" scheme="http://shenweini.cn/tags/js/"/>
    
      <category term="算法" scheme="http://shenweini.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>19年前端校招面经</title>
    <link href="http://shenweini.cn/2019/03/25/19%E5%B9%B4%E6%A0%A1%E6%8B%9B%E5%89%8D%E7%AB%AF%E9%9D%A2%E7%BB%8F%EF%BC%88%E9%98%BF%E9%87%8C-%E5%B0%8F%E7%B1%B3-%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8%EF%BC%89/"/>
    <id>http://shenweini.cn/2019/03/25/19年校招前端面经（阿里-小米-字节跳动）/</id>
    <published>2019-03-25T12:47:45.000Z</published>
    <updated>2019-08-03T14:13:51.513Z</updated>
    
    <content type="html"><![CDATA[<p>加个小前提，本人投的是web前端，如果分方向的话，是React方向。<br>俗话说，金三银四，在这充满了刺激的三月，我也拿着我的一页纸的简历投了好几家公司，下面记录着我参加了面试的几家公司以及近期整理出的题目。很尴尬，没有拿到任何一家的offer，经过这几次的面试也发现自己的基础确实很差，打算歇息一阵子好好补一补自己的基础，准备开始秋招或者明年的春招，毕竟我还是很向往大公司的待遇的。不过我也发现了一点，可能学历对于程序员有点影响，但是还是技术比较重要，只要你够牛逼，BAT肯定会向你打开大门，再不济也是磨练几年走社招进。但是个人认为对于考研和找工作动摇不定的还是先尝试一下考研吧，毕竟对于像我这样的不出名的小二本环境还是不咋地，985/211出名不是没有道理的。</p><a id="more"></a><h2 id="阿里前端校招–电话面试"><a href="#阿里前端校招–电话面试" class="headerlink" title="阿里前端校招–电话面试"></a>阿里前端校招–电话面试</h2><p>小生不才，第一轮的电话初试就被刷掉了，所以不清楚阿里的校招这个流程，我也只能提供电话初试的情况了，那天阳光明媚，中午刚下课接到一个电话，一看归属地浙江杭州已经开始梦想进入阿里的场景了，果不其然，约了第二天晚上八点的电话初始，又在情理之中的被刷掉了，历经一个小时，感觉就是这个面试官是真牛逼啊，我是在一个小时之内肚子里的存货被掏的干干净净的。</p><h3 id="1-请求跨域问题"><a href="#1-请求跨域问题" class="headerlink" title="1. 请求跨域问题"></a>1. 请求跨域问题</h3><p>这是前端面试必问题型，我就写几个不一定对，因为我也是搜的我也没经历过跨域。</p><ol><li>jsonp形式，缺点是只能实现get请求，并且对于出现的error不容易调试</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</span></span><br><span class="line"><span class="actionscript">    script.type = <span class="string">'text/javascript'</span>;</span></span><br><span class="line"><span class="actionscript">    script.src = <span class="string">'http://domain2.com:8080/login?user=admin&amp;callback=onBack'</span>;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.head.appendChild(script);</span></span><br><span class="line"><span class="actionscript">    <span class="comment">// 回调执行函数</span></span></span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span> <span class="title">onBack</span><span class="params">(res)</span></span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(res);</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>document.domain  改变两个域的document.domain</li><li>window.name</li><li>postMessage</li><li>CORS 跨域资源共享</li><li>nginx反向代理</li><li>websocket协议跨域</li></ol><h3 id="2-webpack插件、优化、loader"><a href="#2-webpack插件、优化、loader" class="headerlink" title="2. webpack插件、优化、loader"></a>2. webpack插件、优化、loader</h3><h3 id="3-页面性能优化"><a href="#3-页面性能优化" class="headerlink" title="3. 页面性能优化"></a>3. 页面性能优化</h3><ol><li>减少http请求</li><li>使用CDN</li><li>添加Expires头，第一次访问是缓存组件，减少不必要的http请求</li><li>开启压缩gzip可以减少到30%</li><li>样式表放在head表，脚本放最下面</li><li>配置ETAG</li><li>….</li></ol><h3 id="4-原型链相关"><a href="#4-原型链相关" class="headerlink" title="4. 原型链相关"></a>4. 原型链相关</h3><h3 id="5-ES6的新特性了解多少"><a href="#5-ES6的新特性了解多少" class="headerlink" title="5. ES6的新特性了解多少"></a>5. ES6的新特性了解多少</h3><h3 id="6-ES6和commonjs的区别"><a href="#6-ES6和commonjs的区别" class="headerlink" title="6. ES6和commonjs的区别"></a>6. ES6和commonjs的区别</h3><ol><li>es6导出的是值得引用，值的改变引用也改变，commonjs输出的是值的拷贝，值改变不会影响已经导出的变量</li><li>es6中this指向undefined，commonjs指向当前模块</li><li>es6是在解析是加载模块，commonjs是运行时加载</li><li>es6可以单独加载某个函数，commonjs只能加载整个模块</li><li>es6加载的不是对象，commonjs加载的是一个对象</li></ol><h3 id="7-react生命周期"><a href="#7-react生命周期" class="headerlink" title="7. react生命周期"></a>7. react生命周期</h3><p><img src="http://static.zybuluo.com/shenweizheng/0lh7kggg8topfqk2grc9717w/TIM%E6%88%AA%E5%9B%BE20190325164720.png" alt="TIM截图20190325164720.png-258.9kB"></p><h3 id="8-react优化"><a href="#8-react优化" class="headerlink" title="8. react优化"></a>8. react优化</h3><ol><li>shouldComponentUpdate这边做操作，判断是否进行render</li><li>尽量不适应组件state使用mobx或者其他代替</li><li>。。。</li></ol><h3 id="9-为什么使用mobx而不是使用原生的setState"><a href="#9-为什么使用mobx而不是使用原生的setState" class="headerlink" title="9. 为什么使用mobx而不是使用原生的setState"></a>9. 为什么使用mobx而不是使用原生的setState</h3><ol><li>setState是异步的，渲染时可能会出现错误</li><li>setState会造成不必要的渲染，mobx可以不把变量设置为可观察变量</li><li>setState不可能管理所有的状态，父子组件很多的时候会很乱</li><li>使得jsx的职责变得更单一</li></ol><h3 id="10-setState是批处理吗"><a href="#10-setState是批处理吗" class="headerlink" title="10. setState是批处理吗"></a>10. setState是批处理吗</h3><p>是批处理，如果render里面有多个setState时会一起进行setState</p><h3 id="11-说一说flex布局"><a href="#11-说一说flex布局" class="headerlink" title="11. 说一说flex布局"></a>11. 说一说flex布局</h3><h3 id="12-说一说冒泡机制"><a href="#12-说一说冒泡机制" class="headerlink" title="12. 说一说冒泡机制"></a>12. 说一说冒泡机制</h3><p>从上到下捕获到冒泡，从下往上冒泡<br>最上面是window</p><h3 id="13-浏览器已经定义好的对象有哪些"><a href="#13-浏览器已经定义好的对象有哪些" class="headerlink" title="13. 浏览器已经定义好的对象有哪些"></a>13. 浏览器已经定义好的对象有哪些</h3><p>window,screen,location,history,navigator</p><h3 id="14-数组去重-说一说复杂度"><a href="#14-数组去重-说一说复杂度" class="headerlink" title="14. 数组去重,说一说复杂度"></a>14. 数组去重,说一说复杂度</h3><h3 id="15-说一说websocket"><a href="#15-说一说websocket" class="headerlink" title="15. 说一说websocket"></a>15. 说一说websocket</h3><h3 id="16-正则表达式"><a href="#16-正则表达式" class="headerlink" title="16. 正则表达式"></a>16. 正则表达式</h3><h3 id="17-http和https的区别"><a href="#17-http和https的区别" class="headerlink" title="17. http和https的区别"></a>17. http和https的区别</h3><ol><li>http是明文传输，https是使用安全套接字加密的</li><li>http的端口是80 https的端口是443</li><li>https需要到ca申请证书，需要一定的费用</li><li>http的链接很简单没有状态，https的协议是由SSL+http协议构建的加密传输，身份认证的网络协议很安全</li></ol><h3 id="18-http请求常用的状态码"><a href="#18-http请求常用的状态码" class="headerlink" title="18. http请求常用的状态码"></a>18. http请求常用的状态码</h3><ol><li>200 请求成功</li><li>404 请求不存在</li><li>405 请求方式错误</li><li>403 服务器接受了请求但是拒绝响应</li><li>303 请求需要存在另一个url，请使用get请求定向获取请求的资源</li><li>500 服务器发生了一场异常</li></ol><h3 id="19-说一说css3动画"><a href="#19-说一说css3动画" class="headerlink" title="19. 说一说css3动画"></a>19. 说一说css3动画</h3><h3 id="20-canvas画布"><a href="#20-canvas画布" class="headerlink" title="20. canvas画布"></a>20. canvas画布</h3><h3 id="21-http属于哪一层"><a href="#21-http属于哪一层" class="headerlink" title="21. http属于哪一层"></a>21. http属于哪一层</h3><p>应用层</p><h3 id="22-tcp和udp的区别以及使用场景"><a href="#22-tcp和udp的区别以及使用场景" class="headerlink" title="22. tcp和udp的区别以及使用场景"></a>22. tcp和udp的区别以及使用场景</h3><ol><li>tcp面向连接的可靠传输，udp面向无连接不可靠</li><li>tcp面向字节流，udp面向报文</li><li>tcp是一对一的通信，udp可以一对一也可以一对多也可以多对多通信</li><li>tcp的建立需要经历三次握手四次挥手</li><li>tcp适用于文件传输，发送邮件</li><li>udp适用于即时通信，在线视频</li></ol><h3 id="23-讲一讲计算机网络的七层模型"><a href="#23-讲一讲计算机网络的七层模型" class="headerlink" title="23. 讲一讲计算机网络的七层模型"></a>23. 讲一讲计算机网络的七层模型</h3><p>物理层、数据链路层、传输层、网络层、应用层、会话层、表示层</p><h3 id="24-讲一讲闭包"><a href="#24-讲一讲闭包" class="headerlink" title="24. 讲一讲闭包"></a>24. 讲一讲闭包</h3><p>函数内部可以读取函数外部的变量，直白的说就是函数包函数<br>可以保存局部变量并且不会污染全局环境，缺点是会加大内存的负担</p><h3 id="25-箭头函数和普通函数的区别"><a href="#25-箭头函数和普通函数的区别" class="headerlink" title="25. 箭头函数和普通函数的区别"></a>25. 箭头函数和普通函数的区别</h3><ol><li>this作用域的区别，箭头函数是函数自身，普通函数是函数所在的上下文</li><li>函数作用于提升的区别，箭头函数需要将函数赋值给一个var变量才能提升他的作用域</li><li>构造函数的问题，箭头函数是匿名函数不可以作为构造函数不可以new</li></ol><h3 id="26-如何提升函数的作作用域"><a href="#26-如何提升函数的作作用域" class="headerlink" title="26. 如何提升函数的作作用域"></a>26. 如何提升函数的作作用域</h3><p>call，apply，bind</p><h3 id="27-call和apply的区别"><a href="#27-call和apply的区别" class="headerlink" title="27. call和apply的区别"></a>27. call和apply的区别</h3><p>第二个参数的区别，apply的第二个参数是一个数组，call是一个一个参数的往后加</p><h3 id="28-es5的继承是如何实现的"><a href="#28-es5的继承是如何实现的" class="headerlink" title="28. es5的继承是如何实现的"></a>28. es5的继承是如何实现的</h3><p>利用prototype实现</p><pre><code>function Dog{    this.name = &apos;dog&apos;;};function Animal{    this.speak = function(){        console.log(&apos;二哈&apos;);    }};Dog.prototype = new Animal();dog = new Dog();dog.speak();</code></pre><h3 id="29-XSS攻击"><a href="#29-XSS攻击" class="headerlink" title="29. XSS攻击"></a>29. XSS攻击</h3><ol><li>XSS攻击分为反射型，存储型，DOM型</li><li>反射型XSS是在将XSS代码放在URL中，将参数提交到服务器。服务器解析后响应，在响应结果中存在XSS代码，最终通过浏览器解析执行</li><li>存储型XSS是将XSS代码存储到服务端（数据库、内存、文件系统等），在下次请求同一个页面时就不需要带上XSS代码了，而是从服务器读取</li><li>DOM XSS的发生主要是在JS中使用eval造成的，所以应当避免使用eval语句</li><li>XSS危害有盗取用户cookie，通过JS或CSS改变样式，Dom造成正常用户无法得到服务器响应<br>预防：</li><li>对cookie进行保护 对cookie设置httpOnly</li><li>对用户输入的数据进行编码、解码、过滤</li></ol><h3 id="30-jsx为什么叫jsx-类名为什么大写"><a href="#30-jsx为什么叫jsx-类名为什么大写" class="headerlink" title="30. jsx为什么叫jsx 类名为什么大写"></a>30. jsx为什么叫jsx 类名为什么大写</h3><p>jsx也叫javascript XML</p><h3 id="31-如何获取到dom里面的某个节点"><a href="#31-如何获取到dom里面的某个节点" class="headerlink" title="31. 如何获取到dom里面的某个节点"></a>31. 如何获取到dom里面的某个节点</h3><p>各种dom操作，querySelector等</p><h3 id="32-absolute是对哪个点开始计算的"><a href="#32-absolute是对哪个点开始计算的" class="headerlink" title="32. absolute是对哪个点开始计算的"></a>32. absolute是对哪个点开始计算的</h3><ol><li>外层有relative定义时相对于relative定位</li><li>外层没有时根据body定位</li></ol><h3 id="33-原生js发送请求"><a href="#33-原生js发送请求" class="headerlink" title="33. 原生js发送请求"></a>33. 原生js发送请求</h3><pre><code>// 定义一个XMLHttpRequest变量var xhr = new XMLHttpRequest();// 要发送的请求urlxhr.open(&apos;post&apos;,&apos;/api/login&apos;);// 对于post请求要设置请求头xhr.setRequestHeader(&apos;Content-type&apos;,&apos;application/x-www-form-urlencoded&apos;);// 发送请求xhr.send(&apos;account=admin&amp;password=123456);// 监听状态改变xhr.onreadystatechange = function(){    if(xhr.readyState === 4 &amp;&amp; xhr.status === 200){        console.log(&apos;success&apos;);    }}</code></pre><h2 id="小米电话面试"><a href="#小米电话面试" class="headerlink" title="小米电话面试"></a>小米电话面试</h2><h3 id="1-css常用选择器按照优先级说"><a href="#1-css常用选择器按照优先级说" class="headerlink" title="1. css常用选择器按照优先级说"></a>1. css常用选择器按照优先级说</h3><h3 id="2-css常用水平居中"><a href="#2-css常用水平居中" class="headerlink" title="2. css常用水平居中"></a>2. css常用水平居中</h3><h3 id="3-css垂直居中"><a href="#3-css垂直居中" class="headerlink" title="3. css垂直居中"></a>3. css垂直居中</h3><h3 id="4-css实现图片等比例缩放"><a href="#4-css实现图片等比例缩放" class="headerlink" title="4. css实现图片等比例缩放"></a>4. css实现图片等比例缩放</h3><h3 id="5-讲一讲flex布局"><a href="#5-讲一讲flex布局" class="headerlink" title="5. 讲一讲flex布局"></a>5. 讲一讲flex布局</h3><h3 id="6-css行内元素和块级元素的区别"><a href="#6-css行内元素和块级元素的区别" class="headerlink" title="6. css行内元素和块级元素的区别"></a>6. css行内元素和块级元素的区别</h3><h3 id="7-讲一讲原型链"><a href="#7-讲一讲原型链" class="headerlink" title="7. 讲一讲原型链"></a>7. 讲一讲原型链</h3><h3 id="8-箭头函数和普通函数的区别"><a href="#8-箭头函数和普通函数的区别" class="headerlink" title="8. 箭头函数和普通函数的区别"></a>8. 箭头函数和普通函数的区别</h3><h3 id="9-webpack的插件都用过哪些，都是干嘛用的"><a href="#9-webpack的插件都用过哪些，都是干嘛用的" class="headerlink" title="9. webpack的插件都用过哪些，都是干嘛用的"></a>9. webpack的插件都用过哪些，都是干嘛用的</h3><h2 id="字节跳动"><a href="#字节跳动" class="headerlink" title="字节跳动"></a>字节跳动</h2><p>字节跳动对算法是有点要求的公司，所以很不幸的在最后一轮面试被刷了，想要投字节跳动的同学介意多刷一刷牛客网上的算法题。各种排序，查找，递归。很不幸我就是不会递归最后一轮才被刷了。</p><h3 id="笔试"><a href="#笔试" class="headerlink" title="笔试"></a>笔试</h3><p>我的笔试是两个小时直接四道算法题，前两道还是很简单的，基本的循环就都可以解出来没什么难度，后两题是有点意思了，我是花了一个多小时没写的出来。后两道应该是用动态规划就做出来了。<br>我是两题满分两题零分拿到了面试的机会，我本人也是不敢相信的。貌似是作对两题就可以拿到面试机会。<br>接下来是视频面试，最多三轮，过了一轮会发短信告诉你这一轮有没有过，中间可以休息半个小时左右。三轮都是技术面。个人感觉前两面虽然有的没答得出来但是面试官人还是很好的都给过了。</p><h3 id="视频一面"><a href="#视频一面" class="headerlink" title="视频一面"></a>视频一面</h3><p>一面是一个小姐姐，但是这个小姐姐尽然比我还要紧张。瞬间就搞得我更紧张了。互道你好之后，开始聊聊之前做过的项目，都用了哪些技术栈，为什么选这种技术栈。一面全程半个小时。</p><ol><li>箭头函数和普通函数的区别</li><li>mobx和redux的区别，为什么选用mobx</li><li>单向数据流和双向绑定的理解</li><li>浏览器从输入网址到页面渲染完成中间都发生了什么</li><li>正则表达式</li><li>webpack都用过哪些插件</li><li>了解promise吧，用过promise.all吧 ，来，模拟一下promise.all的过程（。。直接给我整蒙了）</li><li><p>经典的闭包问题</p><p> for(var i = 0;i &lt; 10;i++){</p><pre><code>console.log(i);</code></pre><p> }<br>最后输出的是什么，改写成我们需要的样子</p><p> for(var i = 0;i &lt; 10;i++){</p><pre><code>(function(i){    console.log(i)})(i)</code></pre><p> }</p><h3 id="视频二面"><a href="#视频二面" class="headerlink" title="视频二面"></a>视频二面</h3><p>二面是一个小哥哥，目测发际线有点厉害，是我以后的模样。小哥哥人还是很好的，我没答得上的还和我讲了一遍，最好告诉我我的基础哪里有薄弱。</p></li><li>自我介绍</li><li>stage-0 -1 的区别</li><li>经典的闭包问题，以及闭包改写，其中有一个微任务和宏任务的概念</li><li>函数作用域提示问题，一串代码问我输出是什么，代码记不住了，但是我知道的是这是我看不懂的操作。不过大致就是靠变量提示的。</li><li>一道编程题，给定一个字符串，找出里面出现最多的字符并输出对应的字符和出现次数</li><li>给一张二叉树的图，口述前序中序后序遍历的过程</li><li>说一说tcp和Udp的区别，以及各自的使用场景</li></ol><h3 id="视屏三面"><a href="#视屏三面" class="headerlink" title="视屏三面"></a>视屏三面</h3><p>好吧，这一轮不说多少，两道算法题，有点后悔要是之前搞懂了递归也不会被刷。</p><ol><li><p>第一道题</p><pre><code>const vDom = {    tag: &apos;div&apos;,    props: {&apos;a&apos;: &apos;b&apos;},    children: [        {            tag: &apos;span&apos;,            props: {},            children: []        },{            tag: &apos;span&apos;,            props: {},            children: []        }    ]}// 将这个json组成一个节点&lt;div a=&apos;b&apos;&gt;    &lt;span&gt;&lt;/span&gt;    &lt;span&gt;&lt;/span&gt;&lt;/div&gt;// 递归求解</code></pre></li><li><p>数组旋转</p><p> const image = [</p><pre><code>[1,2,3,4,10],[5,6,7,8,9],[11,12,13,14,15]</code></pre><p> ]<br> // 顺时针旋转九十度<br>这题还是很简单的，刷一下就写完了，刷的一个就收到了你的面试未通过的短信，刷的一下offer就飞了。就是这么快。</p></li></ol><h2 id="以下是在准备面试时收集到的其他人的经验，不全"><a href="#以下是在准备面试时收集到的其他人的经验，不全" class="headerlink" title="以下是在准备面试时收集到的其他人的经验，不全"></a>以下是在准备面试时收集到的其他人的经验，不全</h2><h3 id="1-new一个对象的过程发生了什么"><a href="#1-new一个对象的过程发生了什么" class="headerlink" title="1. new一个对象的过程发生了什么"></a>1. new一个对象的过程发生了什么</h3><ol><li>创建一个新对象，如：var person = {};</li><li>新对象的proto属性指向构造函数的原型对象。</li><li>将构造函数的作用域赋值给新对象。（也所以this对象指向新对象）</li><li>执行构造函数内部的代码，将属性添加给person中的this对象。</li><li>返回新对象person。</li></ol><h3 id="2-visibilty-和-display：none的区别"><a href="#2-visibilty-和-display：none的区别" class="headerlink" title="2. visibilty 和 display：none的区别"></a>2. visibilty 和 display：none的区别</h3><p>visibility隐藏是还是会占据原来的位置<br>但是display：none不会占据原来的位置</p><h3 id="3-js的基本数据类型"><a href="#3-js的基本数据类型" class="headerlink" title="3. js的基本数据类型"></a>3. js的基本数据类型</h3><p>null,underfined,number,string,boolean,object</p><h3 id="4-typeof和intanceof的区别"><a href="#4-typeof和intanceof的区别" class="headerlink" title="4. typeof和intanceof的区别"></a>4. typeof和intanceof的区别</h3><p>typeof返回一个字符串，说明匹配对象的类型，返回值有string，number，boolean，object，underfined，function<br>局限性：对于Array类型和null typeof一致都返回object</p><p>intanceof判断一个对象的原型链中是否存在一个构造函数的prototype</p><h3 id="5-函数的arguments是不是一个数组"><a href="#5-函数的arguments是不是一个数组" class="headerlink" title="5. 函数的arguments是不是一个数组"></a>5. 函数的arguments是不是一个数组</h3><p>不是,arguments是一个类数组对象，可以打印看一下，包含了函数所有的参数</p><h3 id="6-let-var-const-的区别"><a href="#6-let-var-const-的区别" class="headerlink" title="6. let var const 的区别"></a>6. let var const 的区别</h3><ol><li>const 表示常量，一旦定义不可修改，且必须初始化</li><li>var的作用于为全文上下，可以重复定义，</li><li>let是快级作用域，不可重复定义</li></ol><h3 id="7-promise的原理及实现"><a href="#7-promise的原理及实现" class="headerlink" title="7. promise的原理及实现"></a>7. promise的原理及实现</h3><h3 id="8-git相关操作，git-merge-和rebase的区别"><a href="#8-git相关操作，git-merge-和rebase的区别" class="headerlink" title="8. git相关操作，git merge 和rebase的区别"></a>8. git相关操作，git merge 和rebase的区别</h3><ul><li>get merge 之后解决冲突需要执行 git add . git commit -m’fix conflict’ 会多出一个commit </li><li>git rebase 之后执行 git add .和git rebase –continue 不会产生额外的commit这样会干净，不会产生无意义的commit</li></ul><h3 id="9-Es5新增的map-filter-reduce"><a href="#9-Es5新增的map-filter-reduce" class="headerlink" title="9. Es5新增的map filter reduce"></a>9. Es5新增的map filter reduce</h3><ul><li>map 遍历不会改变原数组 </li><li>filter 过滤不会改变原数组，会返回一个新数组 </li><li>reduce 函数值累加</li></ul><h3 id="10-js中的微任务和宏任务"><a href="#10-js中的微任务和宏任务" class="headerlink" title="10. js中的微任务和宏任务"></a>10. js中的微任务和宏任务</h3><h3 id="11-arguments是什么，转数组有哪些方法"><a href="#11-arguments是什么，转数组有哪些方法" class="headerlink" title="11. arguments是什么，转数组有哪些方法"></a>11. arguments是什么，转数组有哪些方法</h3><p>类数组对象，</p><ul><li>[…arguments]</li><li>Array.prototye.slice.apply(arguments)</li><li>Array.from(arguments)</li></ul><h3 id="12-cookie-session的关系区别"><a href="#12-cookie-session的关系区别" class="headerlink" title="12. cookie session的关系区别"></a>12. cookie session的关系区别</h3><h3 id="13-cookie-localStorage-sessionStorage之间的区别"><a href="#13-cookie-localStorage-sessionStorage之间的区别" class="headerlink" title="13. cookie localStorage sessionStorage之间的区别"></a>13. cookie localStorage sessionStorage之间的区别</h3><h3 id="14-link和-import之间的区别"><a href="#14-link和-import之间的区别" class="headerlink" title="14. link和@import之间的区别"></a>14. link和@import之间的区别</h3><ol><li>link属于HTML标签，而@import是CSS提供的; </li><li>页面被加载的时，link会同时被加载，而@import引用的CSS会等到页面被加载完再加载; </li><li>import只在IE5以上才能识别，而link是HTML标签，无兼容问题; </li><li>link方式的样式的权重 高于@import的权重.</li></ol><h3 id="15-absolute-和-float"><a href="#15-absolute-和-float" class="headerlink" title="15. absolute 和 float"></a>15. absolute 和 float</h3><p>A：共同点：<br>对内联元素设置float和absolute属性，可以让元素脱离文档流，并且可以设置其宽高。</p><p>B：不同点：<br>float仍会占据位置，position会覆盖文档流中的其他元素。</p><h3 id="16-XML和json的区别"><a href="#16-XML和json的区别" class="headerlink" title="16. XML和json的区别"></a>16. XML和json的区别</h3><ol><li>数据体积方面。<br>JSON相对于XML来讲，数据的体积小，传递的速度更快些。 </li><li>数据交互方面。<br>JSON与JavaScript的交互更加方便，更容易解析处理，更好的数据交互。 </li><li>数据描述方面。<br>JSON对数据的描述性比XML较差。 </li><li>传输速度方面。<br>JSON的速度要远远快于XML。</li></ol><h3 id="17-BFC"><a href="#17-BFC" class="headerlink" title="17. BFC"></a>17. BFC</h3><p>盒模型</p><h3 id="18-HTML语义化的理解"><a href="#18-HTML语义化的理解" class="headerlink" title="18. HTML语义化的理解"></a>18. HTML语义化的理解</h3><h3 id="19-DOCTYPE，严格模式与混杂模式"><a href="#19-DOCTYPE，严格模式与混杂模式" class="headerlink" title="19. DOCTYPE，严格模式与混杂模式"></a>19. DOCTYPE，严格模式与混杂模式</h3><ol><li>声明位于文档中的最前面，处于 标签之前。告知浏览器以何种模式来渲染文档。</li><li>严格模式的排版和 JS 运作模式是 以该浏览器支持的最高标准运行。</li><li>在混杂模式中，页面以宽松的向后兼容的方式显示。模拟老式浏览器的行为以防止站点无法工作</li><li>DOCTYPE不存在或格式不正确会导致文档以混杂模式呈现。</li></ol><h3 id="20-transform-代替-marginLeft-Top的区别"><a href="#20-transform-代替-marginLeft-Top的区别" class="headerlink" title="20. transform 代替 marginLeft/Top的区别"></a>20. transform 代替 marginLeft/Top的区别</h3><p>页面回流没有了</p><h3 id="21-calc计算"><a href="#21-calc计算" class="headerlink" title="21. calc计算"></a>21. calc计算</h3><p>vw表示 宽度的百分比<br>vh表示 高度的百分比</p><h3 id="22-js防抖和节流"><a href="#22-js防抖和节流" class="headerlink" title="22. js防抖和节流"></a>22. js防抖和节流</h3><h3 id="23-栈和堆得区别"><a href="#23-栈和堆得区别" class="headerlink" title="23. 栈和堆得区别"></a>23. 栈和堆得区别</h3><h3 id="24-聊一聊NaN"><a href="#24-聊一聊NaN" class="headerlink" title="24. 聊一聊NaN"></a>24. 聊一聊NaN</h3><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>唯一的体会就是一定要补补自己的基础，大厂很注重基础，看的是一个人的潜力和可塑造性。另外多看看别人的面经，多做好准备我是准备的有点冲忙，因为我总有一种明天就要毕业的既视感，所以很着急找工作，现在放宽心态慢慢来。</p><h2 id="最后忠诚祝愿各位同行能拿到自己心仪的offer，祝各位拿offer拿到手软"><a href="#最后忠诚祝愿各位同行能拿到自己心仪的offer，祝各位拿offer拿到手软" class="headerlink" title="最后忠诚祝愿各位同行能拿到自己心仪的offer，祝各位拿offer拿到手软"></a>最后忠诚祝愿各位同行能拿到自己心仪的offer，祝各位拿offer拿到手软</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;加个小前提，本人投的是web前端，如果分方向的话，是React方向。&lt;br&gt;俗话说，金三银四，在这充满了刺激的三月，我也拿着我的一页纸的简历投了好几家公司，下面记录着我参加了面试的几家公司以及近期整理出的题目。很尴尬，没有拿到任何一家的offer，经过这几次的面试也发现自己的基础确实很差，打算歇息一阵子好好补一补自己的基础，准备开始秋招或者明年的春招，毕竟我还是很向往大公司的待遇的。不过我也发现了一点，可能学历对于程序员有点影响，但是还是技术比较重要，只要你够牛逼，BAT肯定会向你打开大门，再不济也是磨练几年走社招进。但是个人认为对于考研和找工作动摇不定的还是先尝试一下考研吧，毕竟对于像我这样的不出名的小二本环境还是不咋地，985/211出名不是没有道理的。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Git基本操作</title>
    <link href="http://shenweini.cn/2019/01/28/Git%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
    <id>http://shenweini.cn/2019/01/28/Git基本操作/</id>
    <published>2019-01-28T10:07:47.000Z</published>
    <updated>2019-08-03T14:22:24.751Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-查看分支"><a href="#1-查看分支" class="headerlink" title="1.查看分支"></a>1.查看分支</h2><pre><code>git branch 查看本地分支git branch -a 查看所有分支</code></pre><p><img src="http://static.zybuluo.com/shenweizheng/z2noezmkolv3clrzsv3kr3ys/image_1d29tb0vg1bu35spagp1spr1tqr14.png" alt="image_1d29tb0vg1bu35spagp1spr1tqr14.png-3kB"></p><a id="more"></a><p>前面带有 * 号的表示当前分支。</p><pre><code>git branch xxx 添加本地分支git branch -d xxx 删除分支git pull 拉取代码git pull origin xxx 拉取远程分支git push xxx 推送本地分支到远程git merge xxx 合并分支</code></pre><h2 id="2-合并分支"><a href="#2-合并分支" class="headerlink" title="2. 合并分支"></a>2. 合并分支</h2><p>当前分支  A  要合并分支B的代码<br>步骤一：将A分支的代码commit<br>步骤二：切换到B分支  <code>git checkout B</code><br>步骤三：拉取远程代码  <code>git pull</code><br>步骤四：切换回A分支 <code>git checkout A</code><br>步骤五：合并B分支代码 <code>git merge B</code></p><h2 id="3-合并部分文件"><a href="#3-合并部分文件" class="headerlink" title="3. 合并部分文件"></a>3. 合并部分文件</h2><p>当前分支 A  要合并分支文件 B 文件路径 /static/src/apps/login/store/loginStore.js<br>步骤一：将A分支commit<br>步骤二：切换B分支 <code>git checkout B</code><br>步骤三：拉取远程代码 <code>git pull</code><br>步骤四：检查有没有未提交的文件，有的话提交</p><pre><code>git statusgit commit -m &apos;&apos;</code></pre><p>步骤五：切换回A分支 <code>git checkout A</code><br>步骤六：cd进药合并的文件所在的文件夹 <code>cd /static/src/apps/login/store</code><br>步骤七：合并指定文件 <code>git merge B loginStore.js</code></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-查看分支&quot;&gt;&lt;a href=&quot;#1-查看分支&quot; class=&quot;headerlink&quot; title=&quot;1.查看分支&quot;&gt;&lt;/a&gt;1.查看分支&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;git branch 查看本地分支
git branch -a 查看所有分支
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&quot;http://static.zybuluo.com/shenweizheng/z2noezmkolv3clrzsv3kr3ys/image_1d29tb0vg1bu35spagp1spr1tqr14.png&quot; alt=&quot;image_1d29tb0vg1bu35spagp1spr1tqr14.png-3kB&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="git" scheme="http://shenweini.cn/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>hexo博客配置</title>
    <link href="http://shenweini.cn/2018/12/05/hexo%E5%8D%9A%E5%AE%A2%E9%85%8D%E7%BD%AE/"/>
    <id>http://shenweini.cn/2018/12/05/hexo博客配置/</id>
    <published>2018-12-05T08:30:21.000Z</published>
    <updated>2019-08-03T14:13:05.400Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-网站图标更换"><a href="#1-网站图标更换" class="headerlink" title="1.网站图标更换"></a>1.网站图标更换</h2><p>themes\hexo-theme-Annie\layout_partial\head.ejs<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link <span class="attribute">href</span>=<span class="string">"&lt;%- config.root %&gt;img/favicon.ico"</span> <span class="attribute">rel</span>=<span class="string">"Shortcut Icon"</span> <span class="attribute">type</span>=<span class="string">"image/ico"</span>&gt;</span><br></pre></td></tr></table></figure></p><p>我中间这个hexo-theme-Annie 是我的主题名字，只要路径差不多，找到layout_partial\head.ejs这个文件就对了，把你要换的那个ico文件放在根目录的public\img文件里面就行了，就是你放静态文件的那个目录。</p><a id="more"></a><h2 id="2-主题更换"><a href="#2-主题更换" class="headerlink" title="2.主题更换"></a>2.主题更换</h2><p>可以去hexo theme的官网找到你想要的主题，<a href="https://hexo.io/themes/" target="_blank" rel="noopener">hexo-theme</a>选择你喜欢的主题,以我的为例，我选的是Annie<img src="http://static.zybuluo.com/shenweizheng/91gzkw8d7exfxt76rujuznus/TIM%E6%88%AA%E5%9B%BE20181024000407.png" alt="TIM截图20181024000407.png-41.1kB"><br>然后点击这个主题，就可以找到这个主题的博客拥有者，这时候观察浏览器的地址栏的路由，<a href="https://sariay.github.io/" target="_blank" rel="noopener">https://sariay.github.io/</a> github.io前面这个sariay就是博主的github用户名了<br>然后我们主要在进 <a href="https://github.com/博主用户名，这里就是https://github.com/sariay" target="_blank" rel="noopener">https://github.com/博主用户名，这里就是https://github.com/sariay</a> 就可以找到博主的仓库了<br><img src="http://static.zybuluo.com/shenweizheng/lw0roum747u4lwi79scp4o3x/TIM%E6%88%AA%E5%9B%BE20181024000712.png" alt="TIM截图20181024000712.png-207.9kB"><br>这里我们找到我们所选的主题 hexo-theme-Annie 点进去<br><img src="http://static.zybuluo.com/shenweizheng/di0v7n85s3nfxxdjo44my531/TIM%E6%88%AA%E5%9B%BE20181024000819.png" alt="TIM截图20181024000819.png-109.5kB"><br>复制一下网址，然后我们cd进我们的博客文件夹，右击git bash here<br><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">clone</span> <span class="title">https</span>://github.com/Sariay/hexo-theme-Annie.git themes/hexo-theme-Annie</span><br></pre></td></tr></table></figure></p><p>这样我们就可以吧主题克隆到我们的本地，然后需求修改一下博客的配置文件_config.yml 找到theme字段<br><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">theme</span>: hexo-<span class="built_in">theme</span>-Annie</span><br></pre></td></tr></table></figure></p><p>修改theme后面的值是我们刚刚克隆下来的主题名，注意克隆下的那个主题文件夹不要去修改他的文件夹的名字，这边配置文件修改完之后，启动下本地服务就会发现主题已经更新好了。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-网站图标更换&quot;&gt;&lt;a href=&quot;#1-网站图标更换&quot; class=&quot;headerlink&quot; title=&quot;1.网站图标更换&quot;&gt;&lt;/a&gt;1.网站图标更换&lt;/h2&gt;&lt;p&gt;themes\hexo-theme-Annie\layout_partial\head.ejs&lt;br&gt;&lt;figure class=&quot;highlight routeros&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;link &lt;span class=&quot;attribute&quot;&gt;href&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;&amp;lt;%- config.root %&amp;gt;img/favicon.ico&quot;&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;rel&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;Shortcut Icon&quot;&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;type&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;image/ico&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;我中间这个hexo-theme-Annie 是我的主题名字，只要路径差不多，找到layout_partial\head.ejs这个文件就对了，把你要换的那个ico文件放在根目录的public\img文件里面就行了，就是你放静态文件的那个目录。&lt;/p&gt;
    
    </summary>
    
      <category term="HEXO博客" scheme="http://shenweini.cn/categories/HEXO%E5%8D%9A%E5%AE%A2/"/>
    
    
  </entry>
  
  <entry>
    <title>webpack配置及踩过的那些坑</title>
    <link href="http://shenweini.cn/2018/12/03/webpack%E9%85%8D%E7%BD%AE%E5%8F%8A%E8%B8%A9%E8%BF%87%E7%9A%84%E9%82%A3%E4%BA%9B%E5%9D%91/"/>
    <id>http://shenweini.cn/2018/12/03/webpack配置及踩过的那些坑/</id>
    <published>2018-12-03T07:19:47.000Z</published>
    <updated>2019-08-03T14:23:29.601Z</updated>
    
    <content type="html"><![CDATA[<p>最近学习了一波webpack打包部署，作为一名前端，不会一个打包的工具可真的是丢人啊。不过，用webpack又要接触到了配置文件，这个当初当我放弃写后端的东西，不过以后还是要全面发展的。好了，话不多说，这篇文章用的是webpack4.x版本的，下面将细数当初才过的坑。</p><a id="more"></a><h2 id="1-基础准备"><a href="#1-基础准备" class="headerlink" title="1.基础准备"></a>1.基础准备</h2><p>创建一个文件夹webpackDemo，我们使用命令行进入这个文件夹，运行 <code>npm init</code> 命令，初始化这个文件夹，初始化过程中出现的询问的一些配置，一路回车就好了。初始化好了之后，我们会发现文件夹里面已经多了package.json文件。<br><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install webpack --<span class="built_in">save</span>-<span class="built_in">dev</span> webpack-cli --<span class="built_in">save</span>-<span class="built_in">dev</span></span><br></pre></td></tr></table></figure></p><p>安装必要的 webpack 和 webpack-cli，安装成功之后的package.json文件如下</p><p><img src="http://static.zybuluo.com/shenweizheng/p03mjogf4044egkmgw1y3jzz/image_1csm6khqv45cj0i1plv1erc15ig9.png" alt="image_1csm6khqv45cj0i1plv1erc15ig9.png-26.8kB"></p><p>在根目录下创建如下的目录结构</p><p><img src="http://static.zybuluo.com/shenweizheng/6w2mp3ir0jcu9vahebdtg5n0/image_1csm6mqk21otcctql4fvdcpcpm.png" alt="image_1csm6mqk21otcctql4fvdcpcpm.png-10.4kB"></p><p>在<code>test.js</code>文件里面编写如下代码，一万年经典的Hello World</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">document.write(<span class="string">"Hello World"</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>在<code>index.html</code>里面编写代码<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width,initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Webpack初探<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./dist/js/bundle.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>这边引用一个<code>bundle.js</code>文件，<code>bundle.js</code>文件使我们打包之后生成的文件，接下来使用webpack的打包命令进行打包</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">webpack src<span class="regexp">/apps/</span>test.js -o dist<span class="regexp">/js/</span>bundle.js</span><br></pre></td></tr></table></figure><p>wepack的基础打包命令 <code>webpack {entryFile} -o {aimFile}</code> 执行完之后会发现我们的目录里已经生成了 <code>bundle.js</code> 文件，我们运行 <code>index.html</code> 文件，可以看到亲切的Hello World了。<br>打包过程中，出现的输出如下</p><p><img src="http://static.zybuluo.com/shenweizheng/0ky26he4f2kmgoddtgzdfpuo/image_1csm770vr12441ju3u61v1s49v2j.png" alt="image_1csm770vr12441ju3u61v1s49v2j.png-52.1kB"></p><p>这边会显示webpack打包一共花了501ms，打包后的 <code>bundle.js</code> 体积是957bytes，因为我们的代码比较简单，所以打包生成的文件还是很小的。</p><h2 id="2-webpack-config-js配置文件"><a href="#2-webpack-config-js配置文件" class="headerlink" title="2.webpack.config.js配置文件"></a>2.webpack.config.js配置文件</h2><p>在根目录下创建文件 <code>webpack.config.js</code> 这是weback运行所要依据的配置。大致分为入口配置，出口配置，loader配置，plugins配置</p><h3 id="2-1-entry和output"><a href="#2-1-entry和output" class="headerlink" title="2.1 entry和output"></a>2.1 entry和output</h3><p>entry配置的是入口文件，告诉webpack从哪个文件开始解析，分为单入口和多入口。有了入口，就要配置出口，配置打包生成的文件位置和文件名称。在<code>webpack.config.js</code>里面编写如下代码</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const <span class="built_in">path</span> = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line">module.exports = &#123;</span><br><span class="line">    entry: <span class="built_in">path</span>.resolve(__dirname, <span class="string">'src/apps/test.js'</span>),</span><br><span class="line">    <span class="built_in">output</span>: &#123;</span><br><span class="line">        <span class="built_in">path</span>: <span class="built_in">path</span>.resolve(__dirname, <span class="string">'dist'</span>),</span><br><span class="line">        filename: <span class="string">"js/bundle.js"</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先这边引用的<code>path</code>是<code>node.js</code>的一个模块，是用来解析路径用的，<code>path.resolve</code>指的是当前文件的所在路径，那么这边我们<code>entry</code>配置的就是<code>/src/apps/test.js</code>，这是单入口的配置形式。<br>下面对出口进行配置，output是一个对象，基础的两个属性，一个是输出文件的路径，另一个是输出文件的名称。<br>在<code>package.json</code>里面编写如下代码：</p><p><img src="http://static.zybuluo.com/shenweizheng/5fdepz23biva2ealjip37xvy/image_1csonnbu01u9340h1keo11d91nio9.png" alt="image_1csonnbu01u9340h1keo11d91nio9.png-10.9kB"></p><p>这边配置一下webpack的打包命令，之后通过<code>npm run start</code>进行打包，就不需要输一大串的命令了。打包一下我们可以看一下控制台的输出</p><p><img src="http://static.zybuluo.com/shenweizheng/68nmhoje7hk26hqsgfk6k2c1/image_1csonpuv21ev91ekv93i22k15gum.png" alt="image_1csonpuv21ev91ekv93i22k15gum.png-57.5kB"></p><p>发现有一个warning，这是因为我们还没有配置我们的mode，我们修改<code>webpack.config.js</code>文件</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const <span class="built_in">path</span> = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line">module.exports = &#123;</span><br><span class="line">    mode: <span class="string">'development'</span>,</span><br><span class="line">    devtool: <span class="string">'source-map'</span>,</span><br><span class="line">    entry: <span class="built_in">path</span>.resolve(__dirname, <span class="string">'src/apps/test.js'</span>),</span><br><span class="line">    <span class="built_in">output</span>: &#123;</span><br><span class="line">        <span class="built_in">path</span>: <span class="built_in">path</span>.resolve(__dirname, <span class="string">'dist'</span>),</span><br><span class="line">        filename: <span class="string">"js/bundle.js"</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在打包一下会发现这边的warning已经没有了。</p><h3 id="2-2-devtool配置"><a href="#2-2-devtool配置" class="headerlink" title="2.2 devtool配置"></a>2.2 devtool配置</h3><p>上面的配置文件我们是加了一个<code>devtool</code>的配置，这是因为webpack打包后的这个文件，我们可以看一下，已经不是我们所熟知的代码了，这样不方便于我们的调试，所以webpack为了解决这个问题，有一个<code>devtool</code>的配置。这边给一个别人博客的传送门<a href="https://www.jb51.net/article/134834.htm" target="_blank" rel="noopener">webpack之devtool详解</a>，<a href="https://webpack.js.org/configuration/devtool/#src/components/Sidebar/Sidebar.jsx" target="_blank" rel="noopener">webpack官方解释</a></p><h3 id="2-3-loader配置"><a href="#2-3-loader配置" class="headerlink" title="2.3 loader配置"></a>2.3 loader配置</h3><p>loader配置是webpack中的重点，因为webpack默认是只能处理html文件，如果要处理比如react应用中的jsx文件那么就需要配置一下loader，或者js、css等文件，都需要配置一下loader。这边已react应用为例。由于目前浏览器的兼容性问题，所以我们需要大量的插件和loader来转换我们写的高级js语法，就有了各种es6转es5，es7啥的。具体的还得好好研究。首先安装react相关的插件</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">npm</span> <span class="comment">install</span> <span class="comment">react</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">save</span> <span class="comment">react</span><span class="literal">-</span><span class="comment">dom</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">save</span></span><br></pre></td></tr></table></figure><p>安装解析react的相关插件和解析es6语法的相关插件。</p><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install babel-loader -<span class="built_in">save</span>-<span class="built_in">dev</span> babel-core --<span class="built_in">save</span>-<span class="built_in">dev</span> babel-preset-env --<span class="built_in">save</span>-<span class="built_in">dev</span> babel-preset-react --<span class="built_in">save</span>-<span class="built_in">dev</span></span><br></pre></td></tr></table></figure><p>babel-core<br>把 js 代码分析成 ast (抽象语法树, 是源代码的抽象语法结构的树状表现形式)，方便各个插件分析语法进行相应的处理。有些新语法在低版本 js 中是不存在的，如箭头函数，rest 参数，函数默认值等，这种语言层面的不兼容只能通过将代码转为 ast，再通过语法转换器分析其语法后转为低版本 js。</p><p>babel-preset-<em><br>babel-preset-</em> 代表了一系列的转码插件<br>有了 babel-plugin 系列，可以按需配置自己想要的特性，若是想搭个 es6 环境，一个个地配置各个插件，我猜你会疯掉。babel-preset 系列就可以满足我们的需求，babel-preset 系列打包了一组插件，类似于餐厅的套餐。如 babel-preset-es2015 打包了 es6 的特性，babel-preset-stage-0 打包处于 strawman 阶段的语法</p><p>下面看具体的配置，配置文件如下，这边首先我们要将package.json文件里面的babel-loader的版本更换成7.1.5然后重新安装一下模块，不然下面会因为babel-loader的版本问题出现打包失败的问题。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line"></span><br><span class="line">    mode: <span class="string">'development'</span>,</span><br><span class="line"></span><br><span class="line">    devtool: <span class="string">'source-map'</span>,</span><br><span class="line"></span><br><span class="line">    entry: path.resolve(__dirname, <span class="string">'src/apps/console.jsx'</span>),</span><br><span class="line"></span><br><span class="line">    output: &#123;</span><br><span class="line">        path: path.resolve(__dirname, <span class="string">'dist'</span>),</span><br><span class="line">        filename: <span class="string">"js/bundle.js"</span>,</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="keyword">module</span>: &#123;</span><br><span class="line">        rules: [&#123;</span><br><span class="line">            test: <span class="regexp">/(\.js)|(\.jsx)$/</span>,</span><br><span class="line">            exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">            use: &#123;</span><br><span class="line">                loader: <span class="string">'babel-loader'</span>,</span><br><span class="line">                options: &#123;</span><br><span class="line">                    presets: [<span class="string">'env'</span>, <span class="string">'react'</span>]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>test 指明要对哪一种后缀的文件进行解析，使用正则进行验证<br>exclude 规定一些文件夹或文件不参与解析<br>use.loader 配置使用的loader名称<br>use.option 配置loader的其他选项，这边的presets是告诉webpack解析react语法和es6语法。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// console.jsx</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mountNode = <span class="built_in">document</span>.getElementById(<span class="string">"root"</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">        <span class="keyword">super</span>(props)</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">Hello China!</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        );</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDOM.render(&lt;App /</span>&gt;, mountNode);</span><br></pre></td></tr></table></figure><p>执行<code>npm run start</code>，然后运行我们的index.html文件可以看到Hello China！。</p><h3 id="2-4-plugin配置"><a href="#2-4-plugin配置" class="headerlink" title="2.4 plugin配置"></a>2.4 plugin配置</h3><p>插件赋予了webpack更多的功能，比如说 js和css分离打包。比如说happyPack的多线程打包，比如说每次打包前自动清空dist目录。<br>以js、css分离打包为例，这是使用的<code>extract-text-webpack-plugin</code>插件，<br>首先安装一下，注意这边安装的是<code>extract-text-webpack-plugin@next</code>而不是<code>extract-text-webpack-plugin</code></p><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install --<span class="built_in">save</span>-<span class="built_in">dev</span> extract-text-webpack-plugin@<span class="built_in">next</span></span><br><span class="line">npm install style-loader --<span class="built_in">save</span>-<span class="built_in">dev</span> css-loader --<span class="built_in">save</span>-<span class="built_in">dev</span></span><br></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> ExtractTextPlugin = <span class="built_in">require</span>(<span class="string">'extract-text-webpack-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line"></span><br><span class="line">    mode: <span class="string">'development'</span>,</span><br><span class="line"></span><br><span class="line">    devtool: <span class="string">'source-map'</span>,</span><br><span class="line"></span><br><span class="line">    entry: path.resolve(__dirname, <span class="string">'src/apps/console.jsx'</span>),</span><br><span class="line"></span><br><span class="line">    output: &#123;</span><br><span class="line">        path: path.resolve(__dirname, <span class="string">'dist'</span>),</span><br><span class="line">        filename: <span class="string">"js/bundle.js"</span>,</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="keyword">module</span>: &#123;</span><br><span class="line">        rules: [&#123;</span><br><span class="line">            test: <span class="regexp">/(\.js)|(\.jsx)$/</span>,</span><br><span class="line">            exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">            use: &#123;</span><br><span class="line">                loader: <span class="string">'babel-loader'</span>,</span><br><span class="line">                options: &#123;</span><br><span class="line">                    presets: [<span class="string">'env'</span>, <span class="string">'react'</span>]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, &#123;</span><br><span class="line">            test: <span class="regexp">/\.css$/i</span>,</span><br><span class="line">            use: ExtractTextPlugin.extract(&#123;</span><br><span class="line">                fallback: <span class="string">'style-loader'</span>,</span><br><span class="line">                use: [<span class="string">'css-loader'</span>]</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;]</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="keyword">new</span> ExtractTextPlugin(&#123;</span><br><span class="line">            filename: <span class="string">'style/css/[name].css'</span>,</span><br><span class="line">            allChunks: <span class="literal">true</span> </span><br><span class="line">        &#125;)</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>###2.5 其他配置###</p><blockquote><p>stats配置</p></blockquote><p>在进行webpack打包的时候会出现很多的输出，但是有的输出是我们不需要看见的输出，这就可以采用stats进行配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">//</span> <span class="string">对webpack输出信息的配置，可以减少一些不必要的输出</span></span><br><span class="line"><span class="attr">stats:</span> <span class="string">&#123;</span></span><br><span class="line"><span class="attr">    children:</span> <span class="literal">false</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><blockquote><p>resolve.extensions 解决引入模块不需要加后缀<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// extensions 自动解决扩展，配置这个在引用模块时不用加后缀</span><br><span class="line">// modules 配置解析模块的搜索目录</span><br><span class="line">// path.<span class="built_in">resolve</span> 返回参数的绝对路径  path.<span class="keyword">join</span> 拼接路径 然后返回绝对路径</span><br><span class="line"><span class="built_in">resolve</span>: &#123;</span><br><span class="line">        module<span class="variable">s:</span> [path.<span class="built_in">resolve</span>(__dirname, <span class="string">'node_modules'</span>), path.<span class="keyword">join</span>(__dirname, <span class="string">'src'</span>)],</span><br><span class="line">        extension<span class="variable">s:</span> [<span class="string">'.wasm'</span>, <span class="string">'.mjs'</span>, <span class="string">'.js'</span>, <span class="string">'.json'</span>, <span class="string">'.jsx'</span>]</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>optimization配置 抽离公共模块<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">optimization</span>: &#123;</span><br><span class="line">    <span class="attribute">minimize</span>: false,</span><br><span class="line">    <span class="attribute">splitChunks</span>: &#123;</span><br><span class="line">        <span class="attribute">chunks</span>: <span class="string">'all'</span>,</span><br><span class="line">        <span class="attribute">name</span>: <span class="string">'common'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></p></blockquote><h2 id="last-一些解释及踩过的那些坑"><a href="#last-一些解释及踩过的那些坑" class="headerlink" title="last.一些解释及踩过的那些坑"></a>last.一些解释及踩过的那些坑</h2><p>###last.1 npm install 的时候 –save-dev 和–save的区别</p><p>首先这边的 <code>--save</code> 是将我们install的包写进package.json文件里面，后面的-dev才是要描述的重点，<code>-dev</code>是写进我们的<code>devDependencies</code>里面，如果不加这个那么是写进<code>dependencies</code>里面的，在生产环境下，是不会安装<code>devDependencies</code>里面的包的。这边找了一个别人的博客，写的比我这个更全面一点。<a href="https://www.cnblogs.com/blackgan/p/7678868.html" target="_blank" rel="noopener">对–save-dev和–save的区别详解</a></p><p>###last.2 webpack基础命令打包的时候报ERROR in multi ./src/apps/test.js dist/js/bundle.js<br>Module not found: Error: Can’t resolve ‘dist/js/bundle.js’ in ‘F:\WebDemo\webpackDemo’</p><p>这是因为webpack的版本问题，在webpack4.x版本之前的打包命令是<br><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml">webpack </span><span class="template-variable">&#123;entryFile&#125;</span><span class="xml"> </span><span class="template-variable">&#123;aimFile&#125;</span><span class="xml"></span></span><br></pre></td></tr></table></figure></p><p>但是在webpack4.x开始基础打包命令就变成了<br><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class">webpack </span>&#123;entryFile&#125; -<span class="class">o </span>&#123;aimFile&#125;</span><br></pre></td></tr></table></figure></p><p>###last.3出现Error: Cannot find module ‘@babel/core’###<br>这是因为<code>babel-loader</code>版本的问题，如果之前我们安装<code>babel-loader</code>的时候是采用<code>npm install babel-loader</code>这样写的话是默认安装最新版本的<code>babel-loader</code>最新的是8.x的，我们回退到7.1.5版本就可以避免这个报错了。</p><p>###last.4 webpack-dev-server问题 ###<br>1.webpack-dev-server 不会读取webpack.config.js配置的output也不会将生产的文件添加进项目目录里<br>2.webpack-dev-server 生成的文件和你dist里面的文件不是同一个文件。dist里面的是output里面决定<br>的webpack-dev-server打包生成的文件位置取决于contentBase配置</p><p>###last.5 的 package.json里面的打包命令###<br>–colors 输出结果带有颜色<br>–profile 输出性能数据看见每一步的耗时<br>–proress 输出当前的编译进度<br>–display-error-details 输出详细的错误信息</p><p>###lats.6 使用extractTextPlugin时报 Chunk.entrypoints: Use Chunks.groupsIterable and filter by instanceof Entrypoint instead###<br>这是因为安装<code>extract-text-webpack-plugin</code>的时候安装命令问题，实际上我们需要安装的是<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">"<span class="selector-tag">extract-text-webpack-plugin</span>": "^4<span class="selector-class">.0</span><span class="selector-class">.0-beta</span><span class="selector-class">.0</span>",</span><br></pre></td></tr></table></figure></p><p>解决办法，删除之前安装的extract插件，更换安装命令为<br><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --<span class="built_in">save</span>-<span class="built_in">dev</span> extract-text-webpack-plugin@<span class="built_in">next</span></span><br></pre></td></tr></table></figure></p><p>###last.7 入口文件配置[name].js 但是打包出来的文件总是main.js并不会根据入口名称决定出口名称###<br>这边的main.js main是取决你的主入口的，就是在执行npm init的时候那一堆默认的主入口。之所以没有按照入口文件来改变出口文件的名称，是因为入口文件采用的单入口的形式，也就是如下写法<br><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">entry</span>: path.resolve(__dirname, <span class="symbol">'src</span>/apps/console.jsx')</span><br></pre></td></tr></table></figure></p><p>使用单入口的形式，那么<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">output</span>: &#123;</span><br><span class="line">        <span class="attribute">path</span>: path.<span class="built_in">resolve</span>(__dirname, <span class="string">'dist'</span>),</span><br><span class="line">        filename: <span class="string">'js/[name].js'</span></span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure></p><p>打包生成的文件只会有一个main.js 并不会生成console.js<br>解决办法是将单入口的写法换成多入口的形式，也就是下面这种写法<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">entry</span>: &#123;</span><br><span class="line">        <span class="attribute">console</span>: path.<span class="built_in">resolve</span>(__dirname, <span class="string">'src/apps/console'</span>)</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure></p><p>这样打包出来的文件就是console.js</p><p>###last.7 bundle.js和vendor.js的引入顺序问题###<br>vendor.js一定是最先引用的，因为bundle.js要依赖于vendor.js生存。</p><p>###last.8 名词解释 ###<br>webpack.config.dev.js 开发环境下的webpack配置文件<br>webpack.config.prod.js 生产环境下的配置文件<br>vendor.js 这是打包我们引入的第三方包的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近学习了一波webpack打包部署，作为一名前端，不会一个打包的工具可真的是丢人啊。不过，用webpack又要接触到了配置文件，这个当初当我放弃写后端的东西，不过以后还是要全面发展的。好了，话不多说，这篇文章用的是webpack4.x版本的，下面将细数当初才过的坑。&lt;/p&gt;
    
    </summary>
    
    
      <category term="js" scheme="http://shenweini.cn/tags/js/"/>
    
      <category term="webpack" scheme="http://shenweini.cn/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>腾讯云服务器配置JDK，tomcat解决外网无法访问问题</title>
    <link href="http://shenweini.cn/2018/11/10/%E8%85%BE%E8%AE%AF%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AEJDK%EF%BC%8Ctomcat%E8%A7%A3%E5%86%B3%E5%A4%96%E7%BD%91%E6%97%A0%E6%B3%95%E8%AE%BF%E9%97%AE%E9%97%AE%E9%A2%98/"/>
    <id>http://shenweini.cn/2018/11/10/腾讯云服务器配置JDK，tomcat解决外网无法访问问题/</id>
    <published>2018-11-10T04:26:58.000Z</published>
    <updated>2019-08-03T14:22:06.852Z</updated>
    
    <content type="html"><![CDATA[<p>前几天试了一下腾讯云的学生服务器，在配置tomcat的时候，配置了好久，一直都是无法访问主页，翻看了N多的博客，关了防火墙，配置了安全组，依旧无法访问，接下来改了tomcat的配置终于成功，记录一下。<br>我用的是腾讯云的学生服务器，操作系统是CentOS7.2 64位 JDK版本是1.8.0 tomcat版本是8.5.34<br>准备一下XShell工具，我是使用的XShell。还有一个WinScp工具用来上传文件，当然也可以使用命令，但是我感觉有点慢，不懂是不是错觉。</p><a id="more"></a><h2 id="1-配置JDK"><a href="#1-配置JDK" class="headerlink" title="1.配置JDK"></a>1.配置JDK</h2><p>网上看到了很多配置jdk的方法，相对而言，配置一下jdk还是很简单。我是使用的直接解压linux版本的jdk文件然后配置下环境变量，当然也有的是直接使用yum安装jdk。那么我们首先去<a href="https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html" target="_blank" rel="noopener">jdk官网</a>下载一下jdk<br><img src="http://static.zybuluo.com/shenweizheng/d6as8u57y5cwx0zklb2l8ubg/image_1crsc1nek1797gbtv7i1rfvpiv9.png" alt="image_1crsc1nek1797gbtv7i1rfvpiv9.png-103.2kB"></p><p>这边我们用的是后缀为.tar.gz的，这是linux版本的<br>使用我们的WinScp工具把我们刚刚的下载的jdk上传至我们的服务器。用XShell登录进服务器，这边有一个问题就是我看到有的博客是说一开始进去的时候不是root用户但是我这边是进去就是root用户。下面的所有的配置我们都是要在root用户下进行的。<br><img src="http://static.zybuluo.com/shenweizheng/dpu4hunouaswrrmozaq12750/image_1crscssno10vipt7m0e37m1rfd13.png" alt="image_1crscssno10vipt7m0e37m1rfd13.png-21.9kB"></p><p>如果你不是root用户而是ubuntu用户那么<br><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">sudo su</span></span><br></pre></td></tr></table></figure></p><p>切换进root用户，当然我没有遇到这个问题。<br><img src="http://static.zybuluo.com/shenweizheng/jewd66ybvwimbvixxk3lxl4f/image_1crtp2a1sb8t10vtdsd1475dgs9.png" alt="image_1crtp2a1sb8t10vtdsd1475dgs9.png-25.8kB"><br>ls一下查看现在的根目录，解压jdk</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf jdk-<span class="number">8</span>u191-linux-x64<span class="selector-class">.tar</span><span class="selector-class">.gz</span></span><br></pre></td></tr></table></figure><p>ls查看一下解压成功</p><p><img src="http://static.zybuluo.com/shenweizheng/r5nqg0utk1vumr6jqro13xkp/image_1crtp97csdms3kc15pv10c01jkr16.png" alt="image_1crtp97csdms3kc15pv10c01jkr16.png-7.4kB"></p><p>接下来在/usr下面创建一下文件夹叫java</p><p><img src="http://static.zybuluo.com/shenweizheng/o3c26xka6jvyiwo7nesvgiv9/image_1crtpt60a3271k911pcd1c4boqf1j.png" alt="image_1crtpt60a3271k911pcd1c4boqf1j.png-10.8kB"></p><p>接下来把我们解压好的jdk放到上一步创建的文件夹下面</p><p><img src="http://static.zybuluo.com/shenweizheng/9qxwwuaubcriiuqy62j7jg38/image_1crtq214a1r2lav3t7svm8144c20.png" alt="image_1crtq214a1r2lav3t7svm8144c20.png-5kB"></p><p>下面就是配置jdk的环境变量，我们需要修改 /etc/profile文件</p><p><img src="http://static.zybuluo.com/shenweizheng/hretoz8xtgh5byccpiydt2fj/image_1crtq922b1kt1jmb15ri16on5sb2d.png" alt="image_1crtq922b1kt1jmb15ri16on5sb2d.png-2.7kB"></p><p>配置一下JAVA_HOME CLASSPATH PATH<br><img src="http://static.zybuluo.com/shenweizheng/gogfsd3z7zlxc8zjcvfk8gfy/image_1crtqakkmm3s1a6103c1duq1be2q.png" alt="image_1crtqakkmm3s1a6103c1duq1be2q.png-75.5kB"></p><p>按esc之后 :wq 保存退出编辑，不得不说linux命令还是要会的，多多少少会用到linux的东西<br>使用source命令使我们刚刚做的修改生效，使用java -version检查我们的配置是否正确<br><img src="http://static.zybuluo.com/shenweizheng/wx9rjeszrp6a80sx5x2lnffr/image_1crtqesme1pmnldm1ltm12u71uq737.png" alt="image_1crtqesme1pmnldm1ltm12u71uq737.png-15.3kB"></p><p>到此为止jdk的配置已经做完了，下面就是tomcat的配置，也是本章的重点，拿笔开始记笔记了。</p><h2 id="2-Tomcat配置以及外网无法访问问题"><a href="#2-Tomcat配置以及外网无法访问问题" class="headerlink" title="2.Tomcat配置以及外网无法访问问题"></a>2.Tomcat配置以及外网无法访问问题</h2><p>首先第一步我们得去下一个tomcat和jdk一样，这边给一个传送门<a href="https://tomcat.apache.org/download-80.cgi" target="_blank" rel="noopener">tomcat8.5</a><br><img src="http://static.zybuluo.com/shenweizheng/7i5yo5ja413q6abv4oflxlg8/image_1crtqmg8s4ap1joo1ls219a2140k3k.png" alt="image_1crtqmg8s4ap1joo1ls219a2140k3k.png-93.4kB"></p><p>老样子还是下.tar.gz的，接下来上传tomcat，解压tomcat，将解压好的文件夹移至我们的/usr/java文件夹下面，当然你也可以重新建一个，这都是小事。</p><p>我们进入java文件夹，ls一下现在是有两个文件夹，一个是我们上面的jdk另一个是刚刚的tomcat</p><p><img src="http://static.zybuluo.com/shenweizheng/1jujj0042crmuqpr3nhq01he/image_1crtqu1pvaag1fcn4ld123vpdl41.png" alt="image_1crtqu1pvaag1fcn4ld123vpdl41.png-9.4kB"></p><p>那么下面就是tomcat的问题，首先我们去修改一下tomcat的端口号，默认是8080我们这边修改成80。修改conf/server.xml文件</p><p><img src="http://static.zybuluo.com/shenweizheng/m481dibr6w5yrraphxtm425r/image_1crtr550hecc8krk3e1spm18e14e.png" alt="image_1crtr550hecc8krk3e1spm18e14e.png-87.4kB"></p><p>接下来就是启动我们的tomcat先看一下能不能访问。启动程序和关闭程序在 bin目录下有一个startup.sh 和shutdown.sh<br><img src="http://static.zybuluo.com/shenweizheng/wfhcb1ul4humux1pedea0xuo/image_1crtr8o56c35t577c01j8n1e3d4r.png" alt="image_1crtr8o56c35t577c01j8n1e3d4r.png-23.9kB"></p><p>如果这一步遇到 -bash: startup.sh not command这种报错时<br><img src="http://static.zybuluo.com/shenweizheng/kmv88x25dvqaps4h54xmgps2/image_1crtrcipe1nla1bfd1honj199j458.png" alt="image_1crtrcipe1nla1bfd1honj199j458.png-3.3kB"></p><p>然后再执行startup.sh文件，这样就可以了。<br>那么我们这边开启了tomcat，使用外网ip加端口号访问一下看看情况。<br>如果你不能访问，首先配置一下云服务器的安全组，这边我们直接默认全部端口都放通，当然你也可以自定义配置一下规则。<br><img src="http://static.zybuluo.com/shenweizheng/5fo9j5yft5genj37nn2kuume/image_1crtrkq1k1d56sa6i1l18vf97t5l.png" alt="image_1crtrkq1k1d56sa6i1l18vf97t5l.png-134.3kB"></p><p>接下来重启一下服务器，不知道要不要重启，反正我是重启了一下。之后再去访问一下80端口，看能不能出现tomcat的主页，如果还是不行，那么接下去我们继续配置，这边安全组是已经都开启了，接下来我们查看80端口有没有开启。<br><img src="http://static.zybuluo.com/shenweizheng/ajfaio341tmx3l9idey0ylsq/image_1crtrscii1ls21anrl9417411oq762.png" alt="image_1crtrscii1ls21anrl9417411oq762.png-20.2kB"></p><p>我这边是已经配置好了的，所以80端口是开启的，如果你的80端口没有开启，那么下面我们去搞一下防火墙。<br>首先我们查看一下防火墙的状态<br><img src="http://static.zybuluo.com/shenweizheng/xnj3z2ymgshz32aylpes248g/image_1crts1red1bu81bfd50d4q1dio6f.png" alt="image_1crts1red1bu81bfd50d4q1dio6f.png-14.5kB"></p><p>发现现在防火墙是关闭的，这边我们先开启一下防火墙，不然待会出现filreWalld not runnuind的错<br><img src="http://static.zybuluo.com/shenweizheng/xs7nmzqmlgvdzwi1anzg7cvf/image_1crtsqrhpmbqirf1n2g17p0n2s6s.png" alt="image_1crtsqrhpmbqirf1n2g17p0n2s6s.png-10.2kB"></p><p>这边配置好了之后，我们在吧防火墙关闭一下<br><code>systemctl stop firewalld</code>，我们进入tomcat的bin目录下重启一下服务器。<br><img src="http://static.zybuluo.com/shenweizheng/objwn9diivl04baejjzuw4ru/image_1crtssq284be17641u821v391dgc79.png" alt="image_1crtssq284be17641u821v391dgc79.png-83.6kB"></p><p>如果你在关闭的时候遇到Neither the JAVA_HOME nor the JRE_HOME environment variable is defined这个报错的时候，使用vim修改一下bin目录下的setclasspath.sh，手动添加JAVA_HOME和JRE_HOME两个环境变量。<br><img src="http://static.zybuluo.com/shenweizheng/i7us0bl35qtytmr8ie00rchh/image_1crtt3g1d1lno1552p601sr325f83.png" alt="image_1crtt3g1d1lno1552p601sr325f83.png-269.3kB"></p><p>关闭之后，在启动一下tomcat，打开浏览器，访问公网ip访问，出现tomcat主页。如果还是没有出现的话，就无能为力了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前几天试了一下腾讯云的学生服务器，在配置tomcat的时候，配置了好久，一直都是无法访问主页，翻看了N多的博客，关了防火墙，配置了安全组，依旧无法访问，接下来改了tomcat的配置终于成功，记录一下。&lt;br&gt;我用的是腾讯云的学生服务器，操作系统是CentOS7.2 64位 JDK版本是1.8.0 tomcat版本是8.5.34&lt;br&gt;准备一下XShell工具，我是使用的XShell。还有一个WinScp工具用来上传文件，当然也可以使用命令，但是我感觉有点慢，不懂是不是错觉。&lt;/p&gt;
    
    </summary>
    
    
      <category term="服务器" scheme="http://shenweini.cn/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
  </entry>
  
</feed>
